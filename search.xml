<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>FAQ-DLL生成DEF-DEF生成LIB</title>
    <url>/%E5%85%B6%E4%BB%96/FAQ/FAQ-DLL%E7%94%9F%E6%88%90DEF-DEF%E7%94%9F%E6%88%90LIB/</url>
    <content><![CDATA[<p>DLL生成DEF</p>
<p>使用方法，将pexports.exe放到X:\Microsoft Visual Studio X.0\VC\bin目录下，在命令行里输入pexports x.dll &gt; x.def</p>
<p>DEF生成LIB</p>
<p>然后在输入lib /machine:ix86 /def:x.def<br>即在当前目录生成x.lib</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>FAQ-LoadLibrary找不到指定的模块</title>
    <url>/%E5%85%B6%E4%BB%96/FAQ/FAQ-LoadLibrary%E6%89%BE%E4%B8%8D%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<ol>
<li>到网上下载一个Dependency Walker(简称depends)工具，该工具主要是用来检查某个文件的运行需要使用哪些链接库。下载后直接双击Depends.exe打开，然后点文件-〉打开，选择你要检查的文件，然后会出现下面的画面：</li>
</ol>
<img src="/其他/FAQ/FAQ-LoadLibrary找不到指定的模块/FAQ-LoadLibrary找不到指定的模块-1.png">
<p>可以看到左上角是该控件所需要的所有的动态链接库，右边是每个链接库的具体信息，最下面一栏显示状态，之前因为少装了4个链接库，下面就会显示缺少xxxx，中间的那部分第一栏模块名称那里会用红色表示缺少的模块。</p>
<ol start="2">
<li><p>到网上找到那几个链接库，然后把它们放到%systemroot%\WINDOWS\system32下面。</p>
</li>
<li><p>在开始-〉运行里键入regsvr32 xxxxx.ocx，该控件就成功注册了！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>FAQ-error-LNK2005</title>
    <url>/%E5%85%B6%E4%BB%96/FAQ/FAQ-error-LNK2005/</url>
    <content><![CDATA[<p>如果在编译MFC程序的时候出现下列及类似的错误：</p>
<p>1&gt;uafxcwd.lib(afxmem.obj) : error LNK2005: “void <em> <strong>cdecl operator new(unsigned int)” (??2@YAPAXI@Z) 已经在 LIBCMTD.lib(new.obj) 中定义<br>1&gt;uafxcwd.lib(afxmem.obj) : error LNK2005: “void </strong>cdecl operator delete(void </em>)” (??3@YAXPAX@Z) 已经在 LIBCMTD.lib(dbgdel.obj) 中定义<br>1&gt;uafxcwd.lib(afxmem.obj) : error LNK2005: “void <em> <strong>cdecl operator new<a href="unsigned int"></a>“ (??_U@YAPAXI@Z) 已经在 libcpmtd.lib(newaop.obj) 中定义<br>1&gt;uafxcwd.lib(afxmem.obj) : error LNK2005: “void </strong>cdecl operator delete[](void </em>)” (??_V@YAXPAX@Z) 已经在 LIBCMTD.lib(delete2.obj) 中定义</p>
<p>解决方法如下：<br>项目属性页-》链接器-》输入</p>
<p>做如下改动，注意顺序</p>
<p>附加依赖库：uafxcwd.lib;LIBCMTD.lib;</p>
<p>忽略特定默认库：LIBCMTD.lib;uafxcwd.lib</p>
<p>转自:<a href="http://blog.csdn.net/dotphoenix/article/details/13511863" target="_blank" rel="noopener">http://blog.csdn.net/dotphoenix/article/details/13511863</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>FAQ-mybatis关于oracle-in-1000个数限制的解决</title>
    <url>/%E5%85%B6%E4%BB%96/FAQ/FAQ-mybatis%E5%85%B3%E4%BA%8Eoracle-in-1000%E4%B8%AA%E6%95%B0%E9%99%90%E5%88%B6%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>Oralce in 语句中当in(1,2,3…) 条件数量大于1000将会报错。</p>
<p>如果我们把in拆分成多个in就可以解决这个问题。<br>修改前</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> tbl_temp</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line"><span class="keyword">id</span> <span class="keyword">in</span></span><br><span class="line">&lt;foreach item=<span class="string">"item"</span> <span class="keyword">index</span>=<span class="string">"index"</span> collection=<span class="string">"ids"</span> <span class="keyword">open</span>=<span class="string">"("</span> separator=<span class="string">","</span> <span class="keyword">close</span>=<span class="string">")"</span>&gt;</span><br><span class="line">	<span class="comment">#&#123;item&#125;</span></span><br><span class="line">&lt;/foreach&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> tbl_temp</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line"><span class="keyword">id</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>修改后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> tbl_temp</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">&lt;foreach item=<span class="string">"item"</span> <span class="keyword">index</span>=<span class="string">"index"</span> collection=<span class="string">"ids"</span> <span class="keyword">open</span>=<span class="string">"("</span> separator=<span class="string">"or"</span> <span class="keyword">close</span>=<span class="string">")"</span>&gt;</span><br><span class="line">	<span class="keyword">id</span> <span class="keyword">in</span> <span class="comment">#&#123;item&#125;</span></span><br><span class="line">&lt;/foreach&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> tbl_temp</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">(<span class="keyword">id</span> <span class="keyword">in</span> <span class="number">1</span> <span class="keyword">or</span> <span class="keyword">id</span> <span class="keyword">in</span> <span class="number">2</span> <span class="keyword">or</span> <span class="keyword">id</span> <span class="keyword">in</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>FAQ-如何解决VC中的警告Warning-C4251</title>
    <url>/%E5%85%B6%E4%BB%96/FAQ/FAQ-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3VC%E4%B8%AD%E7%9A%84%E8%AD%A6%E5%91%8AWarning-C4251/</url>
    <content><![CDATA[<p>转载自:<a href="http://wwywnp.blog.163.com/blog/static/16372208720112109039559/" target="_blank" rel="noopener">http://wwywnp.blog.163.com/blog/static/16372208720112109039559/</a></p>
<p>这通常是由于以数据成员方式在DLL导出类中使用了模板类造成的。比如：</p>
<p>#include <iostream></iostream></p>
<p>#include <vector><br>using namespace std;</vector></p>
<p>class __declspec( dllexport ) Test<br>{<br>public:<br>std::vector<int> m_objCon;<br>};</int></p>
<p>int main()<br>{</p>
<p>return 0;<br>}</p>
<p>这会导致这个警告:<br>warning C4251: “Test::m_objCon”: class“std::vector&lt;_Ty&gt;”需要有 dll 接口由 class“Test”的客户端使用<br>1&gt;        with<br>1&gt;        [<br>1&gt;            _Ty=int<br>1&gt;        ]<br>这个问题主要要描述的是不同的地方的vector的实现可能不一样所造成的问题。所以我们应该将其导出。有很多方法可以解决这个问题的。</p>
<p>第一种： 无视它或者#pragma warnind( disable: 4251 )<br>第二种：将该数据改为指针方式：<br>class __declspec( dllexport ) Test<br>{<br>public:<br>std::vector<int>* m_objCon;<br>};<br>然后在构造函数和析构函数中分别初始化和释放它。<br>第三种：<br>将该模板类及其依赖类导出。</int></p>
<p>#include <iostream></iostream></p>
<p>#include <vector><br>using namespace std;</vector></p>
<p>class <strong>declspec( dllexport ) Test<br>{<br>public:<br>template  class </strong>declspec( dllexport ) std::allocator<int>;<br>template  class __declspec( dllexport ) std::vector&lt;int, std::allocator<int> &gt;;<br>public:</int></int></p>
<p>std::vector<int> m_objCon;<br>};</int></p>
<p>int main()<br>{</p>
<p>return 0;<br>}<br>这种方法要注意的是必须要把要导出模板类的模板数据成员一并导出。有点类似于显式实例化。比如说你要导出boost::shared_ptr就还必须将其依赖的shared_count一并导出。导出map还需要导出对应pair等等。很麻烦啦~所以我们还是选择第四种吧。</p>
<p>第四种：Impl。</p>
<p>#include <iostream></iostream></p>
<p>#include <vector><br>using namespace std;</vector></p>
<p>// 这些放到.h中<br>class Test_imp;<br>class __declspec( dllexport ) Test<br>{<br>// 构造函数中初始化 析构中释放m_pImp;<br>void test();<br>public:<br>Test_imp* m_pImp;<br>};</p>
<p>// 这个类放到cpp中去<br>class  Test_imp<br>{<br>public:<br>void test(){}<br>std::vector<int> m_objCon;<br>};</int></p>
<p>// 放到cpp中<br>void Test::test()<br>{<br>m_pImp-&gt;test();<br>}</p>
<p>int main()<br>{</p>
<p>return 0;<br>}</p>
<p>个人推荐第二种和第四种，反对第一种。毕竟掩耳盗铃不是好习惯~~<br>第四种除了可以解决上面的问题之外还可以隐藏代码，当然多了一个桥接的过程。</p>
<p>程序中消除warning有两种方法：消极一点不去理他，反正不是error:-)；积极一点，则想办法去掉。去掉又用两种方法：一种使用#pragma warning(disable: xxxx)，眼不见，心不烦；另外就是找出解决问题的办法了。<br>今天做dll库时，在struct中用到了stl：<br>class CLASS_TEST<br>{<br>    …<br>private:<br>    std::vector&lt;MY_STRUCT&gt; m_structs;<br>}<br>但是编译时，vs2005给出了warning C4251: ‘CLASS_TEST::m_structs’ : class ‘std::vector&lt;_Ty&gt;’ needs to have dll-interface to be used by clients of class ‘CLASS_TEST’的警告信息。费了很大的劲才解决掉，记录下来。</p>
<p>在头文件中，定义宏</p>
<p>#ifdef MYDLL_EXPORTS</p>
<p>#define MYDLL_API __declspec(dllexport)</p>
<p>#else</p>
<p>#define MYDLL_API __declspec(dllimport)</p>
<p>#endif</p>
<p>现在，在变量m_structs前，添加：<br>template class MYDLL_API std::allocator<mystruct>;<br>template class MYDLL_API std::vector&lt;myStruct, std::allocator<mystruct> &gt;;<br>这样，即可以了。</mystruct></mystruct></p>
<p>另一篇:</p>
<p>1:情况一<br>如果类的定义里面仅含有 编译器内置的类型变量, int, float 等等. 或者成员函数仅使用了这些变量作为参数, 那么很简单.<br>直接<br>class __declspec(dllexport) YourClass</p>
<p>{<br>}<br>就行了.</p>
<p>2:情况二<br>如果类内部使用了别的类, 那么别的类最好也导出, 不然, 首先编译的时候会出现编译警告:<br>warning C4251: needs to have dll-interface<br>意思是,你使用另外的一些类型/接口, 但是这些类型或接口没有导出. 当你的client使用这些类型/接口的时候, 会出错!<br>class __declspec(dllexport) YourClass</p>
<p>{<br>   YourAnatherClass m_data; // 这里会 出现 warning 4251. 如果YourAnatherClass 没有导出的话.<br>}<br>解决办法就是: 在YourAnatherClass定义的地方加上<br>class __declspec(dllexport) YourAnatherClass<br>{<br>}<br>如上, 当你的YourAnatherClass没有导出的时候, dll的使用方会出现链接错误</p>
<p>3:情况三<br>当类的内部使用了STL模板的时候, 也会出现C4251警告, 情况会有所不同<br>class __declspec(dllexport) YourClass</p>
<p>{<br>   vector<int> m_data; // 这里会 出现 warning 4251. 因为vector<int>类型没有被导出<br>}<br>上面的使用模板(无论是stl模板,还是自定义模板)的代码,编译dll时会出现C4251警告, 但是dll的使用方, 却不会出现链接错误!!!<br>这个因为, dll的使用方那里也有一套模板的定义, 当他们使用那个vector<int>的时候, 虽没有导出, 但是用户自己也有一套STL模板(或者是自定义的模板),用户会利用自己的模板实例化这个dll中没有导出的东西!</int></int></int></p>
<p>所以, 对于因为使用STL(或模板)出现的c4251警告, 关闭之即可</p>
<p>#pragma warning(push)</p>
<p>#pragma warning(disable:4251)<br>//your declarations that cause 4251</p>
<p>#pragma warning(pop)</p>
<p>若想不使用通过关闭警告的方式关闭警告, 那么就这样<br>1)对于用户自定义的模板<br>   template class DLLImportExportMacro SomeTemplate<int>;<br>   SomeTemplate<int> y;<br>2)对于STL的模板<br>     template class DLLImportExportMacro std::allocator<int><br>     template class DLLImportExportMacro std::vector&lt;int,<br>      std::allocator<int> &gt;;<br>     vector<int> m_data;</int></int></int></int></int></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>HotSpot实战-1内核框架</title>
    <url>/Java/Java/HotSpot%E5%AE%9E%E6%88%98-1%E5%86%85%E6%A0%B8%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><h3 id="源代码下载"><a href="#源代码下载" class="headerlink" title="源代码下载"></a>源代码下载</h3><h3 id="Hotspot源码目录结构概览"><a href="#Hotspot源码目录结构概览" class="headerlink" title="Hotspot源码目录结构概览"></a>Hotspot源码目录结构概览</h3><table>
<thead>
<tr>
<th>目录</th>
<th></th>
<th></th>
<th></th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>agent</td>
<td></td>
<td></td>
<td></td>
<td>Serviceability Agent(可维护性代理)</td>
</tr>
<tr>
<td>make</td>
<td></td>
<td></td>
<td></td>
<td>编译hotspot的makefile文件</td>
</tr>
<tr>
<td>src</td>
<td></td>
<td></td>
<td></td>
<td>主体源代码</td>
</tr>
<tr>
<td></td>
<td>cpu</td>
<td></td>
<td></td>
<td>依赖具体处理器架构的代码(ppc,sparc,x86,zero)</td>
</tr>
<tr>
<td></td>
<td>os</td>
<td></td>
<td></td>
<td>依赖操作系统的代码(bsd,linux,posix,solaris,windows)</td>
</tr>
<tr>
<td></td>
<td>os_cpu</td>
<td></td>
<td></td>
<td>同时依赖操作系统和处理器的代码</td>
</tr>
<tr>
<td></td>
<td>share</td>
<td></td>
<td></td>
<td>操作系统和处理器无关的代码(vm,tools)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>vm</td>
<td></td>
<td>实现虚拟机各项功能</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>adlc</td>
<td>平台描述文件</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>asm</td>
<td>汇编器</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c1</td>
<td>C1编译器,client编译器</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>ci</td>
<td>动态编译器</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>classfile</td>
<td>class文件解析和类的链接等</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>code</td>
<td>机器码生成</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>compiler</td>
<td>调用动态编译器</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>gc_implementation</td>
<td>gc实现</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>gc_interface</td>
<td>gc接口</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>interpreter</td>
<td>解释器</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>libadt</td>
<td>抽象数据结构</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>memory</td>
<td>内存管理</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>oops</td>
<td>jvm内部对象表示</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>opto</td>
<td>C2编译器,server编译器</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>precompiled</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>prims</td>
<td>hotspot对外接口</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>runtime</td>
<td>运行时</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>services</td>
<td>jmx接口</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>shark</td>
<td>基于LLVM实现的即时编译器</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>trace</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>utilizes</td>
<td>内部工具类和公共函数</td>
</tr>
<tr>
<td></td>
<td></td>
<td>tools</td>
<td></td>
<td>独立的虚拟机工具程序</td>
</tr>
<tr>
<td>test</td>
<td></td>
<td></td>
<td></td>
<td>测试用例</td>
</tr>
</tbody>
</table>
<h3 id="Prims"><a href="#Prims" class="headerlink" title="Prims"></a>Prims</h3><p>prims模块定义了外部接口，允许外部程序访问内部状态信息。</p>
<p>比如，jni模块，jvm模块，jvmti模块，perf模块。</p>
<h3 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h3><p>services模块主要包含9个主要子模块(management,memory service,thread service, runtime service, memory manager, heap dumper, classloading service, memory pool,attach listener)。</p>
<h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>runtime是运行时模块，为其他系统组件提供运行时支持,如线程、安全点、PerfData、Stub例程、反射、VMOperation以及互斥锁等组件。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HotSpot实战</tag>
      </tags>
  </entry>
  <entry>
    <title>HotSpot实战-2启动</title>
    <url>/Java/Java/HotSpot%E5%AE%9E%E6%88%98-2%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>Hotspot提供了两种Launcher类型，分别是通用启动器(java)和调试版启动器(gamma)。</p>
<h3 id="通用启动器"><a href="#通用启动器" class="headerlink" title="通用启动器"></a>通用启动器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java [ option ] class [ argument ... ]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>入口：jdk/src/share/bin/main.c</p>
</blockquote>
<h3 id="调试版启动器"><a href="#调试版启动器" class="headerlink" title="调试版启动器"></a>调试版启动器</h3><blockquote>
<p>入口：hostspor/src/share/tools/luncher/java.c</p>
</blockquote>
<h2 id="虚拟机生命周期"><a href="#虚拟机生命周期" class="headerlink" title="虚拟机生命周期"></a>虚拟机生命周期</h2><img src="http://www.plantuml.com/plantuml/svg/VP0zQiD048Nxd6BBfF05jd2ZD1AMcnYroqIxM6DMkx0Q2v8hk3AaiJ6ezHaC8QUnv6Du_IDOnucxn_lUF8OtGTAAiyDgtIwQThFhlfhzydk_tBQRvca4SvCNoWs6lUAi13JFBm7gTZ_TTf503Qb7dFNAXsvHs18RGj3ugP8ilMbBnh6l6CSYSWf8dMxF2MyDXfF2cxBYB3z3KPUUNCs0WfIXdwKNsP-5B3P8dDMbG2_4LDjtqDLzu1VzQvUH1HbfgFxZCuCY0gtV20ZppA9C5HLMFeY_AeAyYEREAKENZnwcAtBser_i2000">
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HotSpot实战</tag>
      </tags>
  </entry>
  <entry>
    <title>HotSpot实战-3类与对象</title>
    <url>/Java/Java/HotSpot%E5%AE%9E%E6%88%98-3%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="源码路径"><a href="#源码路径" class="headerlink" title="源码路径"></a>源码路径</h2><blockquote>
<p>hotspot/src/share/vm/oops</p>
</blockquote>
<h2 id="OOP-Klass"><a href="#OOP-Klass" class="headerlink" title="OOP-Klass"></a>OOP-Klass</h2><ol>
<li>OOP(ordinary object pointer): 普通对象指针，用来描述对象实例信息</li>
<li>Klass: Java类的C++对等体，用来描述Java类。</li>
</ol>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h3><table>
<thead>
<tr>
<th>模块</th>
<th>模块说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>oop</td>
<td>定义了OOPS共同基类</td>
</tr>
</tbody>
</table>
<h3 id="Klass"><a href="#Klass" class="headerlink" title="Klass"></a>Klass</h3><table>
<thead>
<tr>
<th>模块</th>
<th>模块说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Klass</td>
<td>用来描述语言层的类型</td>
</tr>
<tr>
<td>instanceKlass</td>
<td>在虚拟机层面描述一个Java类</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HotSpot实战</tag>
      </tags>
  </entry>
  <entry>
    <title>HotSpot实战-4运行时数据区</title>
    <url>/Java/Java/HotSpot%E5%AE%9E%E6%88%98-4%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HotSpot实战</tag>
      </tags>
  </entry>
  <entry>
    <title>HotSpot实战-5垃圾收集</title>
    <url>/Java/Java/HotSpot%E5%AE%9E%E6%88%98-5%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HotSpot实战</tag>
      </tags>
  </entry>
  <entry>
    <title>HotSpot实战-6栈</title>
    <url>/Java/Java/HotSpot%E5%AE%9E%E6%88%98-6%E6%A0%88/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HotSpot实战</tag>
      </tags>
  </entry>
  <entry>
    <title>HotSpot实战-7解释器和即时编译器</title>
    <url>/Java/Java/HotSpot%E5%AE%9E%E6%88%98-7%E8%A7%A3%E9%87%8A%E5%99%A8%E5%92%8C%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HotSpot实战</tag>
      </tags>
  </entry>
  <entry>
    <title>HotSpot实战-8指令集</title>
    <url>/Java/Java/HotSpot%E5%AE%9E%E6%88%98-8%E6%8C%87%E4%BB%A4%E9%9B%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HotSpot实战</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-线程池</title>
    <url>/Java/Java/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>1.减少创建线程的次数<br>2.控制线程池大小，减少并发线程数目</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>newCachedThreadPool</td>
<td>必要时创建新线程，空闲线程会被保留60秒</td>
</tr>
<tr>
<td>newFixedThreadPool</td>
<td>该池包含固定数量的线程，空闲线程会一直被保留</td>
</tr>
<tr>
<td>newSingleThreadExecutor</td>
<td>只有一个线程的池，该线程顺序执行每一个提交的任务</td>
</tr>
<tr>
<td>newScheduledThreadPool</td>
<td>用于预定执行而构建的固定线程池，替代Timer</td>
</tr>
<tr>
<td>newSingleThreadScheduledExecutor</td>
<td>用于预定执行而构建的单线程“池”</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java-运行时数据区</title>
    <url>/Java/Java/Java-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    <content><![CDATA[<ul>
<li>程序计数器</li>
</ul>
<p>每个线程都有独立的程序计数器，用于记录当前线程所执行的字节码的行号指示器。</p>
<ul>
<li>Java虚拟机栈</li>
</ul>
<p>线程私有。每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，对应一个栈帧在虚拟机栈中入栈到出栈的过程。<br>局部变量表存放了编译期可知的各种基本数据类型、对象引用类型和returnAddress类型。<br>-Xss</p>
<ul>
<li>本地方法栈</li>
</ul>
<p>虚拟机使用的Native方法的栈空间。</p>
<ul>
<li>Java堆</li>
</ul>
<p>所有线程共享的一块内存区域。垃圾收集器管理的主要区域。<br>相关JVM启动参数：<code>-Xmx, -Xms</code></p>
<ul>
<li>方法区</li>
</ul>
<p>所有线程共享的一块内存区域。存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>相关JVM启动参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//（JDK7）方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出</span><br><span class="line">-XX: PermSize=128m -XX:MaxPermSize=512m</span><br><span class="line"></span><br><span class="line">//元空间并不在虚拟机中，而是使用本地内存。默认情况下，元空间的大小仅受本地内存限制。</span><br><span class="line">-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m</span><br><span class="line"></span><br><span class="line">//JIT编译后二进制代码的存放区，满了之后就不再编译，对性能影响很大</span><br><span class="line">-XX:ReservedCodeCacheSize</span><br></pre></td></tr></table></figure></p>
<ul>
<li>运行时常量池</li>
</ul>
<p>方法区的一部分。用于存放编译期生成的各种字面量和符号引用。</p>
<ul>
<li>直接内存</li>
</ul>
<p>使用Native函数库直接分配堆外内存，不受Java堆大小的限制。<br>相关JVM启动参数：<code>-XX:MaxDirectMemorySize</code></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java-集合</title>
    <url>/Java/Java/Java-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><table>
<thead>
<tr>
<th>集合类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashSet</td>
<td>一种没有重复元素的无序集合</td>
</tr>
<tr>
<td>TreeSet</td>
<td>一种有序集</td>
</tr>
<tr>
<td>EnumSet</td>
<td>一种包含枚举类型值得集</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>一种可以记住元素插入次序的集</td>
</tr>
</tbody>
</table>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><table>
<thead>
<tr>
<th>集合类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap</td>
<td>一种存储键/值关联的数据结构</td>
</tr>
<tr>
<td>TreeMap</td>
<td>一种键值有序排列的映射表</td>
</tr>
<tr>
<td>EnumMap</td>
<td>一种键值属于枚举类型的映射表</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>一种可以记住键/值项添加次序的映射表</td>
</tr>
<tr>
<td>WeakHashMap</td>
<td>一种其值无用武之地后可以被垃圾回收器回收的映射表</td>
</tr>
<tr>
<td>IdentityHashMap</td>
<td>一种用==，而不是用equals比较键值得映射表</td>
</tr>
</tbody>
</table>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><table>
<thead>
<tr>
<th>集合类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayList</td>
<td>一种可以动态增长和缩减的索引序列</td>
</tr>
<tr>
<td>LinkedList</td>
<td>一种可以在任何位置进行高效的插入和删除操作的有序序列</td>
</tr>
</tbody>
</table>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><table>
<thead>
<tr>
<th>集合类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PriorityQueue</td>
<td>一种允许高效删除最小元素的集合</td>
</tr>
<tr>
<td>ConcurrentLinkedQueue</td>
<td></td>
</tr>
<tr>
<td>ArrayBlockingQueue</td>
<td></td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td></td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td></td>
</tr>
<tr>
<td>DelayQueue</td>
<td></td>
</tr>
<tr>
<td>SynchronousQueue</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发编程实战</title>
    <url>/Java/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<ol>
<li>安全性问题。永远不发生糟糕的事情。</li>
<li>活跃性问题。某件正确的事情最终会发生。比如死锁，饥饿，活锁。</li>
<li>性能问题。在活跃性问题的基础上关注正确的事情尽快发生。例如服务时间过长，响应不灵敏，资源消耗过高等。</li>
</ol>
<h2 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h2><p>常用的注解:@ThreadSafe,@NotThreadSafe,@Immutable</p>
<ol>
<li>原子性。避免竞态条件,以原子的方式执行,AtomicLong。</li>
<li>加锁机制</li>
<li>可见性</li>
<li>发布与逸出</li>
<li>线程封闭</li>
<li>栈封闭</li>
<li>不变性</li>
</ol>
<h2 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h2><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AbstraceQueuedSynchronizer是一个用于构建锁和同步器的框架，许多同步器都可以通过AQS很容易并且高效地构造出来。</p>
<p>它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程实战</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven指南</title>
    <url>/Java/Java/Maven%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="项目对象模型（POM）"><a href="#项目对象模型（POM）" class="headerlink" title="项目对象模型（POM）"></a>项目对象模型（POM）</h2><h3 id="插件和目标"><a href="#插件和目标" class="headerlink" title="插件和目标"></a>插件和目标</h3><p>一个Maven插件是一个单个或者多个目标的集合。如下面的例子，archtype是一个插件标识，create是目标标识<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn archtype:create</span><br></pre></td></tr></table></figure></p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>命令行并没有指定一个插件目标，而是指定了一个Maven生命周期阶段。命令行是如何执行目标的呢?</p>
<p>插件目标可以被绑定到生命周期阶段上。每个阶段可以绑定0个或者多个目标。当执行到该阶段就会执行该阶段上的目标。</p>
<p>Maven中有三种标准的生命周期：清理（clean），默认（default）(有时候也称为构建)，和站点（site）。默认的Maven生命周期包含了process-resources, compile, process-classes, process-test-resources, test-compile, test, prepare-package, package等等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure>
<h3 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h3><p>POM定义了项目，提供了项目的一组唯一标识符(坐标)，并且通过依赖(dependencies)，父(parents)和先决条件(prerequisite)来定义了和其他项目的关系。</p>
<p>一个Maven坐标可以精确的定位一个项目。格式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupId:artifactId:packageing:version</span><br></pre></td></tr></table></figure></p>
<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>Maven仓库的标准是按照下面的目录格式来存储构件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/&lt;groupId&gt;/&lt;artifactId&gt;/&lt;version&gt;/&lt;artifactId&gt;-&lt;version&gt;.&lt;packaging&gt;</span><br></pre></td></tr></table></figure>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>一个复杂的项目将会包含很多依赖，也有可能包含依赖于其它构件的依赖。这是Maven最强大的特征之一，它支持了传递性依赖（transitive dependencies）。假如你的项目依赖于一个库，而这个库又依赖于五个或者十个其它的库（就像Spring或者Hibernate那样）。你不必找出所有这些依赖然后把它们写在你的pom.xml里，你只需要加上你直接依赖的那些库，Maven会隐式的把这些库间接依赖的库也加入到你的项目中。Maven也会处理这些依赖中的冲突，同时能让你自定义默认行为，或者排除一些特定的传递性依赖</p>
<h3 id="站点生成和报告"><a href="#站点生成和报告" class="headerlink" title="站点生成和报告"></a>站点生成和报告</h3><p>Site生命周期只关心处理在src/site目录下的site内容，还有生成报告。在这个命令运行过之后，你将会在target/site目录下看到一个项目web站点。载入target/site/index.html你会看到项目站点的基本外貌。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn site</span><br></pre></td></tr></table></figure>
<h2 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h2><p>Maven的核心是一个名为Plexus的反转控制（IoC）框架。</p>
<p>一个Maven插件是包含了一个插件描述符和一个或者多个Mojo的Maven构件。一个Mojo可以被认为是Maven中的一个目标，每一个目标对应了一个Mojo。</p>
<h3 id="POM定义"><a href="#POM定义" class="headerlink" title="POM定义"></a>POM定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;packaging&gt;maven-plugin&lt;/packaging&gt;</span><br></pre></td></tr></table></figure>
<h3 id="实现Mojo接口"><a href="#实现Mojo接口" class="headerlink" title="实现Mojo接口"></a>实现Mojo接口</h3><p>继承AbstractMojo，实现一个目标接口。</p>
<h3 id="Mojo中常用注解"><a href="#Mojo中常用注解" class="headerlink" title="Mojo中常用注解"></a>Mojo中常用注解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@goal &lt;goalName&gt;</span><br><span class="line">@requiresDependencyResolution &lt;requireScope&gt;</span><br><span class="line">@requiresProject (true|false)</span><br><span class="line">@requiresReports (true|false)</span><br><span class="line">@aggregator (true|false)</span><br><span class="line">@requiresOnline (true|false)</span><br><span class="line">@requiresDirectInvocation</span><br><span class="line">@phase &lt;phaseName&gt;</span><br><span class="line">@execute [goal=goalName|phase=phaseName [lifecycle=lifecycleId]]</span><br></pre></td></tr></table></figure>
<h3 id="Mojo失败"><a href="#Mojo失败" class="headerlink" title="Mojo失败"></a>Mojo失败</h3><p>MojoExecutionException：一个致命的异常，发生了一些不可恢复的错误。构建需要终止。<br>MojoFailureException：Maven遇到项目失败的时候，他会提供不同的“弹性”设置。mvn -ff mvn -fae mvn -fn等等。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>FastDFS-安装</title>
    <url>/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/FastDFS-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>中间件</category>
      </categories>
  </entry>
  <entry>
    <title>Kafka-安装</title>
    <url>/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>中间件</category>
      </categories>
  </entry>
  <entry>
    <title>Redis-安装</title>
    <url>/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>中间件</category>
      </categories>
  </entry>
  <entry>
    <title>Tomcat-性能调校</title>
    <url>/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/Tomcat-%E6%80%A7%E8%83%BD%E8%B0%83%E6%A0%A1/</url>
    <content><![CDATA[<h2 id="调校的基本步骤"><a href="#调校的基本步骤" class="headerlink" title="调校的基本步骤"></a>调校的基本步骤</h2><ol>
<li>决定需要测量的对象。</li>
<li>决定测量的方式。</li>
<li>测量。</li>
<li>从测量结果中，了解其含义。</li>
<li>以预期会提升测量结果的方式来修补系统配置。</li>
<li>测量，并与之前的测量结果比较。</li>
<li>回到第4步。</li>
</ol>
<p>依照实际环境架设Tomcat。试着使用相同的硬件、操作系统、数据库等。越接近实际环境就越可能找到在实际系统中的瓶颈。在另一台机器上安装并配置负载测试用的软件。如果在运行Tomcat的同一台机器上运行，测试结果会不可靠，有时会更糟糕。<br>让负责测试的机器与运行Tomcat的机器之间通信隔离。这样处理的原因在于在运行高流量的测试时，如果追加了不属于测试的网络流量，将导致这些测试结果变得不可靠。</p>
<h2 id="测量Web服务器的性能"><a href="#测量Web服务器的性能" class="headerlink" title="测量Web服务器的性能"></a>测量Web服务器的性能</h2><ol>
<li>负载测试客户端与服务器软件包是在同一台机器吗?</li>
<li>在测试时，服务器端机器是否正在执行其他的程序?</li>
<li>客户端与服务器是以千兆位的以太网络，还是100baseT、10baseT相连呢?如果负载测试客户端机器通过低于千兆以太网速度的网络信道链接到服务器端，那么网络链接会降低测试速度，从而改变测试结果。</li>
<li>是屡次请求相同的网页，混合多种不同的并发请求，还是从庞大的网页清单中随机挑选呢?这能影响服务器及多线程缓存性能。</li>
<li>测试客户端应按常规方式还是应该以突发方式发送请求呢?按基准调校来说，当您欲知道多快的服务器能完成请求时，应使测试客户端在请求之间不经暂停、快速连续地发送请求。</li>
<li>运行的服务器是最终配置吗?根据基准调校的需要，应关闭所有调试工作，且还可能要关闭一些日志。</li>
<li>HTTP客户端请求了图像还是仅请求了嵌入于其中的HTML页?</li>
</ol>
<h2 id="测试负载的工具"><a href="#测试负载的工具" class="headerlink" title="测试负载的工具"></a>测试负载的工具</h2><ol>
<li>Jmeter<br>Jmeter提供了定制测试结果的最具报表特性的选项，是最能适应不同操作系统的工具，而且支持大部分功能。但是，出于某种原因，Jmeter不能像ab和siege所做的那样，每秒钟请求并完成那么多次HTTP请求。</li>
<li>ab<br>是一个基准调校工具，所以一般不会把它用于递归测试。</li>
<li>Siege<br>Siege是另一个很好的命令行Web负载测试工具。Siege支持多种不同的认证特性，并可执行基准测试、递归测试，还支持”Internet”模式测试(即尽可能仿真在Internet上Web应用程序进行交互的众多实际用户所产生的负载)。</li>
</ol>
<h2 id="ab-Apache基准调校工具"><a href="#ab-Apache基准调校工具" class="headerlink" title="ab:Apache基准调校工具"></a>ab:Apache基准调校工具</h2><p>在基准调校测试的时候，测试客户端请求HTTP的数量越少，测试客户端提供的测试结果就可能越不精确，因为在基准调校过程中，Java VM的资源回收暂停占用了整个测试时间的较高比重。运行HTTP请求的总数量越多，资源回收暂停变得意义更小，而且基准调校测试结果将更能显示Tomcat的整体性能。您最好运行至少100000个HTTP请求以执行基准调校测试。另外，您可以配置测试客户端，产生您喜欢的客户端线程数，但是，如果您将该线程数设置成超过Tomcat的conf/server.xml文件中提供的连接器(Connector)最大线程数(maxThread)，那么实际不会有太大的帮助。在默认的情况下将该线程数设置为150。如果您设置成测试者超过这一数字，而且在更多的线程中产生了比Tomcat拥有的接收线程数和处理线程数还要多的请求，就会影响性能，因为一些客户端请求线程将一直处于等待状态。最好是就保留在连接器的最下线程数(Connector的maxThread)设置下，如使用149的客户端线程。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">ab -k -n 100000 -c 149 http://127.0.0.1:8080/test</span><br></pre></td></tr></table></figure>
<p>如果在ab命令行中删除-k，那么ab与Tomcat将不使用保持联机(keep-alive)链接，这样处理效率更低，因为它必须链接一个新的TCP包到Tomcat上，以执行每个HTTP请求。结果是每秒要处理的请求数更好了，而且Tomcat到客户端的吞吐量更小了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">ab -n 100000 -c 149 http://127.0.0.1:8080/test</span><br></pre></td></tr></table></figure>
<h2 id="外部调校"><a href="#外部调校" class="headerlink" title="外部调校"></a>外部调校</h2><p>当您了解应用程序及Tomcat的实例对负载的响应情形后，就可以开始一些性能调校的处理了，这里有两种基本的调校方式：</p>
<ul>
<li>外部调校<br>涉及到非Tomcat组件的调校，如Tomcat所运行的操作系统，以及运行Tomcat的Java虚拟机器。<br>1.JVM的性能<br>不同厂商，不同版本之间的基准调校。如果选择Java 1.6,那么您可以对Sun的1.6、IBM的1.6和BEA的1.6版本的虚拟机进行基准调校。<br>通常，人们会设法修改JVM启动参数，以使Tomcat JVM能更快地为Web应用程序网页服务。这可以提供一些帮助，但通常不会在性能上提高较高百分比。其主要原因是这样处理不会太有用：JVM提供商在发布JDK之前就已进行过自身测试，寻找哪些设置会产生最佳性能，并让这些设置变成默认值。<br>JVM的堆栈内存(heap memory)分配除外。JVM提供商默认选择分配少量内存以启动JVM，且如果Java应用程序需要更多内存，那么在应用程序暂停时，JVM的heap会被重新分配为更大。为了避免这种暂停，可以设置最小heap大小与最大heap大小相等。那样处理的话，JVM将不会在运行的时候尝试扩展heap大小。只要设置JAVA_OPTS环境变量为类似于-Xms512M -Xmx512M之类的值。这意味着最大、最小heap都被设置为512MB。<br>2.操作系统的性能<br>您的服务器的操作系统是最适合于运行大型、高容量的Web服务器吗?OpenBSD的主要目标在安全防护，所以其核心中许多的限制都设得比较低，以防止各种形式的DOS攻击。Linux的目标是容易使用，所以其限制值会设得比较高。如果您执行任何版本的Microsoft Windows，请确定是Server。在非Server的版本中，终端用户的授权协议和程序代码都可能会限制用户数、可使用的网络连接数或其他限制。</li>
<li>内部调校<br>与Tomcat本身有关的调校，包括改变配置文件中的设定值，以及修改Tomcat本身的源代码。</li>
</ul>
<ol>
<li>停用DNS查询<br>DNS查询需要耗费网络资源，并涉及多部服务器的往返响应，而这些服务器可能位于遥远的地方，也可能尚未运行，因此导致延迟。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">enableLookups</span>=<span class="string">"true"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>只要将enableLookups的值”true”改成”false”，然后重新启动Tomcat。这样将不再使用DNS查询，也不会有延迟了。</p>
<ol start="2">
<li>调整线程数<br>另一种对应用程序之Connector性能控制的方法是控制其处理的进程数。Tomcat默认使用线程池以便对传入的请求提供快速响应。<br>通过更改Connector的minThreads与maxThreads的值，可以控制所分配的线程数。<br>minThreads的值应该大到能够处理最小负载量。即如果在低谷时刻，每秒可访问五次网页，而每次请求在一秒钟之内可完成，则预先分配5个线程就够了。随后在高峰时刻，则需要分配更多线程(最多到maxThreads所设定的数目)，为了防止流量暴增(或黑客的DoS攻击)让系统超出JVM的最大内存限制，而使服务器瘫痪，因此一定要设定上限。</li>
<li>加快JSP的编译速度<br>当第一次访问JSP时，此JSP会转换成Java Servlet的源代码，然后必须再编译成Java的bytecode。用请求预编译JSP。</li>
</ol>
<h2 id="容量规划"><a href="#容量规划" class="headerlink" title="容量规划"></a>容量规划</h2><p>调校Tomcat在线服务器性能的另一重要部分就是容量规划。无论调校多少配置文件与进行多少测试，如果没有符合网站预期流量大小的硬件与带宽，实际上也帮不了忙。<br>通过研究及(或)预测网站必须处理的总网络流量，决定可接收的服务质量与寻找满足或超越服务器软件需求，来预测网站所需的计算机硬件、操作系统与带宽的活动。</p>
<ol>
<li>经验式的容量规划<br>经验式的容量规划师一种轻量级的规划方式，它不一定要很精确，但已足够让公司免于完全不做容量规划的后果。这种方法符合以前的业界经验产生的容量与性能趋势。例如，对于网站在高峰时有多少输出流量，您可以做最佳的预测，然后将该数字加倍。</li>
<li>企业容量规划的目的是要更精确，因此也需要更久的时间。通常这会使用商业及的容量规划分析软件，以及反复的测试与模拟仿真。</li>
</ol>
<h2 id="Tomcat上的容量规划"><a href="#Tomcat上的容量规划" class="headerlink" title="Tomcat上的容量规划"></a>Tomcat上的容量规划</h2><ol>
<li>服务器计算机硬件</li>
<li>网络带宽</li>
<li>服务器操作系统</li>
</ol>
<p>适用于Tomcat的各种容量规划的一般程序</p>
<ol>
<li>找出负载特性。</li>
<li>分析性能的趋势。</li>
<li>决定可接收服务的最低需求。例如，可能希望让用户最多等待20秒钟。</li>
<li>决定要使用何种基础体系的资源，并在分段的环境下测试。</li>
<li>如果第4步可以符合您的服务需求，就可以订购并部署更多的相同的机器，以作为生产用的服务器计算机。否则，请重复第4步，直到满足服务需求为止。</li>
</ol>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
  </entry>
  <entry>
    <title>Zookeeper-安装</title>
    <url>/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/Zookeeper-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>CentOS Linux release 7.4.1708</li>
<li>OpenJDK Runtime Environment (build 1.8.0_131-b12)</li>
<li>zookeeper-3.4.8</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="伪集群"><a href="#伪集群" class="headerlink" title="伪集群"></a>伪集群</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> begin 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> zoo.cfg</span><br><span class="line">dataDir=/root/zookeeper-3.4.8-1/data</span><br><span class="line">clientPort=2081</span><br><span class="line"></span><br><span class="line">server.0=10.0.2.15:2788:3788</span><br><span class="line">server.1=10.0.2.15:2888:3888</span><br><span class="line">server.2=10.0.2.15:2988:3988</span><br><span class="line"><span class="meta">#</span> /root/zookeeper-3.4.8-1/data/myid</span><br><span class="line">0</span><br><span class="line"><span class="meta">#</span> end 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> begin 2</span><br><span class="line"><span class="meta">#</span> zoo.cfg</span><br><span class="line">dataDir=/root/zookeeper-3.4.8-2/data</span><br><span class="line">clientPort=2181</span><br><span class="line"></span><br><span class="line">server.0=10.0.2.15:2788:3788</span><br><span class="line">server.1=10.0.2.15:2888:3888</span><br><span class="line">server.2=10.0.2.15:2988:3988</span><br><span class="line"><span class="meta">#</span> /root/zookeeper-3.4.8-2/data/myid</span><br><span class="line">1</span><br><span class="line"><span class="meta">#</span> end 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> begin 3</span><br><span class="line"><span class="meta">#</span> zoo.cfg</span><br><span class="line">dataDir=/root/zookeeper-3.4.8-3/data</span><br><span class="line">clientPort=2281</span><br><span class="line"></span><br><span class="line">server.0=10.0.2.15:2788:3788</span><br><span class="line">server.1=10.0.2.15:2888:3888</span><br><span class="line">server.2=10.0.2.15:2988:3988</span><br><span class="line"><span class="meta">#</span> /root/zookeeper-3.4.8-3/data/myid</span><br><span class="line">2</span><br><span class="line"><span class="meta">#</span> end 3</span><br></pre></td></tr></table></figure>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zkServer.sh start</span><br><span class="line">zkServer.sh status</span><br><span class="line"></span><br><span class="line">zkCli.sh</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>产品经理手册</title>
    <url>/%E4%BA%A7%E5%93%81/%E4%BA%A7%E5%93%81/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>产品经理手册</tag>
      </tags>
  </entry>
  <entry>
    <title>Big-Endian和Little-Endian</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96/Big-Endian%E5%92%8CLittle-Endian/</url>
    <content><![CDATA[<p>1  Big-endian</p>
<pre><code>按照最高位字节(包含最高位，即MSB，的字节)至最低位字节(包含最低位，即LSB，的字节)的顺序，存放在连续的地址中。
</code></pre><p>采用这种机制的处理器有IBM3700系列、PDP-10、Mortolora微处理器系列和绝大多数的RISC处理器。<br>       例如：双字节数0x1234以big-endian的方式存在起始地址0x00000000中<br>数据&lt;–地址<br>| 0x12 |&lt;– 0x00000000</p>
<p>| 0x34 |&lt;– 0x00000001<br>2  Little-endian</p>
<pre><code>按照最低位字节(包含LSB的字节)至最高位字节(包含MSB的字节)的顺序，存放在连续的地址中。
</code></pre><p>采用这种机制的处理器有PDP-11、VAX、Intel系列微处理器和一些网络通信设备。<br>       例如：双字节数0x1234以little-endian的方式存在起始地址0x00000000中<br>数据&lt;–地址<br>| 0x34 |&lt;– 0x00000000</p>
<p>| 0x12 |&lt;– 0x00000001<br>3  Middle-endian</p>
<pre><code>除了big-endian和little-endian之外的多字节存储顺序就是middle-endian。
</code></pre><p>比如以4个字节为例：象以3-4-1-2或者2-1-4-3这样的顺序存储的就是middle-endian。</p>
<p>这种存储顺序偶尔会在一些小型机体系中的十进制数的压缩格式中出现。</p>
<pre><code>为什么要注意字节序的问题呢？你可能这么问。当然，如果你写的程序只在单机环境下面运行，并且不和别人的程序打交道，那么你完全可以忽略字节序的存在。但是，如果你的程序要跟别人的程序产生交互呢？在这里我想说说两种语言。C/C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而JAVA编写的程序则唯一采用big endian方式来存储数据。试想，如果你用C/C++语言在x86平台下编写的程序跟别人的JAVA程序互通时会产生什么结果？就拿上面的0x12345678来说，你的程序传递给别人的一个数据，将指向0x12345678的指针传给了JAVA程序，由于JAVA采取big endian方式存储数据，很自然的它会将你的数据翻译为0x78563412。什么？竟然变成另外一个数字了？是的，就是这种后果。因此，在你的C程序传给JAVA程序之前有必要进行字节序的转换工作。


无独有偶，所有网络协议也都是采用big endian的方式来传输数据的。所以有时我们也会把big endian方式称之为网络字节序。当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序后再进行传输。
</code></pre><p>4  比特序</p>
<pre><code>CPU存储一个字节的数据时其字节内的8个比特之间的顺序是否也有big endian和little endian之分？或者说是否有比特序的不同？ 实际上，这个比特序是同样存在的。下面以数字0xB4（10110100）用图加以说明。 
</code></pre><p>Big Endian</p>
<p>   msb                                                         lsb<br>   ———————————————-&gt;<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |   1  |   0  |   1  |   1  |   0  |   1  |   0  |   0  |<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p>
<p>Little Endian</p>
<p>   lsb                                                         msb<br>   ———————————————-&gt;<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |   0  |   0  |   1  |   0  |   1  |   1  |   0  |   1  |<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p>
<pre><code>实际上，由于CPU存储数据操作的最小单位是一个字节，其内部的比特序是什么样对我们的程序来说是一个黑盒子。也就是说，你给我一个指向0xB4这个数的指针，对于big endian方式的CPU来说，它是从左往右依次读取这个数的8个比特；而对于little endian方式的CPU来说，则正好相反，是从右往左依次读取这个数的8个比特。而我们的程序通过这个指针访问后得到的数就是0xB4，字节内部的比特序对于程序来说是不可见的，其实这点对于单机上的字节序来说也是一样的。 


那可能有人又会问，如果是网络传输呢？会不会出问题？是不是也要通过什么函数转换一下比特序？嗯，这个问题提得很好。假设little endian方式的CPU要传给big endian方式CPU一个字节的话，其本身在传输之前会在本地就读出这个8比特的数，然后再按照网络字节序的顺序来传输这8个比特，这样的话到了接收端不会出现任何问题。而假如要传输一个32比特的数的话，由于这个数在littel endian方存储时占了4个字节，而网络传输是以字节为单位进行的，little endian方的CPU读出第一个字节后发送，实际上这个字节是原数的LSB，到了接收方反倒成了MSB从而发生混乱。
</code></pre>]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>MapReduce</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96/MapReduce/</url>
    <content><![CDATA[<p>1  问题的出现</p>
<pre><code>多年来磁盘存储容量快速增加的同时，其访问速度-磁盘数据读取速度-却未能与时俱进。

读取一个磁盘中所有的数据需要很长的时间，写甚至更慢。一个很简单的减少读取时间的办法是同时从多个磁盘上读取数据。试想，如果我们拥有100个磁盘，每个磁盘存储1%的数据，并行读取，那么不到两分钟就可以读取所有数据。

MapReduce提出了一个编程模型，该模型将上述磁盘读写的问题进行抽象，并转换为对一个数据集(由键/值对组成)的计算
</code></pre><p>2  MapReduce</p>
<pre><code>MapReduce是一种可用于数据处理的编程模型。MapReduce程序本质上是并行运行的，因此可以将大规模的数据分析任务交给任何一个拥有足够多机器的运营商。MapReduce的优势在于处理大规模数据集。
</code></pre><p>2.1  map阶段和reduce阶段</p>
<pre><code>MapReduce任务过程被分为两个处理阶段：map阶段和reduce阶段。每个阶段都以键/值对作为输入和输出，并由程序员选择它们的类型。程序员还需具体定义两个函数:map函数和reduce函数。
</code></pre><p>2.2  找出最高气温</p>
<p>目标：根据原始数据找出每年的最高气温。</p>
<p>原始数据：包含了一年中每天的气温记录。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>map</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入</td>
<td>原始数据</td>
</tr>
<tr>
<td>输出</td>
<td>(1950, 0)</td>
</tr>
<tr>
<td></td>
<td>(1950,22)</td>
</tr>
<tr>
<td></td>
<td>(1950,-11)</td>
</tr>
<tr>
<td></td>
<td>-1,949,111</td>
</tr>
<tr>
<td></td>
<td>(1949,78)</td>
</tr>
<tr>
<td>功能</td>
<td>从原始数据中提取出有用数据组成键/值对</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>名称</th>
<th>shuffle</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入</td>
<td>(1950, 0)</td>
</tr>
<tr>
<td></td>
<td>(1950, 22)</td>
</tr>
<tr>
<td></td>
<td>(1950, -11)</td>
</tr>
<tr>
<td></td>
<td>(1949, 111)</td>
</tr>
<tr>
<td></td>
<td>(1949, 78)</td>
</tr>
<tr>
<td>输出</td>
<td>(1949, [111,78])</td>
</tr>
<tr>
<td></td>
<td>(1950, [0, 22, -11])</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>名称</th>
<th>reduce</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入</td>
<td>(1949, [111, 78])</td>
</tr>
<tr>
<td></td>
<td>(1950, [0, 22, -11])</td>
</tr>
<tr>
<td>输出</td>
<td>(1949, 111)</td>
</tr>
<tr>
<td></td>
<td>(1950, 22)</td>
</tr>
<tr>
<td>功能</td>
<td>遍历整个列表找出最大值</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown-数学公式</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96/Markdown-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>行内显示<code>$...$</code>定义</p>
<p>单独显示<code>$$...$$</code>定义</p>
<p>语句为<code>$$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$$</code></p>

$$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$$
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({text2jax: {inlineMath: [['$','$'], ['\\(', '\\)']]}});
</script>

<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><ul>
<li>若需要大写希腊字母，将命令首字母大写即可。</li>
<li>若需要斜体希腊字母，将命令前加上var前缀即可。</li>
</ul>
<table>
<thead>
<tr>
<th>显示</th>
<th>命令</th>
<th>显示</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>α</td>
<td>\alpha</td>
<td>β</td>
<td>\beta</td>
</tr>
<tr>
<td>γ</td>
<td>\gamma</td>
<td>δ</td>
<td>\delta</td>
</tr>
<tr>
<td>ε</td>
<td>\epsilon</td>
<td>ζ</td>
<td>\zeta</td>
</tr>
<tr>
<td>η</td>
<td>\eta</td>
<td>θ</td>
<td>\theta</td>
</tr>
<tr>
<td>ι</td>
<td>\iota</td>
<td>κ</td>
<td>\kappa</td>
</tr>
<tr>
<td>λ</td>
<td>\lambda</td>
<td>μ</td>
<td>\mu</td>
</tr>
<tr>
<td>ν</td>
<td>\nu</td>
<td>ξ</td>
<td>\xi</td>
</tr>
<tr>
<td>π</td>
<td>\pi</td>
<td>ρ</td>
<td>\rho</td>
</tr>
<tr>
<td>σ</td>
<td>\sigma</td>
<td>τ</td>
<td>\tau</td>
</tr>
<tr>
<td>υ</td>
<td>\upsilon</td>
<td>φ</td>
<td>\phi</td>
</tr>
<tr>
<td>χ</td>
<td>\chi</td>
<td>ψ</td>
<td>\psi</td>
</tr>
<tr>
<td>ω</td>
<td>\omega</td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>Tomcat的性能调校</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96/Tomcat%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E6%A0%A1/</url>
    <content><![CDATA[<p>###调校的基本步骤</p>
<ol>
<li>决定需要测量的对象。</li>
<li>决定测量的方式。</li>
<li>测量。</li>
<li>从测量结果中，了解其含义。</li>
<li>以预期会提升测量结果的方式来修补系统配置。</li>
<li>测量，并与之前的测量结果比较。</li>
<li>回到第4步。</li>
</ol>
<p>依照实际环境架设Tomcat。试着使用相同的硬件、操作系统、数据库等。越接近实际环境就越可能找到在实际系统中的瓶颈。在另一台机器上安装并配置负载测试用的软件。如果在运行Tomcat的同一台机器上运行，测试结果会不可靠，有时会更糟糕。<br>让负责测试的机器与运行Tomcat的机器之间通信隔离。这样处理的原因在于在运行高流量的测试时，如果追加了不属于测试的网络流量，将导致这些测试结果变得不可靠。</p>
<p>###测量Web服务器的性能</p>
<ol>
<li>负载测试客户端与服务器软件包是在同一台机器吗?</li>
<li>在测试时，服务器端机器是否正在执行其他的程序?</li>
<li>客户端与服务器是以千兆位的以太网络，还是100baseT、10baseT相连呢?如果负载测试客户端机器通过低于千兆以太网速度的网络信道链接到服务器端，那么网络链接会降低测试速度，从而改变测试结果。</li>
<li>是屡次请求相同的网页，混合多种不同的并发请求，还是从庞大的网页清单中随机挑选呢?这能影响服务器及多线程缓存性能。</li>
<li>测试客户端应按常规方式还是应该以突发方式发送请求呢?按基准调校来说，当您欲知道多快的服务器能完成请求时，应使测试客户端在请求之间不经暂停、快速连续地发送请求。</li>
<li>运行的服务器是最终配置吗?根据基准调校的需要，应关闭所有调试工作，且还可能要关闭一些日志。</li>
<li>HTTP客户端请求了图像还是仅请求了嵌入于其中的HTML页?</li>
</ol>
<p>###测试负载的工具</p>
<ol>
<li>Jmeter<br>Jmeter提供了定制测试结果的最具报表特性的选项，是最能适应不同操作系统的工具，而且支持大部分功能。但是，出于某种原因，Jmeter不能像ab和siege所做的那样，每秒钟请求并完成那么多次HTTP请求。</li>
<li>ab<br>是一个基准调校工具，所以一般不会把它用于递归测试。</li>
<li>Siege<br>Siege是另一个很好的命令行Web负载测试工具。Siege支持多种不同的认证特性，并可执行基准测试、递归测试，还支持”Internet”模式测试(即尽可能仿真在Internet上Web应用程序进行交互的众多实际用户所产生的负载)。</li>
</ol>
<p>###ab:Apache基准调校工具<br>在基准调校测试的时候，测试客户端请求HTTP的数量越少，测试客户端提供的测试结果就可能越不精确，因为在基准调校过程中，Java VM的资源回收暂停占用了整个测试时间的较高比重。运行HTTP请求的总数量越多，资源回收暂停变得意义更小，而且基准调校测试结果将更能显示Tomcat的整体性能。您最好运行至少100000个HTTP请求以执行基准调校测试。另外，您可以配置测试客户端，产生您喜欢的客户端线程数，但是，如果您将该线程数设置成超过Tomcat的conf/server.xml文件中提供的连接器(Connector)最大线程数(maxThread)，那么实际不会有太大的帮助。在默认的情况下将该线程数设置为150。如果您设置成测试者超过这一数字，而且在更多的线程中产生了比Tomcat拥有的接收线程数和处理线程数还要多的请求，就会影响性能，因为一些客户端请求线程将一直处于等待状态。最好是就保留在连接器的最下线程数(Connector的maxThread)设置下，如使用149的客户端线程。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">ab -k -n 100000 -c 149 http://127.0.0.1:8080/test</span><br></pre></td></tr></table></figure>
<p>如果在ab命令行中删除-k，那么ab与Tomcat将不使用保持联机(keep-alive)链接，这样处理效率更低，因为它必须链接一个新的TCP包到Tomcat上，以执行每个HTTP请求。结果是每秒要处理的请求数更好了，而且Tomcat到客户端的吞吐量更小了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">ab -n 100000 -c 149 http://127.0.0.1:8080/test</span><br></pre></td></tr></table></figure>
<p>###外部调校<br>当您了解应用程序及Tomcat的实例对负载的响应情形后，就可以开始一些性能调校的处理了，这里有两种基本的调校方式：</p>
<ul>
<li>外部调校<br>涉及到非Tomcat组件的调校，如Tomcat所运行的操作系统，以及运行Tomcat的Java虚拟机器。<br>1.JVM的性能<br>不同厂商，不同版本之间的基准调校。如果选择Java 1.6,那么您可以对Sun的1.6、IBM的1.6和BEA的1.6版本的虚拟机进行基准调校。<br>通常，人们会设法修改JVM启动参数，以使Tomcat JVM能更快地为Web应用程序网页服务。这可以提供一些帮助，但通常不会在性能上提高较高百分比。其主要原因是这样处理不会太有用：JVM提供商在发布JDK之前就已进行过自身测试，寻找哪些设置会产生最佳性能，并让这些设置变成默认值。<br>JVM的堆栈内存(heap memory)分配除外。JVM提供商默认选择分配少量内存以启动JVM，且如果Java应用程序需要更多内存，那么在应用程序暂停时，JVM的heap会被重新分配为更大。为了避免这种暂停，可以设置最小heap大小与最大heap大小相等。那样处理的话，JVM将不会在运行的时候尝试扩展heap大小。只要设置JAVA_OPTS环境变量为类似于-Xms512M -Xmx512M之类的值。这意味着最大、最小heap都被设置为512MB。<br>2.操作系统的性能<br>您的服务器的操作系统是最适合于运行大型、高容量的Web服务器吗?OpenBSD的主要目标在安全防护，所以其核心中许多的限制都设得比较低，以防止各种形式的DOS攻击。Linux的目标是容易使用，所以其限制值会设得比较高。如果您执行任何版本的Microsoft Windows，请确定是Server。在非Server的版本中，终端用户的授权协议和程序代码都可能会限制用户数、可使用的网络连接数或其他限制。</li>
<li>内部调校<br>与Tomcat本身有关的调校，包括改变配置文件中的设定值，以及修改Tomcat本身的源代码。</li>
</ul>
<ol>
<li>停用DNS查询<br>DNS查询需要耗费网络资源，并涉及多部服务器的往返响应，而这些服务器可能位于遥远的地方，也可能尚未运行，因此导致延迟。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">enableLookups</span>=<span class="string">"true"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>只要将enableLookups的值”true”改成”false”，然后重新启动Tomcat。这样将不再使用DNS查询，也不会有延迟了。</p>
<ol start="2">
<li>调整线程数<br>另一种对应用程序之Connector性能控制的方法是控制其处理的进程数。Tomcat默认使用线程池以便对传入的请求提供快速响应。<br>通过更改Connector的minThreads与maxThreads的值，可以控制所分配的线程数。<br>minThreads的值应该大到能够处理最小负载量。即如果在低谷时刻，每秒可访问五次网页，而每次请求在一秒钟之内可完成，则预先分配5个线程就够了。随后在高峰时刻，则需要分配更多线程(最多到maxThreads所设定的数目)，为了防止流量暴增(或黑客的DoS攻击)让系统超出JVM的最大内存限制，而使服务器瘫痪，因此一定要设定上限。</li>
<li>加快JSP的编译速度<br>当第一次访问JSP时，此JSP会转换成Java Servlet的源代码，然后必须再编译成Java的bytecode。用请求预编译JSP。<br>###容量规划<br>调校Tomcat在线服务器性能的另一重要部分就是容量规划。无论调校多少配置文件与进行多少测试，如果没有符合网站预期流量大小的硬件与带宽，实际上也帮不了忙。<br>通过研究及(或)预测网站必须处理的总网络流量，决定可接收的服务质量与寻找满足或超越服务器软件需求，来预测网站所需的计算机硬件、操作系统与带宽的活动。</li>
<li>经验式的容量规划<br>经验式的容量规划师一种轻量级的规划方式，它不一定要很精确，但已足够让公司免于完全不做容量规划的后果。这种方法符合以前的业界经验产生的容量与性能趋势。例如，对于网站在高峰时有多少输出流量，您可以做最佳的预测，然后将该数字加倍。</li>
<li>企业容量规划的目的是要更精确，因此也需要更久的时间。通常这会使用商业及的容量规划分析软件，以及反复的测试与模拟仿真。</li>
</ol>
<p>###Tomcat上的容量规划</p>
<ol>
<li>服务器计算机硬件</li>
<li>网络带宽</li>
<li>服务器操作系统</li>
</ol>
<p>适用于Tomcat的各种容量规划的一般程序</p>
<ol>
<li>找出负载特性。</li>
<li>分析性能的趋势。</li>
<li>决定可接收服务的最低需求。例如，可能希望让用户最多等待20秒钟。</li>
<li>决定要使用何种基础体系的资源，并在分段的环境下测试。</li>
<li>如果第4步可以符合您的服务需求，就可以订购并部署更多的相同的机器，以作为生产用的服务器计算机。否则，请重复第4步，直到满足服务需求为止。</li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>emacs</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96/emacs/</url>
    <content><![CDATA[<p>Emacs不仅仅是一个编辑器，他是一个整合环境，或可称它为集成开发环境，这些功能如让使用者置身于全功能的操作系统中。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>启动：emacs [filename]<br>退出：C-x C-c<br>挂起：C-z</p>
<h2 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h2><p>C-chr表示当输入字符chr时按住CONTROL键。因此C-f就表示：按住CONTROL键再输入f。<br>M-chr表示当输入字符chr时按住META（或EDIT或ALT）键。如果你的键盘上没有META、EDIT或ALT键，用下述方法也等效：先按一下ESC键然后放开，再输入chr。我们用ESC来表示ESC键。</p>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>主(major)模式:M-x fundamental-mode<br>辅助(minor)模式:辅模式并不能替代主模式，而是提供一些辅助的功能。每个辅模式都可以独立地开启和关闭，跟其它辅模式无关，跟主模式也无关。<br>切换：C-x o<br>关闭：C-x 1</p>
<h2 id="窗格"><a href="#窗格" class="headerlink" title="窗格"></a>窗格</h2><p>新窗格：C-x 5 2<br>切换：C-x 5 o<br>删除当前窗格：C-x 5 0</p>
<h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><p>显示和隐藏：M-x menu-bar-mode<br>调用：F10或者M-`</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>.emacs文件包含LISP函数调用表达式，因此它对语法非常挑剔。</p>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>开始录制：C-x (<br>结束录制：C-x )<br>执行最后一条宏：C-x e</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>requestAnimationFrame</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96/requestAnimationFrame/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>swagger</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96/swagger/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>vim</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96/vim/</url>
    <content><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv ~/.vimrc ~/.vimrcbak</span><br><span class="line">mv ~/.vim ~/.vimbak</span><br><span class="line">git clone https://github.com/pauljoo/vim.git</span><br><span class="line">mv vim/.vimrc vim/.vim ~/</span><br></pre></td></tr></table></figure>
<ol>
<li>管理插件的插件</li>
<li>管理窗口和buffer</li>
<li>语法增强</li>
<li>代码补全</li>
</ol>
<h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><h3 id="pathogen"><a href="#pathogen" class="headerlink" title="pathogen"></a>pathogen</h3><p>一个管理插件的插件</p>
<h4 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h4><p><a href="https://github.com/tpope/vim-pathogen" target="_blank" rel="noopener">https://github.com/tpope/vim-pathogen</a></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">execute pathogen#infect()</span><br><span class="line">syntax on</span><br><span class="line">filetype plugin indent on</span><br></pre></td></tr></table></figure>
<h3 id="auto-pairs"><a href="#auto-pairs" class="headerlink" title="auto-pairs"></a>auto-pairs</h3><p>自动匹配括号、引号等</p>
<h4 id="项目地址-1"><a href="#项目地址-1" class="headerlink" title="项目地址"></a>项目地址</h4><p><a href="https://github.com/jiangmiao/auto-pairs" target="_blank" rel="noopener">https://github.com/jiangmiao/auto-pairs</a></p>
<h3 id="NERDTree"><a href="#NERDTree" class="headerlink" title="NERDTree"></a>NERDTree</h3><p>显示目录树</p>
<h4 id="项目地址-2"><a href="#项目地址-2" class="headerlink" title="项目地址"></a>项目地址</h4><p><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="noopener">https://github.com/scrooloose/nerdtree</a></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol>
<li>命令行模式下输入:NERDTree</li>
<li>为了方便打开NERDTree，我们可以设置快捷键，打开~/.vimrc，插入如下一行<br>map <c-n> :NERDTree<cr><br>这样，当打开vim时，只要输入ctrl+n即可打开NERDTree</cr></c-n></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">文件相关操作</span><br><span class="line">o  : 在光标所在的上一个窗口打开文件，并将光标置于新打开的窗口</span><br><span class="line">go : 预览文件，光标停留在NERDTree窗口中</span><br><span class="line">t  : 在新标签中打开文件并激活</span><br><span class="line">gt : 在新标签打开文件，光标留在NERDTree窗口中</span><br><span class="line">i  : 水平分割打开文件</span><br><span class="line">gi : 水平分割预览</span><br><span class="line">s  : 垂直分割打开文件</span><br><span class="line">gs : 垂直分割预览</span><br><span class="line">目录树相关操作</span><br><span class="line">o  : 展开/关闭目录</span><br><span class="line">O  : 递归展开目录。慎用，如果目录层级多，打开会很慢</span><br><span class="line">x  : 关闭父目录</span><br><span class="line">C  : 切换光标所在目录为根目录</span><br><span class="line">u  : 切换目录树的根目录为上层目录</span><br><span class="line">U  : 切换目录树的根目录为上层目录，并保持旧的目录树的状态</span><br><span class="line">r  : 刷新当前目录</span><br><span class="line">R  : 刷新当前根目录（这个在新加入文件后会用到）</span><br><span class="line">cd : 切换vim工作目录为光标所在目录（命令模式下:pwd可查看当前工作目录）</span><br></pre></td></tr></table></figure>
<h3 id="MiniBufExplorer"><a href="#MiniBufExplorer" class="headerlink" title="MiniBufExplorer"></a>MiniBufExplorer</h3><p>显示已打开的buffer</p>
<h4 id="项目地址-3"><a href="#项目地址-3" class="headerlink" title="项目地址"></a>项目地址</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/.vim/bundle/minibufexplorer/plugin &amp;&amp; wget "http://www.vim.org/scripts/download_script.php?src_id=3640" -O ~/.vim/bundle/minibufexplorer/plugin/minibufexpl.vim</span><br></pre></td></tr></table></figure>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>命令行模式下通过:vsp filename打开另一个文件</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="ctags"><a href="#ctags" class="headerlink" title="ctags"></a>ctags</h3><p>是用来对代码建索引，方便查找的，有些Linux版本是自带ctags的，如果没有，按如下方式安装</p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install ctags</span><br></pre></td></tr></table></figure>
<h3 id="taglist"><a href="#taglist" class="headerlink" title="taglist"></a>taglist</h3><p>taglist是vim的一个插件，可以将代码内的函数、变量等按规律列出来，方便查找</p>
<h4 id="项目地址-4"><a href="#项目地址-4" class="headerlink" title="项目地址"></a>项目地址</h4><p><a href="http://www.vim.org/scripts/script.php?script_id=273" target="_blank" rel="noopener">http://www.vim.org/scripts/script.php?script_id=273</a> </p>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">taglist</span><br><span class="line">|-- doc</span><br><span class="line">|   |-- taglist.txt</span><br><span class="line">|-- plugin</span><br><span class="line">  |-- taglist.viml</span><br></pre></td></tr></table></figure>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>打开~/.vimrc，输入如下内容<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">let Tlist_Show_One_File=1    " 只展示一个文件的taglist</span><br><span class="line">let Tlist_Exit_OnlyWindow=1  " 当taglist是最后以个窗口时自动退出</span><br><span class="line">let Tlist_Use_Right_Window=1 " 在右边显示taglist窗口</span><br><span class="line">let Tlist_Sort_Type="name"   " tag按名字排序</span><br></pre></td></tr></table></figure></p>
<h3 id="omnicppcomplete"><a href="#omnicppcomplete" class="headerlink" title="omnicppcomplete"></a>omnicppcomplete</h3><p>这是一个对C++进行语法补全的插件，可以对函数、命名空间、类成员等进行补全，使用起来和绝大多数IDE差不多，不一样的是IDE为你做了很多你不知道的事情，而omni补全需要依赖tags文件，需要你用ctags命令自己生成</p>
<h4 id="项目地址-5"><a href="#项目地址-5" class="headerlink" title="项目地址"></a>项目地址</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.vim/bundle &amp;&amp; wget "http://www.vim.org/scripts/download_script.php?src_id=7722" -O omnicppcomplete.zip &amp;&amp; unzip omnicppcomplete.zip -d omnicppcomplete</span><br></pre></td></tr></table></figure>
<h4 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── after</span><br><span class="line">│   └── ftplugin</span><br><span class="line">│       ├── cpp.vim</span><br><span class="line">│       └── c.vim</span><br><span class="line">├── autoload</span><br><span class="line">│   └── omni</span><br><span class="line">│       ├── common</span><br><span class="line">│       │   ├── debug.vim</span><br><span class="line">│       │   └── utils.vim</span><br><span class="line">│       └── cpp</span><br><span class="line">│           ├── complete.vim</span><br><span class="line">│           ├── includes.vim</span><br><span class="line">│           ├── items.vim</span><br><span class="line">│           ├── maycomplete.vim</span><br><span class="line">│           ├── namespaces.vim</span><br><span class="line">│           ├── settings.vim</span><br><span class="line">│           ├── tokenizer.vim</span><br><span class="line">│           └── utils.vim</span><br><span class="line">└── doc</span><br><span class="line">    └── omnicppcomplete.txt</span><br></pre></td></tr></table></figure>
<h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><p>打开~/.vimrc，输入如下内容<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">filetype plugin indent on</span><br><span class="line">set completeopt=longest,menu</span><br><span class="line">let OmniCpp_NamespaceSearch = 2     " search namespaces in the current buffer   and in included files</span><br><span class="line">let OmniCpp_ShowPrototypeInAbbr = 1 " 显示函数参数列表</span><br><span class="line">let OmniCpp_MayCompleteScope = 1    " 输入 :: 后自动补全</span><br><span class="line">let OmniCpp_DefaultNamespaces = ["std", "_GLIBCXX_STD"]</span><br></pre></td></tr></table></figure></p>
<h4 id="手动建立tags文件"><a href="#手动建立tags文件" class="headerlink" title="手动建立tags文件"></a>手动建立tags文件</h4><p>omni插件的补全是依赖于tags文件的<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctags -R --sort=yes --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++</span><br></pre></td></tr></table></figure></p>
<h3 id="SuperTab"><a href="#SuperTab" class="headerlink" title="SuperTab"></a>SuperTab</h3><p>你想要补全变量名或函数名只需按一下TAB键即可，出现候选窗口之后也可以用TAB键进行选择</p>
<h4 id="项目地址-6"><a href="#项目地址-6" class="headerlink" title="项目地址"></a>项目地址</h4><p><a href="https://github.com/ervandew/supertab" target="_blank" rel="noopener">https://github.com/ervandew/supertab</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>代码整洁</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81/</url>
    <content><![CDATA[<blockquote>
<p>“如果每个例程都让你感到深合己意，那就是整洁代码”-沃德</p>
</blockquote>
<p>SRP原则(单一权责原则):只有一个修改它的理由。</p>
<p>OCP原则(开放闭合原则):对扩展开放，对修改闭合。</p>
<p>要确保函数只做一件事，函数中的语句都要在同一抽象层级上。</p>
<p>如果函数看来需要两个/三个或三个以上的参数，就说明其中一些参数应该封装为类了。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>期望、方差、协方差和矩</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96/%E6%9C%9F%E6%9C%9B%E3%80%81%E6%96%B9%E5%B7%AE%E3%80%81%E5%8D%8F%E6%96%B9%E5%B7%AE%E5%92%8C%E7%9F%A9/</url>
    <content><![CDATA[<p><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script></p>
<h2 id="期望E"><a href="#期望E" class="headerlink" title="期望E"></a>期望E</h2><h3 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h3><p>所有可能取值的一个加权平均</p>
<blockquote>
<p>$E[X]=\sum_{x:p(x)&gt;0}xp(x)$</p>
</blockquote>
<h3 id="连续型随机变量"><a href="#连续型随机变量" class="headerlink" title="连续型随机变量"></a>连续型随机变量</h3><blockquote>
<p>$E[X] = \int_{-\infty}^{\infty}xf(x)dx$</p>
</blockquote>
<h2 id="方差Var"><a href="#方差Var" class="headerlink" title="方差Var"></a>方差Var</h2><p>X与其期望的差的平方的期望</p>
<blockquote>
<p>$Var(X) = E[(X-\mu)^2] = E[X^2] - (E[X])^2$</p>
</blockquote>
<h2 id="协方差Cov"><a href="#协方差Cov" class="headerlink" title="协方差Cov"></a>协方差Cov</h2><p>期望和方差可以给出单个随机变量的信息，两个随机变量的协方差可指示两个随机变量之间的关系</p>
<blockquote>
<p>$Cov(X, Y) = E[(X-E(X))(Y-E(Y))]=E[XY]-E[X]E[Y]$</p>
</blockquote>
<h2 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h2><p>设X, Y为两个随机变量，假定Var(X)和Var(Y)均大于0，则</p>
<blockquote>
<p>$\rho(X, Y) = \frac{Cov(X, Y)}{\sqrt{Var(X)Var(Y)}}$<br>称为X和Y的相关系数</p>
</blockquote>
<h2 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h2><blockquote>
<p>数学期望和方差可以纳入到一个更一般的概念范畴中，那就是随机变量的矩。<br>设X为随机变量，k为正整数，如果$E(X^k)$存在，则称$E(X^k)$为X的k阶原点矩<br>如果$E[(X-E(X))^k]$存在，则称$E[(X-E(X))^k]$为X的k阶中心矩<br>显然，一阶原点矩就是数学期望，二阶中心矩就是方差</p>
</blockquote>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>版本控制</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><ol>
<li>主版本号<br>就API修改而言，主版本号的改变表明添加了大量向后兼容的新特性，或者向后兼容性遭到了破坏。总之，API主版本号的增长向客户表明API进行了重大修改。</li>
<li>次版本号<br>每当添加较小的特性或修正重大错误时这个数会增大。次版本号的修改通常不应该涉及任何不兼容的API修改。用户应该能够升级到新的次版本，而不必对自己的软件做任何改动。不过一些新的特性可能被添加到API中。</li>
<li>补丁版本号<br>补丁版本号的变更应该暗示现行的API接口没有修改，也就是只有API的行为有所改变。</li>
</ol>
<h2 id="提供API的版本信息"><a href="#提供API的版本信息" class="headerlink" title="提供API的版本信息"></a>提供API的版本信息</h2><p>API的版本信息应该可以在代码中访问，以便允许客户以API版本号为条件编写代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//version.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> API_MAJOR 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> API_MINOR 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> API_PATCH 0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Version</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetMajor</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetMinor</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetPatch</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetVersion</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsAtLeast</span><span class="params">(<span class="keyword">int</span> major, <span class="keyword">int</span> minor, <span class="keyword">int</span> patch)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">HasFeature</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="软件分支策略"><a href="#软件分支策略" class="headerlink" title="软件分支策略"></a>软件分支策略</h2><p>大型软件项目通常会涉及某种形式的分支策略，这就需要同步开发、固定及维护不同的软件发布版本。</p>
<h3 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h3><p>每个软件项目都需要一条”主干”代码路线，它是项目源代码的持久存储库。对于每次版本发布，或者必须与下次发布区分的开发工作，可由主干代码派发出分支。这个模型支持并行开发，可以将新特性加入项目，同时锁定对即将发布版本的修改，使现存的特性集保持稳定。</p>
<blockquote>
<p>只在必要时再分支，尽量延迟创建分支的时间。尽量使固体不过分支代码路线而非冻结代码路线。尽早且频繁地合并分支。</p>
</blockquote>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>编程珠玑-随机抽样</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91-%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7/</url>
    <content><![CDATA[<p>该算法按顺序考虑整数0,1,2,…,n-1，并通过合适的随机测试选择每个元素。通过按序访问整数，就能保证输出结果是有序的。</p>
<p>下面通过m=2和n=5这个例子来理解选择条件。选择第一个整数0，概率为2/5，程序通过下面的语句来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;<span class="comment">//总的样本数</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">50</span>;<span class="comment">//抽取的样本数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = m;</span><br><span class="line"><span class="keyword">int</span> remaining = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>((random.nextInt() % remaining) &lt; select &amp;&amp; select &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(i);</span><br><span class="line">		select--;</span><br><span class="line">	&#125;</span><br><span class="line">	remain++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>通过源代码安装nagios</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96/%E9%80%9A%E8%BF%87%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%89%E8%A3%85nagios/</url>
    <content><![CDATA[<p>目的</p>
<p>这个文档描述了如何在CentOS和Ubuntu服务器上通过源代码安装Nagios Core和Nagios Plugins</p>
<p>目标读者</p>
<p>所有想要通过源代码安装Nagios Core</p>
<p>先决条件</p>
<p>Ubuntu</p>
<p>执行这个文档里面的所有步骤使用root权限，下面的命令可以切换到root shell。<br>sudo -i</p>
<p>在不同的平台安装Nagios，对于依赖包的要求会有所不同。<br>RHEL/CentOS:<br>yum install -y wget httpd php gcc glibc glibc-common gd gd-devel make net-snmp</p>
<p>Ubuntu:<br>sudo apt-get install wget build-essential apache2 php5-gd libgd2-xpm libgd2-xpm-dev libapache2-modphp5</p>
<p>下载Nagios Core和Nagios Plugins Tarballs</p>
<p>所有系统，在你的终端中运行以下命令:<br>cd /tmp<br>wget <a href="http://prdownloads.sourceforge.net/sourceforge/nagios/nagios-4.0.4.tar.gz" target="_blank" rel="noopener">http://prdownloads.sourceforge.net/sourceforge/nagios/nagios-4.0.4.tar.gz</a><br>wget <a href="http://nagios-plugins.org/download/nagios-plugins-2.0.tar.gz" target="_blank" rel="noopener">http://nagios-plugins.org/download/nagios-plugins-2.0.tar.gz</a><br>这里会下载Nagios Core和它所要求的插件</p>
<p>增加Nagios用户和组</p>
<p>为了Nagios进程的运行增加适当的用户和组<br>useradd nagios<br>groupadd nagcmd<br>usermod -a -G nagcmd nagios</p>
<p>Nagios Core安装</p>
<p>tar zxvf nagios-4.0.4.tar.gz<br>tar zxvf nagios-plugins-2.0.tar.gz<br>切换到Nagios目录然后安装package：<br>cd nagios-4.0.4</p>
<p>RHEL/CentOS:<br>./configure –with-command-group=nagcmd<br>Ubuntu:<br>./configure –with-nagios-group=nagios –with-command-group=nagcmd -–with-mail=/usr/bin/sendmail</p>
<p>所有系统:<br>make all<br>make install<br>make install-init<br>make install-config<br>make install-commandmode<br>make install-webconf<br>cp -R contrib/eventhandlers/ /usr/local/nagios/libexec/<br>chown -R nagios:nagios /usr/local/nagios/libexec/eventhandlers<br>/usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg<br>/etc/init.d/nagios start</p>
<p>RHEL/CentOS:<br>/etc/init.d/httpd start</p>
<p>创建一个默认用户用于Web访问</p>
<p>htpasswd –c /usr/local/nagios/etc/htpasswd.users nagiosadmin</p>
<p>Nagios Plugin安装</p>
<p>cd /tmp/nagios-plugins-2.0<br>./configure –with-nagios-user=nagios –with-nagios-group=nagios<br>make<br>make install</p>
<p>Nagios Service设置</p>
<p>下面的命令会注册系统启动时运行Nagios守护进程<br>chkconfig –add nagios<br>chkconfig –level 35 nagios on<br>chkconfig –add httpd<br>chkconfig –level 35 httpd on</p>
<p>Ubuntu:<br>ln -s /etc/init.d/nagios /etc/rcS.d/S99nagios<br>Nagios Web界面</p>
<p>在安装正确的步骤安装后，你可以通过web浏览器访问Nagios Core。<br>使用一下：<br>http://&lt;your.nagios.server.ip&gt;/nagios<br>使用你在向htpasswd.users文件里增加nagiosadmin用户时你选择的凭证。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>金字塔原理</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<div id="echarts6464" style="width: 81%;height: 400px;margin: 0 auto"></div>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts6464'));

        // 指定图表的配置项和数据
        var option = {
      tooltip: {
          trigger: 'item',
          triggerOn: 'mousemove'
      },
      series: [
          {
              type: 'tree',
              label: {normal: {position: 'left'}},
              expandAndCollapse: true,
              animationDuration: 550,
              animationDurationUpdate: 750,
              data: [{
                name: '金字塔原理',
                children: [
                  {
                    name: '基本原则',
                    children: [{name: '结论先行'},{name: '以上统下'},{name: '归类分组'},{name: '逻辑递进'}]
                  },
                  {
                    name: '归类分组',
                    children: [{name: '序言'},{name: '纵向关系'},{name: '横向关系'}]
                  },
                  {
                    name: '同一层次',
                    children: [
                      {name: '演绎顺序',children: [{name: '演绎推理'},{name: '归纳推理'}]},
                      {name: '逻辑顺序',children: [{name: '时间顺序'},{name: '结构顺序'},{name: '程度顺序'}]}
                    ]
                  }
                ]
              }]
          }
      ]
  };

        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>错误处理</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>错误处理很重要，但如果它搞乱了代码逻辑，就是错误的做法。</p>
<p>使用异常而非返回码</p>
<p>这类问题在于，调用者必须在调用之后即刻检查错误。不幸的是，这个步骤很容易被遗忘。所以遇到错误时，最好抛出一个异常。调用代码很整洁，其逻辑不会被错误处理搞乱。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>静态代码分析工具</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="什么是静态代码分析"><a href="#什么是静态代码分析" class="headerlink" title="什么是静态代码分析"></a>什么是静态代码分析</h2><pre><code>静态代码分析是指无需运行被测代码，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性，找出代码隐藏的错误和缺陷，如参数不匹配，有歧义的嵌套语句，错误的递归，非法计算，可能出现的空指针引用等等。

在软件开发过程中，静态代码分析往往先于动态测试之前进行，同时也可以作为制定动态测试用例的参考。统计证明，在整个软件开发生命周期中，30% 至 70% 的代码逻辑设计和编码缺陷是可以通过静态代码分析来发现和修复的。
但是，由于静态代码分析往往要求大量的时间消耗和相关知识的积累，因此对于软件开发团队来说，使用静态代码分析工具自动化执行代码检查和分析，能够极大地提高软件可靠性并节省软件开发和测试成本。
</code></pre><h2 id="静态代码分析工具的优势"><a href="#静态代码分析工具的优势" class="headerlink" title="静态代码分析工具的优势"></a>静态代码分析工具的优势</h2><ol>
<li>帮助程序开发人员自动执行静态代码分析，快速定位代码隐藏错误和缺陷。</li>
<li>帮助代码设计人员更专注于分析和解决代码设计缺陷。</li>
<li><p>显著减少在代码逐行检查上花费的时间，提高软件可靠性并节省软件开发和测试成本。</p>
<h2 id="Java-静态分析工具"><a href="#Java-静态分析工具" class="headerlink" title="Java 静态分析工具"></a>Java 静态分析工具</h2><h3 id="Checkstyle"><a href="#Checkstyle" class="headerlink" title="Checkstyle"></a>Checkstyle</h3><pre><code>Checkstyle 是 SourceForge 的开源项目，通过检查对代码编码格式，命名约定，Javadoc，类设计等方面进行代码规范和风格的检查，从而有效约束开发人员更好地遵循代码编写规范。
Checkstyle 提供了支持大多数常见 IDE 的插件，文本主要使用 Eclipse 中的 Checkstyle 插件。
</code></pre><h2 id="C-C-静态分析工具"><a href="#C-C-静态分析工具" class="headerlink" title="C/C++静态分析工具"></a>C/C++静态分析工具</h2><h3 id="Cppcheck"><a href="#Cppcheck" class="headerlink" title="Cppcheck"></a>Cppcheck</h3><pre><code>Cppcheck是一个C/C++代码的静态分析工具。它和其他C/C++编译器不同的是它不检测语法的错误，它通常检测编译器不检测的错误。
</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>分布式一致性-2PC</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7-2PC/</url>
    <content><![CDATA[<p>2PC,即二阶段提交，是计算机网络尤其是在数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务处理过程中能够保持原子性和一致性而设计的一种算法。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式一致性-3PC</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7-3PC/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式一致性-Paxos</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7-Paxos/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式事务-TCC</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-TCC/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式事务-可靠消息服务</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式事务-最大努力通知</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式任务-Elastic-Cloud</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1-Elastic-Cloud/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式任务-Elastic-Job</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1-Elastic-Job/</url>
    <content><![CDATA[<h1 id="Elastic-Job-Lite"><a href="#Elastic-Job-Lite" class="headerlink" title="Elastic-Job-Lite"></a>Elastic-Job-Lite</h1><p>Elastic-Job-Lite定位为轻量级无中心化解决方案，使用jar包的形式提供最轻量级的分布式任务的协调服务，外部依赖仅Zookeeper。</p>
<h3 id="主节点选举"><a href="#主节点选举" class="headerlink" title="主节点选举"></a>主节点选举</h3><table>
<thead>
<tr>
<th>节点</th>
<th>节点类型</th>
<th>节点作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>/${namespace}/${jobName}/leader/election/latch</td>
<td>持久</td>
<td>用于选举的锁</td>
</tr>
<tr>
<td>/${namespace}/${jobName}/leader/election/instance</td>
<td>临时</td>
<td>保存主节点地址</td>
</tr>
<tr>
<td>/${namespace}/${jobName}/leader/sharding/necessary</td>
<td>持久</td>
<td>判断是否需要重新分片</td>
</tr>
<tr>
<td>/${namespace}/${jobName}/leader/sharding/processing</td>
<td>临时</td>
<td>标记主节点正在sharding 的标志</td>
</tr>
<tr>
<td>/${namespace}/${jobName}/sharing/${shardingItem}/instance</td>
<td>永久</td>
<td>保存拿到shardingItem分片的作业实例</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式任务-Xxl-Job</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1-Xxl-Job/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式全局唯一ID-Flicker</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID-Flicker/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式全局唯一ID-Redis</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID-Redis/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式全局唯一ID-SnowFlake</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID-SnowFlake/</url>
    <content><![CDATA[<p>SnowFlake算法生成id的结果是一个64bit大小的整数。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式数据库-Join</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93-Join/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式系统-一致性哈希</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式系统-令牌环</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E4%BB%A4%E7%89%8C%E7%8E%AF/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式系统-令牌环</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E5%B9%82%E7%AD%89%E6%80%A7/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式系统</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>分布式系统是若干独立计算机的集合，这些计算机对于用于来说就像是单个相关系统。</p>
<p>4个关键目标:使资源可访问；透明性；开放性；可扩展性。</p>
<h2 id="分布式系统的分类"><a href="#分布式系统的分类" class="headerlink" title="分布式系统的分类"></a>分布式系统的分类</h2><h3 id="1-分布式计算系统："><a href="#1-分布式计算系统：" class="headerlink" title="1.分布式计算系统："></a>1.分布式计算系统：</h3><p>集群计算：同构性</p>
<p>网格计算：异构性。Foster提出了一种体系结构。该体系结构由4层组成(光纤层，连接层，资源层，汇集层，应用层)。通常，汇集层、连接层和资源层形成了成为网格中间件层的核心。这些层提供了对资源的访问和管理，而这些资源是分散在多个地点的。SOA(面向服务的体系结构)和OGSA(开放式网格服务体系结构)体现了这种思想。</p>
<h3 id="2-分布式信息系统："><a href="#2-分布式信息系统：" class="headerlink" title="2.分布式信息系统："></a>2.分布式信息系统：</h3><p>事务处理系统</p>
<p>企业应用集成</p>
<h3 id="3-分布式普适系统"><a href="#3-分布式普适系统" class="headerlink" title="3.分布式普适系统"></a>3.分布式普适系统</h3><p>之前的分布式系统最大的特点就是他们的稳定性：结点是固定的，具有或多或少的持续性和高质量的网络连接。随着移动和嵌入式计算设备的引入，不稳定性是分布式系统的默认行为。主要有三种需求：接受上下文的变化，促使自主合成，认可共享为默认行为。</p>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>分布式系统的组织结构主要是指组成该系统的软件组件。软件体系结构的最终实例又称为系统体系结构</p>
<h3 id="1-体系结构样式"><a href="#1-体系结构样式" class="headerlink" title="1.体系结构样式"></a>1.体系结构样式</h3><p>分层体系结构<br>基于对象的体系结构<br>以数据为中心的体系结构</p>
<p>基于事件的体系结构</p>
<h3 id="2-系统体系结构"><a href="#2-系统体系结构" class="headerlink" title="2.系统体系结构"></a>2.系统体系结构</h3><p>集中式体系结构</p>
<p>非集中式体系结构</p>
<pre><code>1.结构化的点对点体系结构：通过分布式哈希表来构造覆盖网络。

2.非结构化的点对点体系结构：依靠随机化的算法来构造覆盖网络。每个结点维护一个邻结点列表，但这个列表是以一种或多或少为随机的方法来构造。
</code></pre><p>混合式体系结构</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式系统设计-支付系统</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式系统设计-短网址系统</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式系统设计-秒杀系统</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式系统设计-脑裂</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%84%91%E8%A3%82/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>中国哲学</title>
    <url>/%E5%93%B2%E5%AD%A6/%E5%93%B2%E5%AD%A6/%E4%B8%AD%E5%9B%BD%E5%93%B2%E5%AD%A6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>哲学</category>
      </categories>
  </entry>
  <entry>
    <title>如何解决问题</title>
    <url>/%E5%93%B2%E5%AD%A6/%E5%93%B2%E5%AD%A6/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>发现问题之所在-知识域<br>理清问题之来源-历史<br>寻找解题之思路-论证<br>构建解题之语言</p>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
  </entry>
  <entry>
    <title>西方哲学</title>
    <url>/%E5%93%B2%E5%AD%A6/%E5%93%B2%E5%AD%A6/%E8%A5%BF%E6%96%B9%E5%93%B2%E5%AD%A6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>哲学</category>
      </categories>
  </entry>
  <entry>
    <title>Directshow开发指南-Filter</title>
    <url>/%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93/Directshow%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-Filter/</url>
    <content><![CDATA[<p>Filter是Directshow中最基本的概念。Directshow使用FilterGraph来管理Filter。</p>
<p>Filter一般由一个或多个Pin组成，Filter之间通过Pin相互连接，构成一条顺序的链路。Filter根据实现功能的不同大致可分为3类：source filters、transform filters和rendering filters。</p>
<p>Filter是一种Com组将。每个Filter实现了IBaseFilter接口。</p>
<p>Filter通过API函数CoCreateInstance完成。</p>
<p>Filter使用媒体类型(Media Type)来描述数据流<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Typedefstruct _MediaType&#123;</span><br><span class="line">GUID Majortype;</span><br><span class="line">GUID Subtype;</span><br><span class="line">BOOL bFixedSizeSamples;</span><br><span class="line">BOOL bTemporalCompression;</span><br><span class="line">ULONG lSampleSize;</span><br><span class="line">GUID Formattype;</span><br><span class="line">Iunknown *pUnk;</span><br><span class="line">ULONG cbFormat;</span><br><span class="line">BYTE *pbFormat;</span><br><span class="line">&#125;AM_MEDIA_TYPE;</span><br></pre></td></tr></table></figure></p>
<p>媒体类型主要用3部分来描述：majortype(主类型)、subtype(辅助说明类型)和formattype(格式细节类型)</p>
<p>Majortype:定性的描述媒体类型，比如MEDIATYPE_Video,MEDIATYPE_Audio等</p>
<p>Subtype:辅助说明majortype，指明具体是哪种格式，例如，UYVY、YUY2</p>
<p>Formattype:指定了一种进一步描述格式细节的数据结构类型，包括视频图像大小、帧率，这个描述格式细节的数据块指针保存在pbFormat成员中。</p>
<p>Filter的连接：</p>
<p>1.Filter GraphManager在输出Pin上调用Ipin::Connect(带输入Pin的指针作为参数);</p>
<p>2.如果输出Pin接受连接，则调用输入Pin上的Ipin::ReceiveConnection;</p>
<p>3.如果输入Pin也接受这次连接，则双方连接成功。</p>
<p>Filter的Merit值，Merit可以理解成为Filter被智能连接所使用的优先级。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enum</span><br><span class="line">&#123;</span><br><span class="line">MERIT_PREFERRED</span><br><span class="line">MERIT_NORMAL</span><br><span class="line">MERIT_UNLIKELY</span><br><span class="line">MERIT_DO_NOT_USE</span><br><span class="line">MERIT_SW_COMPRESSOR</span><br><span class="line">MERIT_HW_COMPRESSOR</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Merit值只有在大于MERIT_DO_NOT_USE的时候，才有可能被智能连接所使用</p>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
  </entry>
  <entry>
    <title>FLV格式解析</title>
    <url>/%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93/FLV%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>FLV文件由FLV Header和FLV Body组成</p>
<p>1  FLV Header</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>标签</td>
<td>UI8,1字节</td>
<td>F,0x46</td>
</tr>
<tr>
<td>标签</td>
<td>UI8,1字节</td>
<td>L,0x4C</td>
</tr>
<tr>
<td>标签</td>
<td>UI8,1字节</td>
<td>V,0x56</td>
</tr>
<tr>
<td>版本号</td>
<td>UI8,1字节</td>
<td>文件版本(目前版本是1)</td>
</tr>
<tr>
<td>预留标记</td>
<td>UB[5],5bit</td>
<td>必须是0</td>
</tr>
<tr>
<td>音频标记</td>
<td>UB[1],1bit</td>
<td>是否存在音频</td>
</tr>
<tr>
<td>预留标记</td>
<td>UB[1],1bit</td>
<td>必须是0</td>
</tr>
<tr>
<td>视频标记</td>
<td>UB[1],1bit</td>
<td>是否存在视频</td>
</tr>
<tr>
<td>数据偏移</td>
<td>UI32,4字节</td>
<td>从文件开始到文件body的偏移(文件头的大小)</td>
</tr>
</tbody>
</table>
<p>2  FLV Body</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>PreviousTagSize0</td>
<td>UI32,4字节</td>
<td>0</td>
</tr>
<tr>
<td>Tag1</td>
<td>FLVTAG</td>
<td>第1个tag</td>
</tr>
<tr>
<td>PreviousTagSize1</td>
<td>UI32,4字节</td>
<td>第1个tag大小(tag header+tag body)</td>
</tr>
<tr>
<td>Tag2</td>
<td>FLVTAG</td>
<td>第2个tag</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PreviousTagSizeN-1</td>
<td>UI32,4字节</td>
<td>第N-1个tag大小</td>
</tr>
<tr>
<td>TagN</td>
<td>FLVTAG</td>
<td>第N个tag</td>
</tr>
<tr>
<td>PreviousTagSizeN</td>
<td>UI32,4字节</td>
<td>第N个tag大小</td>
</tr>
</tbody>
</table>
<p>3  FLV Tags</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>tag类型</td>
<td>UI8</td>
<td>8:音频 9:视频 18:脚本数据 其他为保留</td>
</tr>
<tr>
<td>数据大小</td>
<td>UI24</td>
<td>数据区大小</td>
</tr>
<tr>
<td>时间戳</td>
<td>UI24</td>
<td>毫秒为单位，第一个tag为0</td>
</tr>
<tr>
<td>扩展时间戳</td>
<td>UI8</td>
<td>放在高8位，前面的时间戳在低24位</td>
</tr>
<tr>
<td>StreamID</td>
<td>UI24</td>
<td>一直是0</td>
</tr>
<tr>
<td>数据</td>
<td>tag 类型 ==  8,AUDIODATA TAG TYPE ==9,VIDEODATA TAG TYPE ==18 SCRIPTDATAOBJECT</td>
<td>tag body</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
  </entry>
  <entry>
    <title>mingw编译librtmp</title>
    <url>/%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93/MinGW%E7%BC%96%E8%AF%91librtmp/</url>
    <content><![CDATA[<p>1  下载<br>MinGW和MSYS:<a href="http://www.mingw.org/" target="_blank" rel="noopener">http://www.mingw.org/</a><br>zlib:<a href="http://www.zlib.net/" target="_blank" rel="noopener">http://www.zlib.net/</a><br>openSSL:<a href="http://www.openssl.org/" target="_blank" rel="noopener">http://www.openssl.org/</a><br>ActiveState Perl：<a href="http://www.perl.org/" target="_blank" rel="noopener">http://www.perl.org/</a><br>rtmpdump:<a href="http://rtmpdump.mplayerhq.hu/" target="_blank" rel="noopener">http://rtmpdump.mplayerhq.hu/</a></p>
<p>2  编译<br>2.1  编译zlib<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy win32\makefile.gcc makefile.gcc</span><br><span class="line">mingw32-make -f makefile.gcc</span><br></pre></td></tr></table></figure></p>
<p>2.2  编译openssl<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure mingw --prefix=`pwd`/win32libs -DL_ENDIAN -DOPENSSL_NO_HW</span><br><span class="line">#修改Makefile和crypto/Makefile文件</span><br><span class="line">#将gcc替换为mingw32-gcc</span><br><span class="line">#将cc替换为mingw32-cc</span><br><span class="line">#修改文件</span><br><span class="line">#md2test.c </span><br><span class="line">#dummytest.c修改为#include &quot;dummytest.c&quot;</span><br><span class="line">#rc5test.c </span><br><span class="line">#dummytest.c修改为#include &quot;dummytest.c&quot;</span><br><span class="line">#jpaketest.c</span><br><span class="line">#dummytest.c修改为#include &quot;dummytest.c&quot;</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p>
<p>2.3  编译rtmpdump<br>2.3.1  依赖文件<br>将openssl/include下openssl文件夹复制到/MinGW/include目录</p>
<p>将zlib下zconf.h和zlib.h复制/MinGW/include目录</p>
<p>将openssl下(libcrypto.a,libssl.a,ssleay32.lib,libeay32.lib)拷至/MinGW/lib目录</p>
<p>zlib下libz.a拷至/MinGW/lib目录</p>
<p>2.3.2  编译<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make SYS=mingw</span><br><span class="line">make SYS=mingw install</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
  </entry>
  <entry>
    <title>MinGW编译x264</title>
    <url>/%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93/MinGW%E7%BC%96%E8%AF%91x264/</url>
    <content><![CDATA[<p>1  准备</p>
<p>yasm:<a href="http://yasm.tortall.net/" target="_blank" rel="noopener">http://yasm.tortall.net/</a></p>
<p>x264:<a href="http://www.videolan.org/developers/x264.html" target="_blank" rel="noopener">http://www.videolan.org/developers/x264.html</a></p>
<p>下载对应系统的yasm放到/MinGW/msys/1.0/bin下，重新命名为yasm.exe<br>2  编译</p>
<p>./configure –enable-shared<br>make</p>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
  </entry>
  <entry>
    <title>基于Mirror Driver的屏幕捕捉技术</title>
    <url>/%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93/MirrorDriver/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	//获取屏幕DC</span><br><span class="line">	HDC hDesktopDC = CreateDC(L&quot;DISPLAY&quot;, NULL, NULL, NULL);</span><br><span class="line">	//内存DC</span><br><span class="line">	HDC hMemoryDC = CreateCompatibleDC(hDesktopDC);</span><br><span class="line"> </span><br><span class="line">	//得到屏幕宽度</span><br><span class="line">	int nScreenWidth = GetSystemMetrics(SM_CXSCREEN);</span><br><span class="line">	int nScreenHeight = GetSystemMetrics(SM_CYSCREEN);</span><br><span class="line"> </span><br><span class="line">	//根据屏幕DC创建屏幕位图</span><br><span class="line">	HBITMAP hCaptureBitmap = CreateCompatibleBitmap(hDesktopDC, nScreenWidth, nScreenHeight);</span><br><span class="line"> </span><br><span class="line">	//将位图选择到内存DC中</span><br><span class="line">	SelectObject(hMemoryDC, hCaptureBitmap);</span><br><span class="line"> </span><br><span class="line">	//将屏幕DC传送到内存DC中</span><br><span class="line">	BitBlt(hMemoryDC, 0, 0, nScreenWidth, nScreenHeight, hDesktopDC, 0, 0, SRCCOPY);</span><br><span class="line"> </span><br><span class="line">	//得到鼠标位置</span><br><span class="line">	POINT pt;</span><br><span class="line">	GetCursorPos(&amp;pt);</span><br><span class="line">	//加载鼠标位图</span><br><span class="line">	HCURSOR m_hcursor = LoadCursor(NULL, IDC_ARROW);</span><br><span class="line"> </span><br><span class="line">	DrawIconEx(hMemoryDC, pt.x, pt.y, m_hcursor, 0, 0, 0, NULL, DI_NORMAL | DI_COMPAT);</span><br><span class="line"> </span><br><span class="line">	SelectObject(hMemoryDC, hCaptureBitmap);</span><br><span class="line"> </span><br><span class="line">	char str1[50] = &quot;D:/123.bmp&quot;;</span><br><span class="line">	SaveBMPToFile(hCaptureBitmap, str1, pt.x, pt.y);</span><br><span class="line"> </span><br><span class="line">	DeleteDC(hDesktopDC);</span><br><span class="line">	DeleteDC(hMemoryDC);</span><br><span class="line">	DeleteObject(hCaptureBitmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
  </entry>
  <entry>
    <title>基于Mirror Driver的屏幕捕捉技术</title>
    <url>/%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9F%BA%E4%BA%8EMirror%20Driver%E7%9A%84%E5%B1%8F%E5%B9%95%E6%8D%95%E6%8D%89%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//获取屏幕DC</span></span><br><span class="line">	HDC hDesktopDC = CreateDC(<span class="string">L"DISPLAY"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//内存DC</span></span><br><span class="line">	HDC hMemoryDC = CreateCompatibleDC(hDesktopDC);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//得到屏幕宽度</span></span><br><span class="line">	<span class="keyword">int</span> nScreenWidth = GetSystemMetrics(SM_CXSCREEN);</span><br><span class="line">	<span class="keyword">int</span> nScreenHeight = GetSystemMetrics(SM_CYSCREEN);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据屏幕DC创建屏幕位图</span></span><br><span class="line">	HBITMAP hCaptureBitmap = CreateCompatibleBitmap(hDesktopDC, nScreenWidth, nScreenHeight);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将位图选择到内存DC中</span></span><br><span class="line">	SelectObject(hMemoryDC, hCaptureBitmap);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将屏幕DC传送到内存DC中</span></span><br><span class="line">	BitBlt(hMemoryDC, <span class="number">0</span>, <span class="number">0</span>, nScreenWidth, nScreenHeight, hDesktopDC, <span class="number">0</span>, <span class="number">0</span>, SRCCOPY);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//得到鼠标位置</span></span><br><span class="line">	POINT pt;</span><br><span class="line">	GetCursorPos(&amp;pt);</span><br><span class="line">	<span class="comment">//加载鼠标位图</span></span><br><span class="line">	HCURSOR m_hcursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line"></span><br><span class="line">	DrawIconEx(hMemoryDC, pt.x, pt.y, m_hcursor, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, DI_NORMAL | DI_COMPAT);</span><br><span class="line"></span><br><span class="line">	SelectObject(hMemoryDC, hCaptureBitmap);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> str1[<span class="number">50</span>] = <span class="string">"D:/123.bmp"</span>;</span><br><span class="line">	SaveBMPToFile(hCaptureBitmap, str1, pt.x, pt.y);</span><br><span class="line"></span><br><span class="line">	DeleteDC(hDesktopDC);</span><br><span class="line">	DeleteDC(hMemoryDC);</span><br><span class="line">	DeleteObject(hCaptureBitmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
  </entry>
  <entry>
    <title>多媒体技术教程-数字音频</title>
    <url>/%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B-%E6%95%B0%E5%AD%97%E9%9F%B3%E9%A2%91/</url>
    <content><![CDATA[<h2 id="什么声音"><a href="#什么声音" class="headerlink" title="什么声音?"></a>什么声音?</h2><p>声音是一种波动现象，一些物理器件的运动导致了空气分子的震动，进而产生声波。<br>声波数字化<br>声波都带有可测量的压力值，因此我们使用压力传感器将压力转换成电压差，从而通过检测某个区域的压力值来探测声音。要将信号全部数字化，我们就要在每一维(时间维和幅值)上采样。<br>在时间轴上的采样简称”采样”，采样的速度称为采样率。人能够听见从20Hz~20kHz的声音。根据奈奎斯特理论，我们需要使用的的采样频率至少是信号中最高频率的两倍。<br>在振幅维上的采样成为量化。如果幅度的划分是等间隔的就称为线性量化，否则就称为非线性量化。韦伯定律指出，声音自身的强度越大，就越需要更大的振幅来让我们感受到声音的变化。例如我们能够感受到从10磅到11磅的变化，那么从20磅开始，需要增加到22磅我们才能感受到同样的重量变化。</p>
<h2 id="信噪比"><a href="#信噪比" class="headerlink" title="信噪比"></a>信噪比</h2><p>在模拟系统中，随机的波动会在信号里产生噪声，测量电压会因此而变得不准确。正确信号的能量和噪声能量的比称为信噪比(Signal-to-Noise Ratio, SNR)。<br>SNR = 10lg( ( Vsignal ) ^ 2 / ( Vnoise ) ^ 2 ) = 20lg(Vsignal/Vnoise)<br>我们把周围环境中的声音和我们能够听到的最轻的声音求能量比，然后得到dB值，用它来衡量声音的强度。</p>
<h2 id="采样精度"><a href="#采样精度" class="headerlink" title="采样精度"></a>采样精度</h2><p>样本大小是用每个声音样本的位数表示的，它反映度量声音波形幅度的精度。位数越多，存储空间越多，声音越精确。<br>假设Vnoise = 1,采样精度为1位表示Vsignal = 2^1，它的信噪比SNR = 6dB<br>假设Vnoise = 1,采样精度为16位表示Vsignal = 2^16，它的信噪比SNR = 96dB</p>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
  </entry>
  <entry>
    <title>编译libjpeg-6b</title>
    <url>/%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93/%E7%BC%96%E8%AF%91libjpeg-6b/</url>
    <content><![CDATA[<p>1、下载libjpeg的源代码jpegsr6.zip</p>
<p>2、解压出来一堆文件，打开命令行窗口（CMD），进入代码所放的目录下</p>
<p>3、运行命令：nmake /f makefile.vc nodebug=1 开始编译，然后问题就来了</p>
<p>4、“nmake 不是内部或外部命令”<br>  这个执行文件在VC的安装目录中，解决方法：输入命令 path C:\Program Files\Microsoft Visual Studio 9.0\VC\bin; %SystemRoot%\system32;回车</p>
<p>5、makefile.vc<11>:fatal error U1052: file ‘win32.mak’ not found<br>  提示找不到win32.mak文件，这个文件定义了一些必须的宏，这个文件在Windows SDK的安装目录中，打开makefile.vc文件修改第12行为：<br>  !include &lt;C:\Program Files\Microsoft SDKs\Windows\v6.0A\Include\win32.mak&gt;<br>  保存，再执行编译命令又有新的错误。</11></p>
<p>6、NMAKE:fatal error U1073: don’t know how to make ‘jconfig.h’<br>  这是个奇怪的问题，在网上搜了半天没有结果，最后才发现原来目录中没有这个文件。其实只要把文件jconfig.vc更名为jconig.h即可。再执行编译命令又有新的错误。</p>
<p>7、NMAKE: fatal error U1077: ‘…\cl.EXE’ : return code ‘0xc0000135’<br>  CL命令未能执行，我们直接在命令行提示后面输入cl回车，会有个提示“没有找到 mspdb80.dll ”。解决方法：输入 vcvars32 回车，这是一个用来设置VC路径环境的批处理。再次执行编译命令，出现了一行行字符快速的刷新，哈哈，已经开始编译了。最后又出现一个错误，这个就不用管它了，因为我们需要的libjpeg.lib文件已经出现在了当前目录中。</p>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
  </entry>
  <entry>
    <title>Unicode</title>
    <url>/%E5%AE%A2%E6%88%B7%E7%AB%AF/%E5%AE%A2%E6%88%B7%E7%AB%AF/Unicode/</url>
    <content><![CDATA[<p>Unicode</p>
<p>Unicode是ASCII字符编码的一个扩展。Unicode用的是16位字符编码。</p>
<p>0x0000-0x007F:ASCII码</p>
<p>0x0080-0x00FF:ISO 8859-1 ASCII扩展码</p>
<p>char和宽字符</p>
<p>char *p = “Hello”;</p>
<p>wchar_t *pW = L”Hello”;</p>
<p>大写的字母L(表示长整型)，这向编译器表明这个字符串将用宽字符存储。</p>
<p>TCHAR.H</p>
<pre><code>宽字符运行库函数比正常的函数要大。为此你可能希望创建另个版本的程序，一个用ASCII字符串而另一个使用Unicode字符串。而最好的办法则是维护一个单一的源代码文件，但可以编译成ASCII或Unicode。

但这是有问题的，因为运行库函数具有不同名称，字符变量的定义也不同。

一个答案是使用包含在Microsoft Visual C++中的TCHAR.H头文件。这个头文件并不是ANSI C标准的一部分，所以其中的每一个函数和宏都有一个下划线前缀。TCHAR.H为那些需要字符串参数的普通运行库函数提供了一系列 的替代名称。这些函数有时被称为“通用”的函数名字，因为它们可以指Unicode或非Unicode版本的函数。
</code></pre><p>如果一个命名为_UNICODE的标识符被定义了并且TCHAR.H头文件被包含在你的程序中</p>
<p>#define _tcslen wcslen</p>
<p>如果_UNICODE没有被定义</p>
<p>#define _tcslen strlen</p>
<p>同样，_UNICODE定义</p>
<p>typedef wchar_t TCHAR</p>
<p>_UNICODE没有被定义</p>
<p>typedef char TCHAR</p>
]]></content>
      <categories>
        <category>客户端</category>
      </categories>
  </entry>
  <entry>
    <title>Windows窗口程序的生命周期</title>
    <url>/%E5%AE%A2%E6%88%B7%E7%AB%AF/%E5%AE%A2%E6%88%B7%E7%AB%AF/Windows%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="程序的执行"><a href="#程序的执行" class="headerlink" title="程序的执行"></a>程序的执行</h2><p>当执行Windows程序的时候，加载器加载该程序，然后调用C startup code，再调用程序中WinMain函数入口。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>WinMain函数首先通过CreateWindow函数创建窗口，并对窗口进行初始化配置;</p>
<h2 id="消息的处理"><a href="#消息的处理" class="headerlink" title="消息的处理"></a>消息的处理</h2><p>程序通过循环GetMessage函数不断的从消息队列中抓取消息;</p>
<p>当抓取到消息后，通过DispatchMessage函数将消息分发出去，在DispatchMessage中根据switch/case语句对消息进行判别，并做相应的处理;</p>
<h2 id="程序的结束"><a href="#程序的结束" class="headerlink" title="程序的结束"></a>程序的结束</h2><p>当收到WM_CLOSE消息的时候，调用DestoryWindow将窗口销毁掉，再调用PostQuitMessage，退出抓取循环。</p>
]]></content>
      <categories>
        <category>客户端</category>
      </categories>
  </entry>
  <entry>
    <title>窗口与消息</title>
    <url>/%E5%AE%A2%E6%88%B7%E7%AB%AF/%E5%AE%A2%E6%88%B7%E7%AB%AF/%E7%AA%97%E5%8F%A3%E4%B8%8E%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<p>1.定义WNDCLASS窗口类</p>
<p>2.通过RegisterClass注册窗口。</p>
<p>3.窗口的创建。通过CreateWindow创建窗口</p>
<p>4.窗口的显示。通过ShowWindow将窗口显示在屏幕上，UpdateWindow使窗口客户区重绘。</p>
<p>5.消息循环。GetMessage函数用于从消息对立中对消息进行检索。TranslateMessage返还给Windows以进行某些键盘消息的转换。DispatchMessage再次返还给Windows,截下来Windows会将这条消息发送给合适的窗口过程来处理。</p>
<p>6.窗口过程。窗口过程WndProc接收消息并进行处理</p>
<p>队列消息和非队列消息</p>
<p>消息可以是队列消息，也可以是非队列消息。队列消息是指那些由Windows放入程序的消息队列中的消息。而非队列消息则是由Windows对窗口过程的直接调用而产生的。</p>
<p>队列消息主要由用户的输入产生，比如按键消息等。</p>
<p>非队列消息包括队列消息以外的其他所有消息。通常由调用特定的Windows函数引起。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// testWin32.cpp : 定义应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"testWin32.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LOADSTRING 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量: </span></span><br><span class="line">HINSTANCE hInst;					<span class="comment">// 当前实例</span></span><br><span class="line">TCHAR szTitle[MAX_LOADSTRING];				<span class="comment">// 标题栏文本</span></span><br><span class="line">TCHAR szWindowClass[MAX_LOADSTRING];			<span class="comment">// 主窗口类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此代码模块中包含的函数的前向声明: </span></span><br><span class="line"><span class="function">ATOM				<span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span>;</span><br><span class="line"><span class="function">BOOL				<span class="title">InitInstance</span><span class="params">(HINSTANCE, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">LRESULT CALLBACK	<span class="title">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"><span class="function">INT_PTR CALLBACK	<span class="title">About</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> APIENTRY _tWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPTSTR    lpCmdLine, _In_ <span class="keyword">int</span>       nCmdShow)</span><br><span class="line">&#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(hPrevInstance);</span><br><span class="line">	UNREFERENCED_PARAMETER(lpCmdLine);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// <span class="doctag">TODO:</span>  在此放置代码。</span></span><br><span class="line">	MSG msg;</span><br><span class="line">	HACCEL hAccelTable;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化全局字符串</span></span><br><span class="line">	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);</span><br><span class="line">	LoadString(hInstance, IDC_TESTWIN32, szWindowClass, MAX_LOADSTRING);</span><br><span class="line">	MyRegisterClass(hInstance);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行应用程序初始化: </span></span><br><span class="line">	<span class="keyword">if</span> (!InitInstance (hInstance, nCmdShow))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_TESTWIN32));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 主消息循环: </span></span><br><span class="line">	<span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))</span><br><span class="line">		&#123;</span><br><span class="line">			TranslateMessage(&amp;msg);</span><br><span class="line">			DispatchMessage(&amp;msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>) msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数:  MyRegisterClass()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的:  注册窗口类。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">ATOM <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WNDCLASSEX wcex;</span><br><span class="line"></span><br><span class="line">	wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line"></span><br><span class="line">	wcex.style			= CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">	wcex.lpfnWndProc	= WndProc;</span><br><span class="line">	wcex.cbClsExtra		= <span class="number">0</span>;</span><br><span class="line">	wcex.cbWndExtra		= <span class="number">0</span>;</span><br><span class="line">	wcex.hInstance		= hInstance;</span><br><span class="line">	wcex.hIcon			= LoadIcon(hInstance, MAKEINTRESOURCE(IDI_TESTWIN32));</span><br><span class="line">	wcex.hCursor		= LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+<span class="number">1</span>);</span><br><span class="line">	wcex.lpszMenuName	= MAKEINTRESOURCE(IDC_TESTWIN32);</span><br><span class="line">	wcex.lpszClassName	= szWindowClass;</span><br><span class="line">	wcex.hIconSm		= LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> RegisterClassEx(&amp;wcex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   函数:  InitInstance(HINSTANCE, int)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   目的:  保存实例句柄并创建主窗口</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   注释: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        在此函数中，我们在全局变量中保存实例句柄并</span></span><br><span class="line"><span class="comment">//        创建和显示主程序窗口。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">BOOL <span class="title">InitInstance</span><span class="params">(HINSTANCE hInstance, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   HWND hWnd;</span><br><span class="line"></span><br><span class="line">   hInst = hInstance; <span class="comment">// 将实例句柄存储在全局变量中</span></span><br><span class="line"></span><br><span class="line">   hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,</span><br><span class="line">      CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!hWnd)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ShowWindow(hWnd, nCmdShow);</span><br><span class="line">   UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数:  WndProc(HWND, UINT, WPARAM, LPARAM)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的:    处理主窗口的消息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  WM_COMMAND	- 处理应用程序菜单</span></span><br><span class="line"><span class="comment">//  WM_PAINT	- 绘制主窗口</span></span><br><span class="line"><span class="comment">//  WM_DESTROY	- 发送退出消息并返回</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> wmId, wmEvent;</span><br><span class="line">	PAINTSTRUCT ps;</span><br><span class="line">	HDC hdc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (message)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">		wmId    = LOWORD(wParam);</span><br><span class="line">		wmEvent = HIWORD(wParam);</span><br><span class="line">		<span class="comment">// 分析菜单选择: </span></span><br><span class="line">		<span class="keyword">switch</span> (wmId)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> IDM_ABOUT:</span><br><span class="line">			DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> IDM_EXIT:</span><br><span class="line">			DestroyWindow(hWnd);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_PAINT:</span><br><span class="line">		hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span>  在此添加任意绘图代码...</span></span><br><span class="line">		EndPaint(hWnd, &amp;ps);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">		PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “关于”框的消息处理程序。</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">About</span><span class="params">(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(lParam);</span><br><span class="line">	<span class="keyword">switch</span> (message)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">		<span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">		<span class="keyword">if</span> (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)</span><br><span class="line">		&#123;</span><br><span class="line">			EndDialog(hDlg, LOWORD(wParam));</span><br><span class="line">			<span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (INT_PTR)FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>客户端</category>
      </categories>
  </entry>
  <entry>
    <title>绘图</title>
    <url>/%E5%AE%A2%E6%88%B7%E7%AB%AF/%E5%AE%A2%E6%88%B7%E7%AB%AF/%E7%BB%98%E5%9B%BE/</url>
    <content><![CDATA[<p>GDI原理</p>
<p>图形显示主要由动态链接库GDI32.DLL中导出的函数处理，这些动态链接库会调用你安装的视频显示器和打印机的设备驱动程序中的一些函数。各种各样的显示设备都可以与PC兼容机连接。因此，GDI的一个主要目的就是支持与设备无关的图形。GDI提供了一种特殊的机制来彻底隔离应用程序和不同输出设备的特性，这样就可以支持与设备无关的图形。<br>GDI函数的调用</p>
<p>GDI包含有几百个函数，可以分成下面几大类</p>
<p>获取和释放设备环境的函数</p>
<p>获取设备环境信息的函数</p>
<p>绘图函数</p>
<p>设置和获取设备环境属性的函数</p>
<p>使用GDI”对象”的函数</p>
<p>GDI的基本图形</p>
<p>线条和曲线</p>
<p>可被填充的封闭区域</p>
<p>位图</p>
<p>文本</p>
<p>其他</p>
<p>映射模式和转换</p>
<p>图元文件</p>
<p>区域</p>
<p>路径</p>
<p>剪裁</p>
<p>调色板</p>
<p>打印</p>
<p>设备环境</p>
<p>如果希望在图形输出设备上绘制图形，必须首先获取设备环境的句柄。</p>
<p>GetDC</p>
<p>有时候，仅需要获取一下关于设备环境的信息，而不需要在上面绘制任何东西。</p>
<p>CreateIC</p>
<p>CreateCimpatibleDC内存设备环境</p>
<p>保存设备环境</p>
<p>通常，当调用GetDC或者BeginPaint函数时，Windows返回一个设备环境，它的所有属性都被设定为默认值。当设备环境调用ReleaseDC或者EndPaint函数时，对属性所做的任何改变都会丢失。如果程序需要使用非默认的设备环境属性，则必须在每次获取一个新的设备环境句柄时初始化这个设备环境。</p>
<p>我们可以通过SaveDC来保存设备环境状态。</p>
]]></content>
      <categories>
        <category>客户端</category>
      </categories>
  </entry>
  <entry>
    <title>Elasticsearch-介绍</title>
    <url>/%E6%90%9C%E7%B4%A2/%E6%90%9C%E7%B4%A2/Elasticsearch-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>Elasticsearch是一个基于Lucene构建的开源、分布式、RESTful的搜索引擎。</p>
<p>索引词<br>文本<br>分析<br>集群<br>节点<br>路由<br>分片<br>主分片<br>副本分片<br>复制<br>索引<br>类型<br>文档</p>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Solr-介绍</title>
    <url>/%E6%90%9C%E7%B4%A2/%E6%90%9C%E7%B4%A2/Solr-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>Solr</tag>
      </tags>
  </entry>
  <entry>
    <title>Solr整合mmseg4j搭建全文搜索引擎</title>
    <url>/%E6%90%9C%E7%B4%A2/%E6%90%9C%E7%B4%A2/Solr%E6%95%B4%E5%90%88mmseg4j%E6%90%AD%E5%BB%BA%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>solr:<a href="http://lucene.apache.org/solr/" target="_blank" rel="noopener">http://lucene.apache.org/solr/</a><br>mmseg4j:<a href="https://code.google.com/p/mmseg4j/" target="_blank" rel="noopener">https://code.google.com/p/mmseg4j/</a><br>oracle<br>tomcat-7.0.39:<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h3><p>Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，即它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。<br>Solr是一个高性能，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。</p>
<h3 id="mmseg4j"><a href="#mmseg4j" class="headerlink" title="mmseg4j"></a>mmseg4j</h3><p>mmseg4j用Chih-Hao Tsai 的MMSeg算法实现的中文分词器，并实现lucene的analyzer和solr的TokenizerFactory以方便在Lucene和Solr中使用。 MMSeg 算法有两种分词方法：Simple和Complex，都是基于正向最大匹配。Complex加了四个规则过虑。官方说：词语的正确识别率达到了 98.41%。mmseg4j已经实现了这两种分词算法。</p>
<h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、名字服务、分布式同步、组服务等。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>将solr-4.5.0.zip解压开后，复制/example/webapps/solr.war复制到tomcat/webapp目录下</p>
<ul>
<li><p>配置solr/home<br>/conf/Catalina/localhost/solr.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">"../solr/solr.war"</span> <span class="attr">debug</span>=<span class="string">"0"</span> <span class="attr">crossContext</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Environment</span> <span class="attr">name</span>=<span class="string">"solr/home"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"../solr"</span> <span class="attr">override</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置数据库信息<br>/solr/collection1/conf/solrconfig.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"../../../../dist/"</span> <span class="attr">regex</span>=<span class="string">"solr-dataimporthandler-.*\.jar"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">requestHandler</span> <span class="attr">name</span>=<span class="string">"/dataimport"</span> <span class="attr">class</span>=<span class="string">"org.apache.solr.handler.dataimport.DataImportHandler"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lst</span> <span class="attr">name</span>=<span class="string">"defaults"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">str</span> <span class="attr">name</span>=<span class="string">"config"</span>&gt;</span>db-data-config.xml<span class="tag">&lt;/<span class="name">str</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">lst</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">requestHandler</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>增加业务数据库相应信息<br>/solr/collection1/conf/db-data-config.xml </p>
<ul>
<li><p>配置分词信息<br>/solr/collection1/conf/schema.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"SUMMARY"</span> <span class="attr">type</span>=<span class="string">"text_cn"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Chinese --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">"text_cn"</span> <span class="attr">class</span>=<span class="string">"solr.TextField"</span> <span class="attr">positionIncrementGap</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">analyzer</span> <span class="attr">type</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">tokenizer</span> <span class="attr">class</span>=<span class="string">"com.chenlb.mmseg4j.solr.MMSegTokenizerFactory"</span> <span class="attr">mode</span>=<span class="string">"complex"</span> <span class="attr">dicPath</span>=<span class="string">"dic"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">analyzer</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">analyzer</span> <span class="attr">type</span>=<span class="string">"query"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tokenizer</span> <span class="attr">class</span>=<span class="string">"com.chenlb.mmseg4j.solr.MMSegTokenizerFactory"</span> <span class="attr">mode</span>=<span class="string">"complex"</span> <span class="attr">dicPath</span>=<span class="string">"dic"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">analyzer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldType</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置solr cloud信息<br>/tomcat/solr/solr.xml </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">solrcloud</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">str</span> <span class="attr">name</span>=<span class="string">"host"</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">str</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">int</span> <span class="attr">name</span>=<span class="string">"hostPort"</span>&gt;</span>5080<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">str</span> <span class="attr">name</span>=<span class="string">"hostContext"</span>&gt;</span>$&#123;hostContext:solr&#125;<span class="tag">&lt;/<span class="name">str</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">int</span> <span class="attr">name</span>=<span class="string">"zkClientTimeout"</span>&gt;</span>$&#123;zkClientTimeout:15000&#125;<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bool</span> <span class="attr">name</span>=<span class="string">"genericCoreNodeNames"</span>&gt;</span>$&#123;genericCoreNodeNames:true&#125;<span class="tag">&lt;/<span class="name">bool</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">solrcloud</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>到/tomcat/bin目录下。编辑catalina.bat文件。在文件最开始增加：<br><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> JAVA_OPTS=-Dbootstrap_confdir=../solr/collection1/conf -Dcollection.configName=clusterconf -DzkRun=<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9001</span> -DzkHost=<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9001</span>,<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9002</span>,<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9003</span> -DnumShards=<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> JAVA_OPTS=-Dbootstrap_confdir=../solr/collection1/conf -Dcollection.configName=clusterconf -DzkRun=<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9002</span> -DzkHost=<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9001</span>,<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9002</span>,<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9003</span> -DnumShards=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> JAVA_OPTS=-Dbootstrap_confdir=../solr/collection1/conf -Dcollection.configName=clusterconf -DzkRun=<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9003</span> -DzkHost=<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9001</span>,<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9002</span>,<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9003</span> -DnumShards=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>配置zookeeper信息<br>/tomcat/solr/zoo.cfg<br>修改zoo.cfg文件，增加如下内容：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=9001</span><br><span class="line"># NOTE: Solr sets this based on zkRun / zkHost params</span><br><span class="line">server.1=127.0.0.1:2888:2889</span><br><span class="line">server.2=127.0.0.1:3888:3889</span><br><span class="line">server.3=127.0.0.1:4888:4889</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>tomcat 5080设为9001<br>tomcat 6080设为9002<br>tomcat 7080设为9003</p>
<ul>
<li>新建myid<br>/tomcat/solr/oo_data目录下，新建文件myid<br>tomcat 5080设内容为1<br>tomcat 6080设内容为2<br>tomcat 7080设内容为3</li>
</ul>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>Solr</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS-内核升级</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CentOS-%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<p>EPEL的全称叫 Extra Packages for Enterprise Linux 。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。装上了 EPEL之后，就相当于添加了一个第三方源。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 查看当前内核版本</span><br><span class="line">uname -r</span><br><span class="line">cat /etc/redhat-release</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装内核包</span><br><span class="line">yum install kernel-lt-4.4.147-1.el7.elrepo.x86_64.rpm</span><br><span class="line">yum install kernel-lt-devel-4.4.147-1.el7.elrepo.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看启动项</span><br><span class="line">awk -F\' '$1=="menuentry " &#123;print i++ " : " $2&#125;' /etc/grub2.cfg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置启动项</span><br><span class="line">grub2-set-default 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 检查启动项是否设置成功</span><br><span class="line">grub2-editenv list</span><br></pre></td></tr></table></figure>
<h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p><a href="https://wiki.centos.org/HowTos/Custom_Kernel" target="_blank" rel="noopener">https://wiki.centos.org/HowTos/Custom_Kernel</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y rpm-build rpmdevtools</span><br><span class="line"></span><br><span class="line">yum groupinstall -y "Development Tools"</span><br><span class="line">yum install -y asciidoc bc m4 net-tools openssl-devel xmlto audit-libs-devel binutils-devel bison elfutils-devel java-1.8.0-openjdk-devel newt-devel numactl-devel perl-ExtUtils-Embed python-devel slang-devel xz-devel zlib-devel ncurses-devel pciutils pciutils-devel</span><br><span class="line"><span class="meta">#</span> 生成目录</span><br><span class="line">rpmdev-setuptree</span><br><span class="line"></span><br><span class="line">cp kernel-lt-4.4.147-1.el7.elrepo.nosrc.rpm rpmbuild/SRPMS/</span><br><span class="line">cp linux-4.4.147.tar.xz rpmbuild/SOURCES/</span><br><span class="line"></span><br><span class="line">rpm -ivh ~/rpmbuild/SRPMS/kernel-lt-4.4.147-1.el7.elrepo.nosrc.rpm</span><br><span class="line"><span class="meta">#</span> 使用rpmbuild就可以一键编出你的内核到 ~/rpmbuild/RPMS/ 目录中了</span><br><span class="line">rpmbuild -bb --with baseonly --with firmware ~/rpmbuild/SPECS/kernel-lt-4.4.spec</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>编译过程会用到大量随机种子，遇到 waiting for lock on `./random_seed'... 提示时请执行</span><br><span class="line">rngd -r /dev/urandom</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-shell</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-Shell/</url>
    <content><![CDATA[<p>shell是一个作为用户与Linux系统间接口的程序，它允许用户向操作系统输入需要执行的命令。</p>
<table>
<thead>
<tr>
<th>名</th>
<th>路径</th>
<th>FreeBSD 5.2.1</th>
<th>Linux 2.4.22</th>
<th>Mac OS X 10.3</th>
<th>Solaris 9</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bourne shell</td>
<td>/bin/sh</td>
<td>.</td>
<td>链接至bash</td>
<td>链接至bash</td>
<td>.</td>
</tr>
<tr>
<td>Bourne-again shell</td>
<td>/bin/bash</td>
<td>可选的</td>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>C shell</td>
<td>/bin/csh</td>
<td>链接至tcsh</td>
<td>链接至tcsh</td>
<td>链接至tcsh</td>
<td>.</td>
</tr>
<tr>
<td>Korn shell</td>
<td>/bin/ksh</td>
<td></td>
<td></td>
<td></td>
<td>.</td>
</tr>
<tr>
<td>TENEX C shell</td>
<td>/bin/tcsh</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
</tbody>
</table>
<h1 id="管道和重定向"><a href="#管道和重定向" class="headerlink" title="管道和重定向"></a>管道和重定向</h1><ul>
<li>重定向输出</li>
<li>重定向输入</li>
<li>管道</li>
</ul>
<h1 id="脚本和语法"><a href="#脚本和语法" class="headerlink" title="脚本和语法"></a>脚本和语法</h1><h2 id="第一行"><a href="#第一行" class="headerlink" title="第一行"></a>第一行</h2><p><code>#!</code>告诉系统同一行上紧跟在它后面的那个参数是用来执行本文件的程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin.sh</span><br></pre></td></tr></table></figure>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>使用变量之前通常并不需要事先为它们做出声明。<br>变量赋值时，等号两边不能有空格。<br>通过在变量名前加一个$符号来访问它的内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=123</span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>当一个shell脚本程序开始执行时，一些变量会根据环境设置中的值进行初始化。这些变量通常用大写字母做名字，以便它们和用户在脚本程序里定义的变量区分开来。</p>
<table>
<thead>
<tr>
<th>环境变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$HOME</td>
<td>当前用户目录</td>
</tr>
<tr>
<td>$PATH</td>
<td>搜索地址</td>
</tr>
<tr>
<td>$PS1</td>
<td>命令提示符</td>
</tr>
<tr>
<td>$PS2</td>
<td>二级提示符</td>
</tr>
<tr>
<td>$IFS</td>
<td>输入域分隔符</td>
</tr>
<tr>
<td>$0</td>
<td>shell脚本的名字</td>
</tr>
<tr>
<td>$#</td>
<td>传递给脚本的参数个数</td>
</tr>
<tr>
<td>$$</td>
<td>shell脚本的进程号</td>
</tr>
</tbody>
</table>
<h4 id="参数变量"><a href="#参数变量" class="headerlink" title="参数变量"></a>参数变量</h4><p>如果脚本程序在调用时带有参数，一些额外的变量就会被创建。</p>
<table>
<thead>
<tr>
<th>环境变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$1,$2,…</td>
<td>脚本程序的参数</td>
</tr>
<tr>
<td>$*</td>
<td>列出所有</td>
</tr>
</tbody>
</table>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><h4 id="test或"><a href="#test或" class="headerlink" title="test或["></a>test或[</h4><p>在一些老版本的UNIX shell中，test命令调用的是一个外部程序。可以使用which test来检查执行的是哪一个test命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if test -f fred.c</span><br><span class="line">then</span><br><span class="line">...</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -f fred.c ]</span><br><span class="line">then</span><br><span class="line">...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>字符串比较</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>string1 = string2</td>
<td></td>
</tr>
<tr>
<td>string1 != string2</td>
<td></td>
</tr>
<tr>
<td>-n strng</td>
<td>如果字符串不为空则结果为真</td>
</tr>
<tr>
<td>-z string</td>
<td>如果字符串为Null(一个空串)则结果为真</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>算术比较</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>expression1 -eq expression2</td>
<td>如果两个表达式相等则结果为真</td>
</tr>
<tr>
<td>expression1 -ne expression2</td>
<td>如果两个表达式不等则结果为真</td>
</tr>
<tr>
<td>expression1 -gt expression2</td>
<td>如果expression1大于expression2则结果为真</td>
</tr>
<tr>
<td>expression1 -ge expression2</td>
<td>如果expression1大于等于expression2则结果为真</td>
</tr>
<tr>
<td>expression1 -lt expression2</td>
<td>如果expression1小于expression2则结果为真</td>
</tr>
<tr>
<td>expression1 -le expression2</td>
<td>如果expression1小于等于expression2则结果为真</td>
</tr>
<tr>
<td>!expression</td>
<td>如果表达式为假则结果为真</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>文件条件测试</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d file</td>
<td>如果是目录</td>
</tr>
<tr>
<td>-e file</td>
<td>如果文件存在</td>
</tr>
<tr>
<td>-f file</td>
<td>如果是普通文件</td>
</tr>
<tr>
<td>-g file</td>
<td>如果set-group-id位被设置</td>
</tr>
<tr>
<td>-r file</td>
<td>如果文件刻度</td>
</tr>
<tr>
<td>-s file</td>
<td>如果文件大小不为0</td>
</tr>
<tr>
<td>-u file</td>
<td>如果set-user-id位被设置</td>
</tr>
<tr>
<td>-w file</td>
<td>如果文件可写</td>
</tr>
<tr>
<td>-x file</td>
<td>如果文件可执行</td>
</tr>
</tbody>
</table>
<h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">  statements</span><br><span class="line">elif</span><br><span class="line">  statements</span><br><span class="line">else</span><br><span class="line">  statements</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for variable in values</span><br><span class="line">do</span><br><span class="line">  statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while condition do</span><br><span class="line">  statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h4 id="until语句"><a href="#until语句" class="headerlink" title="until语句"></a>until语句</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">  statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case variable in</span><br><span class="line">  pattern [|pattern]...) statements;;</span><br><span class="line">  pattern [|pattern]...) statements;;</span><br><span class="line">  ...</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">case "$timeofday" in</span><br><span class="line">  yes) echo "Good Morning";;</span><br><span class="line">  no ) echo "Good Afternonn";;</span><br><span class="line">  ...</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<h4 id="AND和OR语句"><a href="#AND和OR语句" class="headerlink" title="AND和OR语句"></a>AND和OR语句</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">statement1 &amp;&amp; statement2 &amp;&amp; statement3</span><br><span class="line">statement1 || statement2 || statement3</span><br></pre></td></tr></table></figure>
<h4 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">get_confirm &amp;&amp; &#123;</span><br><span class="line">  grep -v "$cdcatnum" $tracks_file &gt; $temp_file</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>必须在调用一个函数之前先对它进行定义。当一个函数被调用时，脚本程序的位置参数($*,$@,$#,$1等)会被替换为函数的参数。当函数执行完毕后，这些参数会恢复为它们先前的值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function_names()&#123;</span><br><span class="line">  statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="break命令"><a href="#break命令" class="headerlink" title="break命令"></a>break命令</h4><p>用于跳出循环</p>
<h4 id="冒号命令"><a href="#冒号命令" class="headerlink" title=":冒号命令"></a>:冒号命令</h4><p>冒号（:）命令是一个空命令。用于简化条件逻辑，相当于true的别名，比true快。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 无限循环</span><br><span class="line">while :</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 条件设置</span><br><span class="line">: $&#123;var:=value&#125;</span><br></pre></td></tr></table></figure>
<h4 id="continue命令"><a href="#continue命令" class="headerlink" title="continue命令"></a>continue命令</h4><p>继续循环</p>
<h4 id="命令-1"><a href="#命令-1" class="headerlink" title=".命令"></a>.命令</h4><p>点(.)命令用于在当前shell中执行命令。点命令实在当前上下文中执行命令，所以可以改变当前脚本中的变量参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. ./shell_script</span><br></pre></td></tr></table></figure>
<h4 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h4><p>输出字符串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -n "string to output"</span><br></pre></td></tr></table></figure>
<h4 id="eval命令"><a href="#eval命令" class="headerlink" title="eval命令"></a>eval命令</h4><p>对参数进行求值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">foo=10</span><br><span class="line">x=foo</span><br><span class="line">eval y='$'$x</span><br><span class="line">echo $y</span><br><span class="line"><span class="meta">#</span>输出10</span><br></pre></td></tr></table></figure>
<h3 id="命令的执行"><a href="#命令的执行" class="headerlink" title="命令的执行"></a>命令的执行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 旧的语法，反引号</span><br><span class="line">`command`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 新的语法</span><br><span class="line"><span class="meta">$</span>(command)</span><br></pre></td></tr></table></figure>
<h3 id="调试脚本程序"><a href="#调试脚本程序" class="headerlink" title="调试脚本程序"></a>调试脚本程序</h3><p>跟踪脚本程序中复杂错误的主要方法是设置各种shell选项。为此，你可以在调用shell时加上命令行选项，或是使用set命令。</p>
<table>
<thead>
<tr>
<th>命令行选项</th>
<th>set选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sh -n</td>
<td>set -n</td>
<td>只检查语法错误，不执行命令</td>
</tr>
<tr>
<td>sh -v</td>
<td>set -v</td>
<td>在执行命令之前回显它们</td>
</tr>
<tr>
<td>sh -x</td>
<td>set -x</td>
<td>在处理命令之后回显它们</td>
</tr>
<tr>
<td>sh -u</td>
<td>set -u</td>
<td>如果使用了未定义的变量，就给出出错消息</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-makefile</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-makefile/</url>
    <content><![CDATA[<h1 id="make命令和makefile文件"><a href="#make命令和makefile文件" class="headerlink" title="make命令和makefile文件"></a>make命令和makefile文件</h1><p>make命令和makefile文件的结合提供了一个在项目管理领域十分强大的工具。</p>
<p>makefile文件由一组依赖关系和规则构成。每个依赖关系由一个目标(即将要创建的文件)和一组该目标所依赖的源文件组成。而规则描述了如何通过这些依赖文件创建目标。一般来说，目标是一个单独的可执行文件。</p>
<p>make命令会读取makefile文件的内容，它先确定目标文件或要创建的文件，然后比较该目标所依赖的源文件的日期和时间以决定采用哪条规则来构造目标。通常在创建最终的目标文件之前，它需要先创建一些中间目标。make命令会根据makefile文件来确定目标文件的创建顺序以及正确的规则调用顺序。</p>
<h2 id="makefile语法"><a href="#makefile语法" class="headerlink" title="makefile语法"></a>makefile语法</h2><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>依赖关系定义了最终应用程序里的每个文件与源文件之间的关系。</p>
<p>规则的写法是：<br>目标的名称: [文件] [文件] …</p>
<p>以下规则表示目标myapp依赖于main.o、2.o和3.o，而main.o依赖于main.h和a.h，等等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">myapp: main.o 2.o 3.o</span><br><span class="line">main.o: main.c a.h</span><br><span class="line">2.o: 2.c a.h b.h</span><br><span class="line">3.o: 3.c b.h c.h</span><br></pre></td></tr></table></figure>
<p>如果想一次创建多个文件，可以利用伪目标all。如果未指定一个all目标，则make命令将只创建它在文件makefile中找到的第一个目标。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">all: myapp myapp.1</span><br></pre></td></tr></table></figure>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>makefile文件的第二部分内容是规则，它们定义了目标的创建方式。规则必须以[tab]开头，不能是空格。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">myapp: main.o 2.o 3.o</span><br><span class="line">  gcc -o myapp main.o 2.o 3.o</span><br></pre></td></tr></table></figure>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>makefile文件中的注释以#号开头。</p>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>通过语句<code>MACRONAME=value</code>在makefile文件中定义宏，引用宏的方法是使用<code>$(MACRONAME)</code>或<code>${MARCRONAME}</code>。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-内存管理</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="简单的内存分配"><a href="#简单的内存分配" class="headerlink" title="简单的内存分配"></a>简单的内存分配</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="页"><a href="#页" class="headerlink" title="页"></a>页</h2><p>内核把物理页作为内存管理的基本单位。尽管处理器的最小可寻址单位通常为字，但是，内存管理单元(MMU，管理内存并把虚拟地址装换为物理地址的硬件)通常以页为单位进行处理。从虚拟内存的角度来看，页就是最小单位。</p>
<p>大多数32位体系结构支持4KB的页，而64位体系结构一般会支持8KB的页。这就意味着，在支持4KB页大小并有1GB物理内存的机器上，物理内存会被划分为262144个页。</p>
<h2 id="区"><a href="#区" class="headerlink" title="区"></a>区</h2><p>由于硬件的限制，内核并不能对所有的页一视同仁。有些页位于内存中特定的物理地址上，所以不能将其用于一些特定的任务。由于存在这种限制，所以内核把页划分为不同的区(zone)。内核使用区对具有相似特性的页进行分组。Linux必须处理如下两种由于硬件存在缺陷而引起的内存寻址问题。</p>
<ol>
<li>一些硬件只能用某些特定的内存地址来执行DMA（直接内存访问）。</li>
<li>一些体系结构的内存的物理寻址范围比虚拟寻址范围大得多。这样，就有一些内存不能永久的映射到内核空间上。</li>
</ol>
<p>Linux主要使用了四种区：</p>
<ul>
<li>ZONE_DMA：这个区包含的页能用来执行DMA操作。</li>
<li>ZONE_DMA32：与ZONE_DMA不同之处在于这些页面只能被32位设备访问。</li>
<li>ZONE_NORMAL：这个区包含的都是能正常映射的页。</li>
<li>ZONE_HIGHMEM：这个区包含“高端内存”，其中的页并不能永久地映射到内核地址空间。</li>
</ul>
<p>区的实际使用和分布是与体系结构相关的。区的划分没有任何物理意义，这只不过是内核为了管理页而采取的一种逻辑上的分组。</p>
<h3 id="x86-32上的区"><a href="#x86-32上的区" class="headerlink" title="x86-32上的区"></a>x86-32上的区</h3><table>
<thead>
<tr>
<th>区</th>
<th>描述</th>
<th>物理内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZONE_DMA</td>
<td>DMA使用的页</td>
<td>&lt;16MB</td>
</tr>
<tr>
<td>ZONE_NORMAL</td>
<td>正常可寻址的页</td>
<td>16-896M</td>
</tr>
<tr>
<td>ZONE_HIGHMEM</td>
<td>动态映射的页</td>
<td>&gt;896M</td>
</tr>
</tbody>
</table>
<h2 id="页的操作"><a href="#页的操作" class="headerlink" title="页的操作"></a>页的操作</h2><p>内核是完全信赖自己的。这点与用户空间不同，如果你有非法操作，内核会开开心心的把自己挂起来，停止运行。</p>
<p>获得页：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">释放页：```free_pages</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-虚拟文件系统</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>虚拟文件系统(VFS)作为内核子系统，为用户空间程序提供了文件和文件系统相关的接口。程序可以利用标准的Unix系统调用不同的文件系统，甚至是不同介质上的文件系统。</p>
<h2 id="文件系统抽象层"><a href="#文件系统抽象层" class="headerlink" title="文件系统抽象层"></a>文件系统抽象层</h2><p>之所以可以使用这种通用接口对所有类型的文件系统进行操作，是因为内核在它的底层文件系统接口上建立了一个抽象层。它定义了所有文件系统都支持的、基本的、概念上的接口和数据结构。</p>
<p>Unix使用了四种和文件系统相关的传统抽象概念：文件、目录项、索引节点和安装点。</p>
<h3 id="安装点-Mount-Point"><a href="#安装点-Mount-Point" class="headerlink" title="安装点(Mount Point)"></a>安装点(Mount Point)</h3><p>在Unix系统中，文件系统被安装在一个特定的安装点上，该安装点在全局层次结构中被称作命名空间，所有的已安装文件系统都作为根文件系统树的枝叶出现在系统中。</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件是简单的面向字节流的有序字节串。</p>
<h3 id="目录项"><a href="#目录项" class="headerlink" title="目录项"></a>目录项</h3><p>文件通过目录组织起来。目录条目统称为目录项。在Unix中，目录属于普通文件，它列出包含在其中的所有文件。</p>
<h3 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h3><p>Unix系统将文件的相关信息和文件本身这两个概念加以区分，例如访问控制权限、大小、拥有者、创建时间等信息。文件相关信息，被存储在一个单独的数据结构中，该结构被称为索引节点。</p>
<h3 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h3><p>超级块是一种包含文件系统信息的数据结构。</p>
<h2 id="VFS对象及其数据结构"><a href="#VFS对象及其数据结构" class="headerlink" title="VFS对象及其数据结构"></a>VFS对象及其数据结构</h2><p>VFS采用的是面向对象的设计思路，使用一组数据结构来代表通用文件对象。</p>
<p>VFS中有四个主要的对象类型</p>
<ol>
<li>超级块对象：代表一个具体的已安装文件系统</li>
<li>索引节点对象：代表一个具体文件</li>
<li>目录项对象：代表一个目录项，是路径的一个组成部分</li>
<li>文件对象：代表由进程打开的文件</li>
</ol>
<p>因为VFS将目录作为一个文件来处理，所以不存在目录对象。</p>
<h3 id="超级块对象"><a href="#超级块对象" class="headerlink" title="超级块对象"></a>超级块对象</h3><p>各种文件系统都必须实现超级块对象，该对象用于存储特定文件系统的信息，通常对应于存放在磁盘特定扇区中的文件系统超级块或文件系统控制块。对于并非基于磁盘的文件系统（如基于内存的文件系统，比如sysfs），它们会在使用现场创建超级块并将其保存到内存中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct super_block &#123;</span><br><span class="line">  unsigned long long s_maxbytes;//文件大小上限</span><br><span class="line">  struct file_system_type s_type;//文件系统类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="索引节点对象"><a href="#索引节点对象" class="headerlink" title="索引节点对象"></a>索引节点对象</h3><p>索引节点对象包含了内核在操作文件或目录时需要的全部信息。对于Unix风格的文件系统来说，这些信息可以从磁盘索引节点直接读入。如果一个文件系统没有索引节点，那么，不管这些相关信息在磁盘上是怎么存放的，文件系统都必须从中提取信息。没有索引节点的文件系统通常将文件的描述信息作为文件的一部分来存放。这些文件系统与Unix风格的文件系统不同，没有将数据与控制信息分开存放。有些现代文件系统使用数据库来存储文件的数据。不管哪种情况、采用哪种方式，索引节点对象必须在内存中创建，以便于文件系统使用。</p>
<p>一个索引节点代表文件系统中（但是索引节点仅当文件被访问时，才在内存中创建）的一个文件，它也可以是设备或管道这样的特殊文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct inode &#123;</span><br><span class="line">  unsigned long i_ino;//节点号</span><br><span class="line">  atomic_t i_count;//引用计数</span><br><span class="line">  loff_t i_size;//以字节为单位的文件大小</span><br><span class="line">  struct address_space *i_mapping;//相关的地址映射</span><br><span class="line">  struct address_space i_data;//设备地址映射</span><br><span class="line">  struct dquot *i_dquot[MAXQUOTAS];//索引节点的磁盘限额</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="目录项对象"><a href="#目录项对象" class="headerlink" title="目录项对象"></a>目录项对象</h3><p>为了方便查找操作，VFS引入了目录项的概念。每个dentry代表路径中的一个特定部分。在路径中(包括普通文件在内)，每一个部分都是目录项对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// &lt;linux/dcache.h&gt;</span><br><span class="line"></span><br><span class="line">struct dentry &#123;</span><br><span class="line">  struct dentry *d_parent;//父目录的目录项对象</span><br><span class="line">  struct qstr d_name;//目录项名称</span><br><span class="line">  struct inode *d_inode;//相关联的索引节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h3><p>文件对象表示进程已打开的文件。文件对象是已打开的文件在内存中的表示。因为多个进程可以同时打开和操作同一个文件，所以同一个文件也可能存在多个对应的文件对象。文件对象仅仅在进程观点上代表已打开文件，它反过来指向目录项对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct file &#123;</span><br><span class="line">  struct path f_path;//包含目录项</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX环境高级编程-UNIX标准化</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-UNIX%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="UNIX体系结构"><a href="#UNIX体系结构" class="headerlink" title="UNIX体系结构"></a>UNIX体系结构</h2><p>UNIX的体系结构大致分为以下几个层次：<br>第一层：内核<br>第二层：系统调用<br>第三层：shell和库函数<br>第四层：应用软件  </p>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>每当运行一个新程序时，所有的shell都为其打开三个文件描述符：标准输入、标准输出、标准出错。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./a.out &lt; in file &gt; outfile</span><br></pre></td></tr></table></figure>
<h2 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h2><p>当UNIX函数出错时，常常返回一个负值。文件errno.h中定义了符号errno以及可以赋予它的各种变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单线程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> errno;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> *__errno_location(<span class="keyword">void</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> errno (*__errno_location())</span></span><br></pre></td></tr></table></figure>
<p>errno的打印函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>UNIX环境高级编程</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX环境高级编程-UNIX标准化</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-UNIX%E6%A0%87%E5%87%86%E5%8C%96/</url>
    <content><![CDATA[<p>20世纪80年代UNIX版本的剧增以及它们之间差别的扩大，导致很多大用户（例如美国政府）呼吁对其进行标准化。所有标准化工作的一个重要部分是对每种实现必须定义的各种限制进行说明。</p>
<h1 id="UNIX标准化"><a href="#UNIX标准化" class="headerlink" title="UNIX标准化"></a>UNIX标准化</h1><h2 id="ISO-C"><a href="#ISO-C" class="headerlink" title="ISO C"></a>ISO C</h2><p>ISO C标准的意图是提供C程序的可移植性，使其能适合于大量不同的操作系统，而不只是UNIX系统。此标准不仅定义了C程序设计语言的语法和语义，还定义了其标准库。因为所有现今的UNIX系统都提供C标准中定义库例程，所以该标准库是很重要的。<br>如同大多数标准一样，在批准标准和修改软件以使其符合标准这两者之间有一段时间上的延迟。随着供应商的编译系统不断眼睛，对ISO C标准最新版本的支持也越来越多。</p>
<blockquote>
<p>gcc对ISO C标准1999版本的当前符合程度的总结可见：<a href="http://www.gnu.org/software/gcc/c99status.html" target="_blank" rel="noopener">http://www.gnu.org/software/gcc/c99status.html</a></p>
</blockquote>
<p>按照该标准定义的各个头文件，可将ISO C库分成24个区。</p>
<table>
<thead>
<tr>
<th>头文件</th>
<th>FreeBSD 5.2.1</th>
<th>Linux 2.4.22</th>
<th>Mac OS X 10.1</th>
<th>Solaris</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>assert.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>验证程序断言</td>
</tr>
<tr>
<td>complex.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td>支持复数算数运算</td>
</tr>
<tr>
<td>ctype.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>字符类型</td>
</tr>
<tr>
<td>errno.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>出错码</td>
</tr>
<tr>
<td>fenv.h</td>
<td></td>
<td>x</td>
<td>x</td>
<td></td>
<td>浮点环境</td>
</tr>
<tr>
<td>float.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>浮点常量</td>
</tr>
<tr>
<td>inttypes.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>整形格式转换</td>
</tr>
<tr>
<td>iso646.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>替代关系操作符宏</td>
</tr>
<tr>
<td>limits.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>实现常量</td>
</tr>
<tr>
<td>locale.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>局部类别</td>
</tr>
<tr>
<td>math.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>数学常量</td>
</tr>
<tr>
<td>setjmp.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>非局部goto</td>
</tr>
<tr>
<td>signal.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>信号</td>
</tr>
<tr>
<td>stdarg.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>可变参数表</td>
</tr>
<tr>
<td>stdbool.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>布尔类型和值</td>
</tr>
<tr>
<td>srddef.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>标准定义</td>
</tr>
<tr>
<td>stdint.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td>整型</td>
</tr>
<tr>
<td>stdio.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>标准I/O库</td>
</tr>
<tr>
<td>stdlib.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>实用程序函数</td>
</tr>
<tr>
<td>string.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>字符串操作</td>
</tr>
<tr>
<td>tgmath.h</td>
<td></td>
<td>x</td>
<td></td>
<td></td>
<td>通用类型数学宏</td>
</tr>
<tr>
<td>time.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>时间和日期</td>
</tr>
<tr>
<td>wchar.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>扩展的多字节和宽字符支持</td>
</tr>
<tr>
<td>wctype.h</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>宽字符分类和映射支持</td>
</tr>
</tbody>
</table>
<blockquote>
<p>ISO C头文件依赖于操作系统所配置的C编译器版本。FreeBSD 5.2.1配置了gcc 3.3.3版，Solaris 9同时配置了gcc 2.95.3版和gcc 3.2版，Mandrate 9.2 (Linux 2.4.22)配置了gcc 3.3.1版，Mac OS X配置了gcc 3.3版。Mac OS X还包括了gcc的较早版本。</p>
</blockquote>
<h2 id="IEEE-POSIX"><a href="#IEEE-POSIX" class="headerlink" title="IEEE POSIX"></a>IEEE POSIX</h2><p>POSIX是一系列由IEEE制定的标准。POSIX指的是可移植的操作系统接口(Portable Operating System)。它原来指的只是IEEE标准1003.1-1988（操作系统接口），后来则扩展成包括很多标记为1003的标准及标准草案，包括shell和实用程序。<br>该标准的目的是提高应用程序在各种UNIX系统环境之间的可以执行。它定义了“依从POSIX的”(POSIX compliant)操作系统必须提供的各种服务。<br>由于1003.1标准定义了一个接口而不是一种实现，所以并不区分系统调用和库函数。标准中的所有例程都称为函数。<br>标准是不断演变的，1003.1标准也不例外。该标准的1988版，即IEEE 1003.1-1988经修改后提交给ISO。最终的文档作为IEEE Std.1003.1-1990正式出版，这也就是国际标准ISO/IEC 9945-1:1990。该标准通常被称为POSIX.1。<br>1003.1的2001版与以前各版本有较大的差别，它组合了1003.1的多次修订、1003.2标准以及Single UNIX Specification第2版的若干部分，最终形成了IEEE标准1003.1-2001，其中包括了下列借个标准。</p>
<ul>
<li><p>ISO/IEC 9945-1(IEEE标准1003.1-1996)，它包括</p>
<ol>
<li>IEEE标准1003.1-1990。</li>
<li>IEEE标准1003.1b-1993(实时扩展)。</li>
<li>IEEE标准1003.1c-1995(pthreads)。</li>
<li>IEEE标准1003.1i-1995(实时技术勘误表)。</li>
</ol>
</li>
<li><p>IEEE P1003.1a标准草案(系统接口修订版)。</p>
</li>
<li>IEEE标准1003.1d-1999(高级实时扩展)。</li>
<li>IEEE标准1003.1j-2000(更高级实时扩展)。</li>
<li>IEEE标准1003.1q-2000(文件跟踪)。</li>
<li>IEEE标准1003.2d-1994(批处理扩展)。</li>
<li>IEEE P1003.2b草案标准(附加的使用程序)。</li>
<li>IEEE标准 1003.1g-2000(协议无关接口)的某些部分。</li>
<li>ISO/IEC 9945-2(IEEE标准1003.2-1993)。</li>
<li><p>Single UNIX Specification第2版本的基本规范，包括</p>
<ol>
<li>系统接口定义，第5发行版。</li>
<li>命令和使用程序，第5发行版。</li>
<li>系统接口和头文件，第5发行版。</li>
</ol>
</li>
<li><p>开放组技术标准，网络服务，5.2发行版。</p>
</li>
<li>ISO/IEC 9899:1999，C编程语言。</li>
</ul>
<p>POSIX.1标准现有Austin Group(<a href="http://www.opengroup.org/austin)的开放工作组维护。为了保证它们与实际需求吻合，仍需经常对这些标准进行更新或再修订。" target="_blank" rel="noopener">http://www.opengroup.org/austin)的开放工作组维护。为了保证它们与实际需求吻合，仍需经常对这些标准进行更新或再修订。</a></p>
<h2 id="Single-UNIX-Specification"><a href="#Single-UNIX-Specification" class="headerlink" title="Single UNIX Specification"></a>Single UNIX Specification</h2><p>Single UNIX Specification（单一UNIX规范）是POSIX.1标准的一个超集，定义了一些附加的接口，这些接口扩展了基本的POSIX.1规范所提供的功能。相应的系统接口全集被称为X/Open系统接口。_XOPEN_UNIX符号常量表示了XSI扩展的几口。<br>XSI还定义了实现必须支持POSIX.1的哪些可选部分才能认为是遵循XSI的。它们包括文件同步、存储映射文件、存储保护及线程接口。只有遵循XSI的实现才能称为UNIX系统。</p>
<h2 id="FIPS"><a href="#FIPS" class="headerlink" title="FIPS"></a>FIPS</h2><p>FIPS的含义是联邦信息处理标准。它有美国政府出版，用于计算机系统的采购。FIPS 151-1(1989年4月)基于IEEE标准1003.1-1988及ANSI C标准草案。<br>POSIX.1 FIPS的影响是：它要求任何希望向美国政府销售POSIX.1兼容的计算机系统的厂商应支持POSIX.1的某些可选功能。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>UNIX环境高级编程</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX环境高级编程-UNIX系统实现</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-UNIX%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>标准只是接口的规范。这些标准由制造商采用，然后转变成具体实现。<br>UNIX的各种版本和变体都起源于在PDP-11系统上运行的UNIX分时系统第6版和第7版。这两个版本是在贝尔实验室意外首先得到广泛应用的UNIX系统。从树上演变出三个分支：</p>
<ol>
<li>AT&amp;T分支，从此到处了系统III和系统V。</li>
<li>加州大学伯克利分校分支，从此到处4.xBSD实现。</li>
<li>由AT&amp;T贝尔实验室的计算科学研究中心开发的UNIX研究版本，从此到处UNIX分时系统第8、第9版以及于1990年发布的最后一版第10版。</li>
</ol>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>UNIX系统实现定义了很多幻数和常量，其中有很多已被硬编码进程序中，或用特定的技术确定。由于大量标准化工作的努力，已有若干种可移植的方法用以确定这些幻数和实现定义的限制。这非常有助于软件的可移植性。<br>以下两种类型的限制是必需的：</p>
<ol>
<li>编译时限制（例如，短整型的最大值是什么?）。</li>
<li>运行时限制（例如，文件名可以有多少个字符?）。</li>
</ol>
<p>编译时限制可在头文件中定义，程序在编译时可以包含这些头文件。但是，运行时限制则要求进程调用一个函数以获得此种限制值。<br>另外，某些限制在一个给定的实现中可能是固定的，而在另一个实现上则可能是变化的。这类限制的一个例子是文件名的最大字符数。文件名的最大长度依赖于该文件处于何种文件系统中，例如，根文件系统中的文件名长度限制可能是14个字符，而在另一个文件系统中文件名长度限制可能是255个字符，这是运行时限制的一个例子。<br>为了解决这类问题，提供了一下三种限制：</p>
<ol>
<li>编译时限制</li>
<li>不与文件或目录相关联的运行时限制(sysconf函数)</li>
<li>与文件或目录相关联的运行时显示(pathconf和fpathconf函数)</li>
</ol>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>就整体而言，这些不同的标准之间配合的相当好。但是我们也很关注它们之间的差别，特别是ISO C标准和POSIX.1之间的差别。<br>有一个相同的术语，即每秒钟滴答数，但ISO C和POSIX.1的定义却不懂，在Solaris中看到，其中clock返回微秒数(因此，CLOCK_PER_SEC是一百万)，而sysconf为每秒钟的滴答数返回的值是100。<br>另一个可能产生冲突的领域是：在ISO C标准定义函数时，可能没有考虑到POSIX.1的某些要求。在POSIX环境下，有些函数可能要求有一个与C环境下不同的实现，因为POSIX环境中多个进程，而ISO C环境则很少考虑主机操作系统。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>UNIX环境高级编程</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX环境高级编程-文件IO</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/</url>
    <content><![CDATA[<p>UNIX系统中的大多数文件IO只需要用到5个函数：open,read,write,lseek,close。<br>这5个函数通常被称为不带缓冲的IO(unbuffered io)，每个read和write都调用内核中的一个系统调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode*/</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> filedes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buf, size_n nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="IO效率"><a href="#IO效率" class="headerlink" title="IO效率"></a>IO效率</h2>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>UNIX环境高级编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows核心编程-用户模式下的线程同步</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h2 id="关键段"><a href="#关键段" class="headerlink" title="关键段"></a>关键段</h2><p>关键段(critical section)是一小段代码，它在执行之前需要独占对一些共享资源的访问权。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRITICAL_SECTION g_cs;</span><br><span class="line"><span class="keyword">int</span> g_nSum = <span class="number">0</span>;</span><br><span class="line">InitializeCriticalSection(&amp;g_cs);</span><br><span class="line"></span><br><span class="line">EnterCriticalSection(&amp;g_cs);</span><br><span class="line">g_nSum++;</span><br><span class="line">LeaveCriticalSection(&amp;g_cs);</span><br><span class="line"></span><br><span class="line">DeleteCriticalSection(&amp;g_cs);</span><br></pre></td></tr></table></figure></p>
<h2 id="Slim读-写锁"><a href="#Slim读-写锁" class="headerlink" title="Slim读/写锁"></a>Slim读/写锁</h2><p>SRWLock的目的和关键段相同，对同一资源进行保护，不让其他线程访问它。但是，与关键段不同的是，SRWLock允许我们区分那些（读取者线程）和（写入者线程）。让所有的读取者线程在同一时刻访问共享资源应该是可行的，这是因为仅仅读取资源的值并不存在破坏数据的风险。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SRWLOCK g_srwLock;</span><br><span class="line">InitializeSRWLock(&amp;g_srwLock);</span><br><span class="line"><span class="comment">//写入者线程调用</span></span><br><span class="line">AcquireSRWLockExclusive(&amp;g_srwLock);</span><br><span class="line">ReleaseSRWLockExclusive(&amp;g_srwLock);</span><br><span class="line"><span class="comment">//读取者线程调用</span></span><br><span class="line">AcquireSRWLockShared(&amp;g_srwLock);</span><br><span class="line">ReleaseSRWLockShared(&amp;g_srwLock);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>性能之巅-1基本概念</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85-1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="系统性能"><a href="#系统性能" class="headerlink" title="系统性能"></a>系统性能</h2><p>系统性能是对整个系统的研究，包括了所有的硬件组件和整个软件栈。对于分布式系统来说，这意味着多台服务器和多个应用。</p>
<h2 id="人员"><a href="#人员" class="headerlink" title="人员"></a>人员</h2><p>系统性能是一项需要多类人员参与的事务，其中包括系统管理员、技术支持人员、应用开发者、数据库管理员和网络管理员。对于他们的大多数来说，性能是一项兼职的事情，他们可能会有发掘性能的倾向，但仅限于本职工作范围内（网络团队检查网络、数据库团队检查数据库，如此等等）。然而，对于某些性能问题，要找到根本原因还需要这些团队一起协同工作才行。</p>
<p>一些公司会雇佣性能工程师，其主要任务就是维护系统性能。他们与多个团队协同工作，对环境做全局性的研究。</p>
<h2 id="事情"><a href="#事情" class="headerlink" title="事情"></a>事情</h2><h2 id="视角"><a href="#视角" class="headerlink" title="视角"></a>视角</h2><p>性能可以从不同的角度来审视。负载分析和资源分析。系统管理员作为系统资源的负责人，通常采用资源分析角度。应用程序开发人员，对最终实现的负载性能负责，通常采用负载缝隙角度。</p>
<h2 id="延时"><a href="#延时" class="headerlink" title="延时"></a>延时</h2><p>性能分析必须量化问题的重要程度。延时非常适合用来量化性能。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>延时</th>
<th>相对时间比例</th>
</tr>
</thead>
<tbody>
<tr>
<td>1个CPU周期</td>
<td>0.3ns</td>
<td>1s</td>
</tr>
<tr>
<td>L1缓存访问</td>
<td>0.9ns</td>
<td>3s</td>
</tr>
<tr>
<td>L2缓存访问</td>
<td>2.8ns</td>
<td>9s</td>
</tr>
<tr>
<td>L3缓存访问</td>
<td>12.9ns</td>
<td>43s</td>
</tr>
<tr>
<td>主存访问（从CPU访问DRAM）</td>
<td>120ns</td>
<td>6分</td>
</tr>
<tr>
<td>固态硬盘I/O（闪存）</td>
<td>50-150us</td>
<td>2-6天</td>
</tr>
<tr>
<td>旋转磁盘I/O</td>
<td>1-10ms</td>
<td>1-12月</td>
</tr>
<tr>
<td>互联网：从旧金山到纽约</td>
<td>40ms</td>
<td>4年</td>
</tr>
<tr>
<td>互联网：从旧金山到英国</td>
<td>81ms</td>
<td>8年</td>
</tr>
<tr>
<td>互联网：从旧金山到澳大利亚</td>
<td>183ms</td>
<td>19年</td>
</tr>
<tr>
<td>TCP包重传</td>
<td>1-3s</td>
<td>105-317年</td>
</tr>
<tr>
<td>OS虚拟化系统重启</td>
<td>4s</td>
<td>423年</td>
</tr>
<tr>
<td>SCSI命令超时</td>
<td>30s</td>
<td>3千年</td>
</tr>
<tr>
<td>硬件虚拟化系统重启</td>
<td>40s</td>
<td>4千年</td>
</tr>
<tr>
<td>物理系统重启</td>
<td>5m</td>
<td>32千年</td>
</tr>
</tbody>
</table>
<h2 id="动态跟踪"><a href="#动态跟踪" class="headerlink" title="动态跟踪"></a>动态跟踪</h2><p>动态跟踪技术把所有的软件变得可以监控，而且能用在真实的生产环境中。这项技术利用内存中的CPU指令并在这些指令之上动态构建监测数据。</p>
<h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><ul>
<li>IOPS：每秒的I/O操作数。</li>
<li>吞吐量：每秒数据量或操作量。</li>
<li>使用率：给定的时间区间内资源的繁忙程度，有些组件达到100%后，还是能够正常工作。</li>
<li>饱和度：随着工作量增加而对资源的请求超过资源所能处理的程度，100%后就无法处理，开始排队。</li>
<li>命中率</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>街灯讹方法</td>
<td>观测分析</td>
</tr>
<tr>
<td>随机变动讹方法</td>
<td>实验分析</td>
</tr>
<tr>
<td>责怪他人讹方法</td>
<td>假设分析</td>
</tr>
<tr>
<td>Ad Hoc核对清单法</td>
<td>观测与实验分析</td>
</tr>
<tr>
<td>问题陈述法</td>
<td>信息收集</td>
</tr>
<tr>
<td>科学法</td>
<td>观测分析</td>
</tr>
<tr>
<td>诊断循环</td>
<td>生命周期分析</td>
</tr>
<tr>
<td>工具法</td>
<td>观测分析</td>
</tr>
<tr>
<td>USE方法</td>
<td>观测分析</td>
</tr>
<tr>
<td>工作负载特征归纳</td>
<td>观测分析，容量规划</td>
</tr>
<tr>
<td>向下挖掘分析</td>
<td>观测分析</td>
</tr>
<tr>
<td>延时分析</td>
<td>观测分析</td>
</tr>
<tr>
<td>R方法</td>
<td>观测分析</td>
</tr>
<tr>
<td>事件跟踪</td>
<td>观测分析</td>
</tr>
<tr>
<td>基础线统计</td>
<td>观测分析，容量规划</td>
</tr>
<tr>
<td>性能监控</td>
<td>观测分析，容量规划</td>
</tr>
<tr>
<td>排队论</td>
<td>统计分析，容量规划</td>
</tr>
<tr>
<td>静态性能调整</td>
<td>观测分析，容量规划</td>
</tr>
<tr>
<td>缓存调优</td>
<td>观测分析，调优</td>
</tr>
<tr>
<td>微基准测试</td>
<td>实验分析</td>
</tr>
<tr>
<td>容量规划</td>
<td>容量规划，调优</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>性能之巅</tag>
      </tags>
  </entry>
  <entry>
    <title>性能之巅-2文件系统</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85-2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>性能之巅</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统概念-内存管理</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>内存是现代计算机运行的中心。内存由很大一组字或字节组成，每个字或字节都有它们自己的地址。CPU根据程序计数器（PC）的值从内存中提取指令，这些指令可能会引起进一步对特定内存地址的读取和写入。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统概念-线程</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5-%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>线程是CPU调度的基本单元，它由线程ID、程序计数器、寄存器集合和栈组成。<br>操作系统提供的线程支持包括用户层的用户线程和内核层的内核线程。<br>用户线程和内核线程之间存在着三种常见的关系：  </p>
<ol>
<li><p>多对一模型<br>多个用户线程映射到一个内核线程。<br>缺点是如果一个相称阻塞了系统调用，那么整个进程都会被阻塞。  </p>
</li>
<li><p>一对一模型<br>一个用户线程映射到一个内核线程。<br>缺点是创建内核线程的开销会影响到应用程序的性能。  </p>
</li>
<li><p>多对多模型<br>线程库提供了创建和管理线程的API。<br>目前主要的三种线程库是：1.POSIX Phread;2.Win32;3.Java。<br>由于Java是运行在虚拟机上的，通常都是调用虚拟机的宿主操作系统上的线程库。  </p>
</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统概念-进程</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5-%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>进程是执行中的程序。当启动可执行文件，并被启动被装载到内存中，一个程序就成为了进程。<br>进程包括代码段，堆栈段（用于保存临时数据，局部变量等），数据段（用于保存全局变量），堆（运行时动态分配的内存），当前进程的活动状态。  </p>
<ol>
<li><p>进程控制块<br>进程在操作系统中用数据控制块这样的一个数据结构表示，包含了进程的相关信息。在CPU调度进程进行切换的时候，会将信息保存到进程控制块中。进程状态、程序计数器(要执行的下个指令)、CPU寄存器、CPU调度信息(进程优先级，调度队列的指针和其他调度参数)、内存管理信息、记账信息(CPU时间，时间界限等)、I/O状态信息。  </p>
</li>
<li><p>调度程序<br>对于当前CPU执行的进程的选择是由相应的调度程序来执行的。  </p>
</li>
<li><p>进程间通信<br>进程间通信有两种基本模式：1.共享内存；2.消息传递。<br>共享内存：创建一块共享的内存区域，其他进程通过这个共享区域来交换信息。<br>消息传递的方式有多种<br>直接/间接通信：直接根据标示通信/通过端口来通信。<br>同步/异步通信<br>队列缓冲，在消息传递中，不管是直接或者间接通信，进程的消息都保存在临时队列中，临时队列的缓冲有三种方法：1.零容量；2.有限容量；3.无限容量。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>深入分析GCC</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90GCC/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>深入分析GCC</tag>
      </tags>
  </entry>
  <entry>
    <title>边干边学LINUX内核指导-编译</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%B9%E5%B9%B2%E8%BE%B9%E5%AD%A6LINUX%E5%86%85%E6%A0%B8%E6%8C%87%E5%AF%BC-%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol>
<li>操作系统Fedora Core 5</li>
</ol>
<h2 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h2>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>边干边学LINUX内核指导</tag>
      </tags>
  </entry>
  <entry>
    <title>二项随机变量</title>
    <url>/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6/%E4%BA%8C%E9%A1%B9%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><br>设进行n次独立重复实验，每次试验成功的概率为p，失败的概率为1-p。若以X表示n次试验中成功的次数，那么X称为参数为(n, p)的二项随机变量。<br>参数为(n, p)二项随机变量的分布列为<br>$$p(i)=(_i^n)p^i(1-p)^{n-i} $$</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>数学符号</title>
    <url>/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<ol>
<li>基本符号：＋ － × ÷（／） </li>
<li>分数号：／ </li>
<li>正负号：± </li>
<li>相似全等：∽ ≌ </li>
<li>因为所以：∵ ∴ </li>
<li>判断类：＝ ≠ ＜ ≮（不小于） ＞ ≯（不大于） </li>
<li>集合类：∈（属于） ∪（并集） ∩（交集） </li>
<li>求和符号：∑ </li>
<li>n次方符号：¹（一次方） ²（平方） ³（立方） ⁴（4次方） ⁿ（n次方） </li>
<li>下角标:₁ ₂ ₃ ₄ (如:A₁B₂C₃D₄) </li>
<li>或与非的”非”:￢ </li>
<li>导数符号(备注符号):′ 〃 </li>
<li>度:° ℃ </li>
<li>任意:∀ </li>
<li>推出号:⇒ </li>
<li>等价号:⇔ </li>
<li>包含被包含:⊆ ⊇ ⊂ ⊃ </li>
<li>导数:∫ ∬ </li>
<li>箭头类:↗ ↙ ↖ ↘ ↑ ↓ ↔ ↕ ↑ ↓ → ← </li>
<li>绝对值:｜ </li>
<li>弧:⌒ </li>
<li>圆:⊙</li>
<li>平均数-，ba拔</li>
<li>存在:∃</li>
</ol>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>高等代数-研究对象</title>
    <url>/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%A0%94%E7%A9%B6%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h2><p>一个非空集合V如果规定了加法运算和数量乘法(数域与V中元素的乘法)运算，并且满足类似于几何空间中的加法的4条运算法则和数量乘法的4条运算法则，那么称V是数域上的一个线性空间。</p>
<h2 id="线性映射"><a href="#线性映射" class="headerlink" title="线性映射"></a>线性映射</h2><p>线性映射是研究数量关系中最基本的“线性关系”（即均匀变化的关系）以及空间形式中最基本的变换（例如，几何空间中的旋转、镜面反射、投影等）。</p>
<h2 id="具有度量的线性空间以及度量有关的线性映射"><a href="#具有度量的线性空间以及度量有关的线性映射" class="headerlink" title="具有度量的线性空间以及度量有关的线性映射"></a>具有度量的线性空间以及度量有关的线性映射</h2><p>几何空间中有长度、角度、正交(即垂直)、距离的等度量概念，它们可以统一用内积来刻画。由此受到启发，在线性空间中只要定义了内积，就可以引进度量的概念。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>InfluxDB-基本概念</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/InfluxDB-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>InfluxDB是一个无模式数据库，可以随时添加新的measurement,tags和fields。</p>
<ol>
<li><p>database<br>数据库可以包含多个用户、保留策略、连续查询和时间序列数据的逻辑容器。</p>
</li>
<li><p>measurement<br>measurement是包含timestamp, field和tag的容器。相当于数据库中的表。</p>
</li>
<li><p>timestamp<br>时间戳</p>
</li>
<li><p>field<br>字段由字段键(field key)和字段值(field value)构成。字段是InfluxDB中必须存在的，没有字段就不能保存数据。相当于表中的列名和列的值。<br>但是，字段不能进行索引，进行字段匹配的时候会导致全表扫描。如果需要作为查询条件，需要设置为tags。</p>
</li>
<li><p>tags<br>标签由标签键(tag key)和标签值(tag value)构成。不同于字段，标签是可选，同时是被索引的。标签适合存储查询用的元数据。</p>
</li>
<li><p>point<br>同一个序列(serie)和时间戳(timestamp)中的字段集(field set)。</p>
</li>
<li><p>retention policy<br>保留策略描述了InfluxDB保存数据的持续时间，这些数据的副本数量以及分片组覆盖的时间范围。</p>
</li>
<li><p>series<br>InfluxDB数据结构中的数据集合，共享measurement、retention policy、measurement和tag set</p>
</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>root权限</p>
<h2 id="网络端口"><a href="#网络端口" class="headerlink" title="网络端口"></a>网络端口</h2><p>8086:用于客户端和服务器之间的通信</p>
<p>8088:用于备份和还原</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">influxd config</span><br><span class="line">influxd --config /etc/influxdb/influxdb.conf</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>InfluxDB-数据库管理</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/InfluxDB-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="database"><a href="#database" class="headerlink" title="database"></a>database</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE &lt;database_name&gt; [WITH [DURATION &lt;duration&gt;] [REPLICATION &lt;n&gt;] [SHARD DURATION &lt;duration&gt;] [NAME &lt;retention-policy-name&gt;]]</span><br><span class="line"></span><br><span class="line">DROP DATABASE &lt;database_name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="series"><a href="#series" class="headerlink" title="series"></a>series</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP SERIES FROM &lt;measurement_name[,measurement_name]&gt; WHERE &lt;tag_key&gt;=&apos;&lt;tag_value&gt;&apos;</span><br></pre></td></tr></table></figure>
<h2 id="measurement"><a href="#measurement" class="headerlink" title="measurement"></a>measurement</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP MEASUREMENT &lt;measurement_name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="retention-policy"><a href="#retention-policy" class="headerlink" title="retention policy"></a>retention policy</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE RETENTION POLICY &lt;retention_policy_name&gt; ON &lt;database_name&gt; DURATION &lt;duration&gt; REPLICATION &lt;n&gt; [SHARD DURATION &lt;duration&gt;] [DEFAULT]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>MongoDB-介绍</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>开始时只有很少的数据，一台服务器就可以了。然后就得建立备份，以便应对大量的读取和不时的宕机。用不了多长时间，就得加一个缓存层，调整所有的查询，投入更多的硬件。<br>最后，你会发现自己需要将数据切分到多个集群中，并重新构建大量的应用逻辑以适应这种切分。之后不久，你又会发现被自己数月前设计的数据库结构限制住了。<br>这是应为集群中大量的数据需要更改模式，会花费很长时间，也需要DBA投入相当多的宝贵时间。在代码中处理要简单一些，但也需要小型开发团队数月的努力。<br>为了应对现在Web应用的数据膨胀，开源社区像以往一样提供了太多的“好方法”。从内存中的键值型存储到可以使用SQL的MySQL/InnoDB变种等复杂方法。<br>MongoDB在功能和复杂性之间取得了很好的平衡，并且将原先十分复杂的任务大大简化。也就是说，它具备支撑今天主流Web应用的关键功能：索引、复制、分片、丰富的查询语法，特别灵活的数据模型。与此同时还不牺牲速度。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>mongodb:<a href="https://www.mongodb.org/" target="_blank" rel="noopener">https://www.mongodb.org/</a></p>
<h2 id="配置-amp-启动"><a href="#配置-amp-启动" class="headerlink" title="配置&amp;启动"></a>配置&amp;启动</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">   destination: file</span><br><span class="line">   path: "D:/MongoDB/log/mongodb.log"</span><br><span class="line">   logAppend: true</span><br><span class="line">net:</span><br><span class="line">   bindIp: 127.0.0.1</span><br><span class="line">   port: 27017</span><br><span class="line">storage:</span><br><span class="line">   dbPath: "D:/MongoDB/data"</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/mongod.exe --config mongodb.conf</span><br></pre></td></tr></table></figure>
<h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><p>最基本的方法就是向MongoDB服务器发送一个SIGINT或者SIGTERM信号。如果服务器是作为前台进程运行在终端的，就直接按Ctrl-C。否则，就用kill这种命令发出型号。如果mongod的PID是10014，就可以kill -2 10014 (SIGINT)或者kill 10014 (SIGTERM)。</p>
<blockquote>
<p>千万不要向运行中的MongoDB发送SIGKIILL(kill -9)。这样会导致数据库直接关闭，上面讲到的步骤都将被忽略，这会使数据文件损毁。要是真的发生了不幸，一定要在启动备份之前修复数据库。<br>当mongod收到时，会稳妥退出。也就是说会等到当前运行的操作或者文件预分配完成，关闭所有打开的连接，将缓存的数据刷新的磁盘，最后停止。</p>
</blockquote>
<p>另一种稳妥的方式就是使用shutdown命令，{“shutdown”:1}。这是管理命令，要在admin数据库下使用。</p>
<h2 id="GridFS"><a href="#GridFS" class="headerlink" title="GridFS"></a>GridFS</h2><p>GridFS是一种在MongoDB中存储大二进制文件的机制。使用GridFS存文件有如下几个原因。</p>
<ul>
<li>利用GridFS可以简化需求。要是已经用了MongoDB, GridFS就可以不需要使用独立文件存储架构。</li>
<li>GridFS会直接利用已建立的复制或分片机制，所以对于文件存储来说故障恢复和扩展很容易。</li>
<li>GridFS可以避免用于存储用户上传内容的文件系统出现的某些问题。例如，GridFS在同一目录下放置大量的文件是没有任何问题的。</li>
<li>GridFS不产生磁盘碎片，因为MongoDB分配数据文件空间时以2GB为一块。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Oracle-RAC体系结构</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle-RAC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>系统故障转移共有3种一般方法。按照可用性的升高顺序，依次为无故障转移、冷故障转移和热故障转移。  </p>
<p>Oracle RAC在本质上是为多台服务器提供对同一数据副本进行一致性访问的能力。  </p>
<p>尽管Oracle RAC能够很好地进行伸缩，但水平可伸缩性也有一个上限。一般来说，应用程序的可伸缩性取决于这个应用程序在单个实例上的工作状况。如果这个应用程序执行的SQL语言是高效的，使用的资源数量合理，那么通常可以认为它能很好地伸缩，相反，它还会使问题放大，使情况变得更糟。这一点也适用于Oracle RAC或任意其他可伸缩性解决方案。因此，在使用集群进行扩展之前，需要确保进行了应用程序级别的调优以清除瓶颈。  </p>
<p>Oracle RAC允许多个实例访问同一个数据库，从Oracle 11g R2开始，Oracle集群件栈被称为”Oracle Grid Infrastructure”。  </p>
<p>Oracle RAC的主要组件包括：  </p>
<p>共享磁盘系统，Oracle集群件，集群互联，Oracle内核组件  </p>
<p>可伸缩共享存储是Oracle RAC环境中的一个关键组件。传统上，使用主机本地的SCSI或SATA接口将存储设备连接到各个服务器。今天，更灵活的存储设备已经很流行了，可以使用常规的以太网，通过存储区域网络(SAN)或网络连接存储(NAS)来访问。这些新的存储选项使多台服务器能够通过一个网络访问同一组磁盘，简化了在任意分布式环境中提供存储的过程。  </p>
<p>在共享存储中，数据库文件应当能提供所有节点平等地并发访问。一般的文件系统不允许在一个以上的系统中安装磁盘。依赖于单一节点，而且这个节点可能成为单一故障点(SPOF),所以它是对高可用性(HA)体系结构的另一个威胁。  </p>
<p>主要有3种方法可以提供RAC所需要的共享存储：</p>
<ol>
<li>原始卷</li>
<li>集群文件系统</li>
<li>自动存储管理(ASM)：ASM是为Oracle数据库文件准备的一种可移植、专用、优化的集群文件系统。</li>
</ol>
<p>“Oracle集群件”是可移植软件。它由几个后台进程组成，这些进程执行不同的功能，用以推动集群操作。  </p>
<p>Oracle集群件由集群就绪服务(CRS)使用”Oracle集群注册表”和表决磁盘进行管理，OCR记录和维持集群及节点的成员资格信息，表决器在通信故障时充当一个仲裁者。在集群运行期间，来自所有节点的一致性心跳信息都会发送给表决磁盘。  </p>
<p>构成Oracle集群件的后台进程和服务是CRSd(CRS守护进程)、OCSSd(Oracle集群同步服务守护进程)、OPROCd(进程监控器守护进程，在11g R2版本中废弃)、EVMd(事件卷管理器守护进程)和ONS(Oracle通知服务)。  </p>
<p>Oracle 10g引入了一个名为”集群VIP”的新功能，集群VIP就是一个集群虚拟IP地址，外部世界将使用这个IP地址连接到数据库。这个IP地址应当不同于集群中的IP地址集。  </p>
<p>应用程序VIP是一种用于管理网络IP地址的集群资源。如果一个应用程序依赖于应用程序VIP(AVIP)，只要有一个节点停机，应用程序VIP就会故障转移到仍在正常运行的节点，并在这个节点上重新启动此应用程序进程。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>PostgreSQL-锁</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL-%E9%94%81/</url>
    <content><![CDATA[<p>在PostgreSQL数据库中有两类锁：表级锁和行级锁。当要查询、插入、更新、删除表中的数据时，首先是要获得表上的锁，然后再获得行上的锁。</p>
<h2 id="表级锁模式"><a href="#表级锁模式" class="headerlink" title="表级锁模式"></a>表级锁模式</h2><table>
<thead>
<tr>
<th>锁模式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACCESS SHARE</td>
<td>多版本控制功能，修改数据下也允许读数据</td>
</tr>
<tr>
<td>ROW SHARE</td>
<td>意向共享锁</td>
</tr>
<tr>
<td>ROW EXCLUSIVE</td>
<td>意向独占锁</td>
</tr>
<tr>
<td>SHARE UPDATE EXCLUSIVE</td>
<td>在意向独占锁的基础上，自身会排斥</td>
</tr>
<tr>
<td>SHARE</td>
<td>读锁，表的内容不能再变化</td>
</tr>
<tr>
<td>SHARE ROW EXCLUSIVE</td>
<td>SHARE+ROW EXCLUSIVE</td>
</tr>
<tr>
<td>EXCLUSIVE</td>
<td>写锁，其他进程不能写也不能读</td>
</tr>
<tr>
<td>ACCESS EXCLUSIVE</td>
<td>多版本控制功能，也不允许访问数据</td>
</tr>
</tbody>
</table>
<p>PostgreSQL中有8种表锁，最普通的是共享锁“SHARE”和排他锁“EXCLUSIVE”，因为多版本的原因，修改一条语句的同时，允许了读数据，为了处理这种情况，又增加了两种锁“ACCESS SHARE”和“ACESS EXCUSIVE”，锁中的关键字“ACCESS”是与多版本相关的。此外，为了处理表锁和行锁之间的关系，有了“意向锁”的概念，这时又加了两种锁，即“意向共享锁”和“意向排他锁”，由于意向锁之间不会产生冲突，而且意向排它锁相互之间也不会产生冲突，于是又需要更严格一些的锁，这样就产生了“SHARE UPDATE EXCLUSIVE” 和 “SHARE ROW EXCLUSIVE”</p>
<h2 id="行级锁模式"><a href="#行级锁模式" class="headerlink" title="行级锁模式"></a>行级锁模式</h2><p>只有共享锁和独占锁。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>PostgreSQL能够自动侦测到死锁，然后会退出其中一个事务，从而允许其他事务完成。不过，到底哪个事务会被退出是很难估计的。</p>
<h2 id="表级锁命令"><a href="#表级锁命令" class="headerlink" title="表级锁命令"></a>表级锁命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LOCK TABLE name [NOWAIT]</span><br></pre></td></tr></table></figure>
<p>在PostgreSQL中，事务自己的锁是从不冲突的。</p>
<h2 id="行级锁命令"><a href="#行级锁命令" class="headerlink" title="行级锁命令"></a>行级锁命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SELECT FOR [UPDATE | SHARE] [OF table_name] [NOWAIT]</span><br></pre></td></tr></table></figure>
<p>多表关联时，可以使用<code>of table</code>指定表名。</p>
<h2 id="锁的查看"><a href="#锁的查看" class="headerlink" title="锁的查看"></a>锁的查看</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM pg_locks</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>RRDTool-基本概念</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/RRDTool-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>rrdtool是一个固定大小的，基于文件的时序数据库。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>PDP(Primary Data Point)：主数据点<br>CDP（Consolidation Data Point）：聚合数据点<br>解析度（resolution）：指的就是时间跨度<br>DS（Data Source）：数据源，每一个数据源都可以对其做单独的聚合</p>
<h2 id="rrdtool-create"><a href="#rrdtool-create" class="headerlink" title="rrdtool create"></a>rrdtool create</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rrdtool create filename [--start|-b start time] [--step|-s step]</span><br><span class="line">                        [DS:ds-name:DST:dst arguments]  </span><br><span class="line">                        [RRA:CF:cf arguments]</span><br><span class="line">filename:    默认为.rrd为后辍的文件，名称自己随意取；</span><br><span class="line">--start:     指定RRDtool的第一个记录的起始时间，--start选项的值必须是timestamp的格式。</span><br><span class="line">             如查你想自己设定时间可以使用--start $(date -d '1 days ago' +%s) ,当然还有一种方法就是使用rrdtool fetch filename.rrd AVERAGE；</span><br><span class="line">--step:      就是RRDtool“期望”每隔多长时间就收到一个值；</span><br><span class="line">DS：         用于定义数据源；</span><br><span class="line">ds-name:     指定数据源的名字，随意取。必须是1到19个字符，且是a-z、A-Z、或者0-9；</span><br><span class="line">DST：        定义源数据类型，源数据类型分以下几种：</span><br><span class="line">                    1、COUNTER      数据必须是递增的，保存的是相对于前面的一个值</span><br><span class="line">                    2、GAUGE        保存原值</span><br><span class="line">                    3、DERIVE       可增可减</span><br><span class="line">                    4、ABSOLUTE     相对于初始值的数值</span><br><span class="line">                    5、COMPUTE      对于COMPUTE数据源来说格式是DS:ds-name:COMPUTE:rpn-expression</span><br><span class="line">dst argument:数据源参数，形式是:    heartbeat:min:max</span><br><span class="line">                 heartbeat：  定义在我们这个时间跨度之内，再过多长时间过期，过期的标记为unknown；</span><br><span class="line">                 min：        接收的最小值，一般我们可以都设为0；</span><br><span class="line">                 max：        接收的最大值，如果不是很清楚其最大值可以设置为U；</span><br><span class="line">RRA：        用于指定数据如何存放；</span><br><span class="line">CF:          指定数据合并方法，合并方法分以下几种：</span><br><span class="line">                    1、AVERAGE    平均值</span><br><span class="line">                    2、MAX        最大值</span><br><span class="line">                    3、MIN        最小值</span><br><span class="line">                    4、LAST       当前值</span><br><span class="line">cf arguments:数据保存，它的形式是：    xff:steps:rows</span><br><span class="line">              xff:        定义PDP中出现unknown的百分比高于设置的这个比例以后CDP也被标记为unknown；</span><br><span class="line">              steps：     聚合函数对多少个pdp做聚合生成cdp；</span><br><span class="line">              rows：      保存多少个聚合的cdp结果；</span><br></pre></td></tr></table></figure>
<h2 id="rrdtool-update"><a href="#rrdtool-update" class="headerlink" title="rrdtool update"></a>rrdtool update</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rrdtool &#123;update | updatev&#125; filename [--template | -t ds-name[:ds-name]...]</span><br><span class="line">[--] N | timestamp:value[:value...]</span><br><span class="line">-t ：    改变接收数据的次序</span><br><span class="line">            例如，我们定义的rrdtool create test.rrd DS：ds1 DS：ds2，默认情况下我们想这个数据库里面输入值得话是：rrdtool update test.rrd N:30（DS1值）:40（DS2值），</span><br><span class="line">            使用rrdtool update test.rrd -t  ds2:ds1 40:30 把循序给颠倒; </span><br><span class="line">N:       表示当前时间</span><br></pre></td></tr></table></figure>
<h2 id="rrdtool-info"><a href="#rrdtool-info" class="headerlink" title="rrdtool info"></a>rrdtool info</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rrdtool info filename    用于查看filename的数据结构（filename就是rrdtool create生成的数据库文件）；</span><br></pre></td></tr></table></figure>
<h2 id="rrdtool-fetch"><a href="#rrdtool-fetch" class="headerlink" title="rrdtool fetch"></a>rrdtool fetch</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rrdtool fetch filename [-r #] [CF]</span><br><span class="line">-r #:    指定#个PDP为一个数据；</span><br><span class="line">CF:      指定使用哪种合并函数，与rrdtool create中cf argument一样；</span><br></pre></td></tr></table></figure>
<h2 id="rrdtool-graph"><a href="#rrdtool-graph" class="headerlink" title="rrdtool graph"></a>rrdtool graph</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rrdtool graph|graphv filename [option ...][datadefinition ...][data calculation ...][variabledefinition ...][graph element ...][print element ...]</span><br><span class="line">[-s|--start time][-e|--end time][-S|--step seconds]</span><br><span class="line">[-t|--title string][-V |--Vertical-label string ]</span><br><span class="line">[-w|--width pixels][-h|--height pixels][-j|--only-graph][-D|--full-size-mode]</span><br><span class="line"> </span><br><span class="line">OPTION：</span><br><span class="line">Graph Limits</span><br><span class="line">[-u | --upper-limit value]:     显示数值的最大上限的值</span><br><span class="line">[-l | --lower-limit value]：    显示的最低下限的值</span><br><span class="line">[-r | --rigid ]:                不会自动缩放，以定义的最大值和最小值来显示</span><br><span class="line">[-A | --alt-autoscale ]:        启用自动缩放，但是最大的和最小的是不能超过上面的范围</span><br><span class="line">[-J | --alt-autoscale-min]:     只自动缩放最小值</span><br><span class="line">[-M | --alt-autoscale-max ]:    只自动缩放最大值</span><br><span class="line">[-N | --no-gridfit]:            不显示网格线</span><br><span class="line"> </span><br><span class="line">定义横轴：</span><br><span class="line">X-Axis</span><br><span class="line">    [-x|--x-grid GTM:GST(定义基准网格线，前面是单位，后面是数值)</span><br><span class="line">    :MTM:MST（定义主网格线，前面的是单位，后面的是数值）</span><br><span class="line">    :LTM:LST（定义横轴底面的标签的单位和距离，前面是单位，后面是距离）</span><br><span class="line">    :LPR:LFM（显示标签的显示格式）]</span><br><span class="line">    [-x | --x-grid none ]</span><br><span class="line"> </span><br><span class="line">Y-Axis</span><br><span class="line">    [-y|--y-grid grid(刻度是什么) step(多长显示一个刻度)</span><br><span class="line">    :label（卷标显示是什么） factor（卷标多长时间显示一个）]:</span><br><span class="line">    [-y|--y-grid none ]</span><br><span class="line">    [-Y| --alt-y-grid]</span><br><span class="line"> </span><br><span class="line">图片全局定义</span><br><span class="line">   [-c| --color COLORTAGE #rrggbb[aa]]</span><br><span class="line">       BACK          #背景色</span><br><span class="line">       CANVAS        #画布颜色</span><br><span class="line">       SHADEA        #左边和上边的颜色</span><br><span class="line">       SHADEB        #右边和下边的颜色</span><br><span class="line">       GRID，MGRID   #主网格线的颜色</span><br><span class="line">       FONT          #字体颜色</span><br><span class="line">       AXIS          #坐标轴的颜色</span><br><span class="line">       FRAME         #边框颜色</span><br><span class="line">       ARROW         #箭头的颜色</span><br><span class="line">    -n | --font FONTTAG（字体名字）：size（大小）：[font（路径）]   #指定字体的参数</span><br><span class="line">    [-R|--font-render-mode(字体格式) &#123;normal（正常）,light（发亮）,mono（粗体）&#125;]</span><br><span class="line">    [-a|--imgformat PNG|SVG|EPS|PDF]   #图像输出格式</span><br><span class="line">    [-W| --watermark string ]          #加水印</span><br><span class="line"> </span><br><span class="line">数据与变量</span><br><span class="line">定义数据获取方式：</span><br><span class="line">  DEF：vname（变量名，只能包含数字和字母，最长不能超过255字符）=rrdfile（rrd文件路径）:ds-name（数据源名称）:CF（聚合函数）[:step=step][:start=time][:end=time]</span><br><span class="line">  CDEF:vname=RPN expression</span><br><span class="line">  VDEF:vname=RPN expression</span><br><span class="line"> </span><br><span class="line">图片</span><br><span class="line">线状图：</span><br><span class="line">   LINE[width（线条的粗细程度，1最细的3是最粗的）</span><br><span class="line">   :value（上面定义的变量名称）[#color（线条颜色）]</span><br><span class="line">   [:[legend（底面的标签名称）][:STACK]]</span><br><span class="line">   [:dashes[=on_s[,off_s[,on_s,off_s]...]</span><br><span class="line">   [:dash-offset=offset]</span><br><span class="line">面积图：</span><br><span class="line">    AREA：value[#color][:[legend][:STACK]]</span><br></pre></td></tr></table></figure>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\rrdtool.exe create test.rrd --step 60 DS:test:GAUGE:8:0:U RRA:LAST:0.5:1:3600</span><br><span class="line">.\rrdtool.exe graph test.png --step 60 -t test DEF:vtest=test.rrd:test:LAST LINE1:vtest#FF0000:testline1 --font &quot;DEFAULT:13:fonts\times.ttf&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>AvlTree</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/AvlTree/</url>
    <content><![CDATA[<p>AVL树使带有平衡条件的二叉查找树。</p>
<p>一棵AVL树是其每个节点的左子树和右子树的高度最多差1的二叉查找树(空树的高度定为-1)。</p>
<p>当进行插入操作时，我们需要更新通向根节点路径上那些节点的平衡信息，而插入操作的隐含着困难的原因在于，插入一个节点可能破坏AVL树的特性。如果发生这种情况，那么就要考虑这一步插入完成之前恢复平衡的性质。事实上，这总可以通过对树进行简单的修正来做到，我们称其为旋转。</p>
<p>第一种情况是插入发生在“外边”的情况（即左子树-左儿子或右子树-右儿子），该情况通过对树的一次单旋转而完成调整。</p>
<p>第二种情况是插入发生在”内部”的情况（即左子树-右儿子或右子树-左儿子），该情况通过稍微复杂些的双旋转来处理。</p>
<ol>
<li><p>单旋转  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private AvlNode&lt;AnyType&gt; rotateWithLeftChild(AvlNode&lt;AnyType&gt; k2)</span><br><span class="line">&#123;</span><br><span class="line">    AvlNode&lt;AnyType&gt; k1 = k2.left;</span><br><span class="line">    k2.left = k1.right;</span><br><span class="line">    k1.right = k2;</span><br><span class="line">    k2.height = Math.max(height(k2.left), height(k2.right)) + 1;</span><br><span class="line">    k1.height = Math.max(height(k1.left), k2.height) + 1;</span><br><span class="line">    return k1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双旋转  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private AvlNode&lt;AnyType&gt; doubleWithLeftChild(AvlNode&lt;AnyType&gt; k3)</span><br><span class="line">	&#123;</span><br><span class="line">		k3.left = rotateWithLeftChild(k3.left);</span><br><span class="line">		return rotateWithLeftChild(k3);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>B-Tree</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/B-Tree/</url>
    <content><![CDATA[<p>如果数据装不下内存，那么就意味着要把数据结构放到磁盘上。此时磁盘的访问代价太高了，我们想要把磁盘访问次数减小到一个非常小的常数。</p>
<p>我们可以以与建立二叉查找树大致相同的方式建立M叉查找树。</p>
<p>阶位M的B树是一棵具有下列特性的树：</p>
<p>1.数据项存储在树叶上。</p>
<p>2.非叶节点存储直到M - 1个关键字以指示搜索的方向；关键字i代表子树i + 1中的最小的关键字。</p>
<p>3.树的根或者是一片树叶，或者其儿子数在2和M之间。</p>
<p>4.除根外，所有非树叶节点的儿子数在[M / 2]和M之间。</p>
<p>5.所有的树叶都在相同的深度上并有[L / 2]和L之间个数据项。</p>
<h2 id="插入情况"><a href="#插入情况" class="headerlink" title="插入情况"></a>插入情况</h2><p>如果该树叶还没有被装满则插入项。</p>
<p>如果该树叶装满了则分裂该树叶，当父节点也满了，则沿树向上分裂，直到树根。如果分裂树根，那么我们就得到两个树根，我们可以建立一个新的根，这个根以分裂得到的两个树根作为它的两个儿子。这就是为什么准许树根可以最少有两个儿子的特权。</p>
<h2 id="删除情况"><a href="#删除情况" class="headerlink" title="删除情况"></a>删除情况</h2><p>如果被删元所在的树叶的数据项数已经是最小值，那么删除后它的项树就低于最小值了。我们可以通过在邻节点本身没有达到最小值时领养一个邻项来矫正这种状况。如果相邻节点已经达到最小值，那么可以与该相邻节点联合以形成一片满叶。可是，这意味着其父节点失去一个儿子。如果失去儿子的结果又引起父节点的儿子数低于最小值，那么我们使用相同的策略继续进行。这个过程可以一直上行到根。根不可能只有一个儿子。如果这个领养过程的结果使得根只剩下一个儿子，那么删除该根并让它的这个儿子作为树的新根。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>BinarySearchTree</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/BinarySearchTree/</url>
    <content><![CDATA[<p>使二叉树成为二叉查找树的性质是，对于树中的每个节点x,它的左子树中所有项值小于x中的项，而它的右子树中所有项的值大于x中的项。</p>
<p>二叉查找树中的删除<br>如果节点是一片树叶，那么它可以被立即删除。如果节点有一个儿子，则该节点可以在其父节点调整自己的链以绕过该节点后被删除。</p>
<p>复杂的情况是处理具有两个儿子的节点。一般的删除策略是用其右子树的最小的数据代替该节点的数据并递归地删除那个节点。因为右子树中的最小的节点不可能有左儿子，所以第二次remove要容易。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>List</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/List/</url>
    <content><![CDATA[<h2 id="MyArrayList"><a href="#MyArrayList" class="headerlink" title="MyArrayList"></a>MyArrayList</h2><p>MyArrayList将保持基础数组，数组的容量，以及存储在MyArrayList中的当前项数。</p>
<p>MyArrayList将提供一种机制以改变基础数组的容量。通过获得一个新数组，将老数组拷贝到新数组中来改变数组的容量，允许虚拟机回收老数组。</p>
<p>MyArrayList将提供get和set的实现。</p>
<p>MyArrayList将提供基本的例程，如size、isEmpty和clear。还提供remove，以及两种不同版本的add。如果数组的大小和容量相同，那么这两个add例程将增加容量。</p>
<p>MyArrayList将提供一个实现Iterator接口的类。这个类将存储迭代序列中的下一项的下表，并提供next、hasNext和remove等方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyArrayList&lt;AnyType&gt; implements Iterable&lt;AnyType&gt;</span><br><span class="line">&#123;</span><br><span class="line">	private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line">	</span><br><span class="line">	private int theSize;</span><br><span class="line">	private AnyType[] theItems;</span><br><span class="line">	</span><br><span class="line">	public int size()</span><br><span class="line">	&#123;</span><br><span class="line">		return theSize;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean isEmpty()</span><br><span class="line">	&#123;</span><br><span class="line">		return size() == 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//调整容量符合大小</span><br><span class="line">	public void trimToSize()</span><br><span class="line">	&#123;</span><br><span class="line">		ensureCapacity(size());</span><br><span class="line">	&#125;</span><br><span class="line">	//确保数组大小足够大</span><br><span class="line">	public void ensureCapacity(int newCapacity)</span><br><span class="line">	&#123;</span><br><span class="line">		if(newCapacity &lt; theSize)</span><br><span class="line">			return;</span><br><span class="line">		</span><br><span class="line">		//复制数据到新数组中</span><br><span class="line">		AnyType[] old = theItems;</span><br><span class="line">		theItems = (AnyType[]) new Object[newCapacity];</span><br><span class="line">		for(int i = 0; i &lt;size(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			theItems[i] = old[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public AnyType get(int index)</span><br><span class="line">	&#123;</span><br><span class="line">		if(index &lt; 0 || index &gt;= size())</span><br><span class="line">		&#123;</span><br><span class="line">			throw new ArrayIndexOutOfBoundsException();</span><br><span class="line">		&#125;</span><br><span class="line">		return theItems[index];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public AnyType set(int index, AnyType newVal)</span><br><span class="line">	&#123;</span><br><span class="line">		if(index &lt; 0 || index &gt;= size())</span><br><span class="line">		&#123;</span><br><span class="line">			throw new ArrayIndexOutOfBoundsException();</span><br><span class="line">		&#125;</span><br><span class="line">		AnyType old = theItems[index];</span><br><span class="line">		theItems[index] = newVal;</span><br><span class="line">		return old;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void add(int index, AnyType x)</span><br><span class="line">	&#123;</span><br><span class="line">		//数组不够大，则扩大数组</span><br><span class="line">		if(theItems.length == size())</span><br><span class="line">		&#123;</span><br><span class="line">			ensureCapacity(size()*2 + 1);</span><br><span class="line">		&#125;</span><br><span class="line">		//从index开始，元素往后移动一位</span><br><span class="line">		for(int i = theSize; i &gt; index; i--)</span><br><span class="line">		&#123;</span><br><span class="line">			theItems[i] = theItems[i - 1];</span><br><span class="line">		&#125;</span><br><span class="line">		//index位置赋值x</span><br><span class="line">		theItems[index] = x;</span><br><span class="line">		theSize++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public AanyType remove(int index)</span><br><span class="line">	&#123;</span><br><span class="line">		AnyType removedItem = theItems[index];</span><br><span class="line">		for(int i = index; i &lt; size(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			//从index位置开始，所有元素都往前移动一位</span><br><span class="line">			theItems[i] = theItems[i + 1];</span><br><span class="line">		&#125;</span><br><span class="line">		theSize--;</span><br><span class="line">		return removedItem;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public java.util.Iterator&lt;AnyType&gt; iterator()</span><br><span class="line">	&#123;</span><br><span class="line">		return new ArrayListIterator&lt;AnyType&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private static class ArrayListIterator&lt;AnyType&gt; implements java.util.Iterator&lt;AnyType&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		private int current = 0;</span><br><span class="line">		</span><br><span class="line">		public boolean hasNext()</span><br><span class="line">		&#123;</span><br><span class="line">			return current &lt; MyArrayList.this.size();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public AnyType next()</span><br><span class="line">		&#123;</span><br><span class="line">			return MyArrayList.this.theItems[current++];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public void remove()</span><br><span class="line">		&#123;</span><br><span class="line">			//防止迭代器的remove与MyArrayList的remove冲突</span><br><span class="line">			MyArrayList.this.remove(--current);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="MyLinkedList"><a href="#MyLinkedList" class="headerlink" title="MyLinkedList"></a>MyLinkedList</h2><p>MyLinkedList类，包含两端的链、表的大小以及一些方法。</p>
<p>Node类，一个节点包含数据以及到前一个节点的链和到下一个节点的链，还有一些适当的构造方法。</p>
<p>LinkedListIterator类，该类抽象了位置的概念，并实现接口Iterator。它提供了方法next、hasNext和remove的实现</p>
<p>使用额外的头节点和尾节点的优点在于，通过排除许多特殊情形极大地简化了编码。例如，如果我不使用头节点，那么删除第1个节点就变成了一种特殊的情况，因为在删除期间我们必须重新调整链表到第1个节点的链。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyLinkedList&lt;AnyType&gt; implements Iterable&lt;AnyType&gt;</span><br><span class="line">&#123;</span><br><span class="line">	private static class Node&lt;AnyType&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		public AnyType data;</span><br><span class="line">		public Node&lt;AnyType&gt; prev;</span><br><span class="line">		public Node&lt;AnyType&gt; next;</span><br><span class="line">		public Node(AnyType d, Node&lt;AnyType&gt; p, Node&lt;AnyType&gt; n)</span><br><span class="line">		&#123;</span><br><span class="line">			data = d;</span><br><span class="line">			prev = p;</span><br><span class="line">			next = n;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private int theSize;</span><br><span class="line">	//自从链表构造以来对链表所做的改变次数</span><br><span class="line">	//与迭代器里的modCount进行比较</span><br><span class="line">	private int modCount = 0;</span><br><span class="line">	//头节点</span><br><span class="line">	private Node&lt;AnyType&gt; beginMarker;</span><br><span class="line">	//尾节点</span><br><span class="line">	private Node&lt;AnyType&gt; endMarker;</span><br><span class="line">	</span><br><span class="line">	public boolean add(AnyType x)</span><br><span class="line">	&#123;</span><br><span class="line">		add(size(), x);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void add(int index, AnyType x)</span><br><span class="line">	&#123;</span><br><span class="line">		//根据index获取节点，在该节点前添加x</span><br><span class="line">		addBefore(getNode(index, x));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void addBefore(Node&lt;AnyType&gt; p, AnyTyoe x)</span><br><span class="line">	&#123;</span><br><span class="line">		//在p和p之前插入新节点</span><br><span class="line">		Node&lt;AnyType&gt; newNode = new Node&lt;AnyType&gt;(x, p.prev, p);</span><br><span class="line">		//更新新节点前一节点的后一节点链接</span><br><span class="line">		newNode.prev.next = newNode;</span><br><span class="line">		//更新p的前一节点链接</span><br><span class="line">		p.prev = newNode;</span><br><span class="line">		theSize++;</span><br><span class="line">		modCount++;</span><br><span class="line">	&#125;</span><br><span class="line">	public AnyType get(int index)</span><br><span class="line">	&#123;</span><br><span class="line">		return getNode(index).data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public AnyType set(int index, AnyType newVal)</span><br><span class="line">	&#123;</span><br><span class="line">		Node&lt;AnyType&gt; p = getNode(index);</span><br><span class="line">		AnyType oldVal = p.data;</span><br><span class="line">		p.data = newVal;</span><br><span class="line">		return oldVal;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public AnyType remove(int index)</span><br><span class="line">	&#123;</span><br><span class="line">		return remove(getNode(index));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private AnyType remove(Node&lt;AnyType&gt; p)</span><br><span class="line">	&#123;</span><br><span class="line">		p.next.prev = p.prev;</span><br><span class="line">		p.prev.next = p.next;</span><br><span class="line">		theSize--;</span><br><span class="line">		modCount++;</span><br><span class="line">		</span><br><span class="line">		return p.data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private Node&lt;AnyType&gt; getNode(int index)</span><br><span class="line">	&#123;</span><br><span class="line">		Node&lt;AnyType&gt; p;</span><br><span class="line">		</span><br><span class="line">		if(index &lt; 0 || index &gt; size())</span><br><span class="line">		&#123;</span><br><span class="line">			throw new IndexOutOfBoundsException();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		//从头节点或者尾节点开始查找</span><br><span class="line">		if(index &lt; size() / 2)</span><br><span class="line">		&#123;</span><br><span class="line">			p = beginMarker.next;</span><br><span class="line">			for(int i = 0; i &lt; index; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				p = p.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			p = endMarker;</span><br><span class="line">			for(int i = size(); i &gt; index; i--)</span><br><span class="line">			&#123;</span><br><span class="line">				p = p.prev;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return p;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private class LinkedListIterator implements java.util.Iterator&lt;AnyType&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		private Node&lt;AnyType&gt; current = beginMarker.next;</span><br><span class="line">		private int expectedModCount = modCount;</span><br><span class="line">		private boolean okToRemove = false;</span><br><span class="line">		</span><br><span class="line">		public boolean hasNext()</span><br><span class="line">		&#123;</span><br><span class="line">			return current != endMarker;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public AnyType next()</span><br><span class="line">		&#123;</span><br><span class="line">			if(modCount != expectedModCount)</span><br><span class="line">			&#123;</span><br><span class="line">				throw new java.util.ConcurrentModificationException();</span><br><span class="line">			&#125;</span><br><span class="line">			if(!hasNext())</span><br><span class="line">			&#123;</span><br><span class="line">				throw new java.util.NoSuchElementException();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			AnyType nextItem = current.data;</span><br><span class="line">			current = current.next;</span><br><span class="line">			okToRemove = true;</span><br><span class="line">			return nextItem;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public void remove()</span><br><span class="line">		&#123;</span><br><span class="line">			if(modCount != expectedModCount)</span><br><span class="line">			&#123;</span><br><span class="line">				throw new java.util.ConcurrentModificationException();</span><br><span class="line">			&#125;</span><br><span class="line">			if(!okToRemove)</span><br><span class="line">			&#123;</span><br><span class="line">				throw new IllegalStateException();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			MyLinkedList.this.remove(current.prev);</span><br><span class="line">			okToRemove = false;</span><br><span class="line">			expectedModCount++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Queue</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Queue/</url>
    <content><![CDATA[<p>队列也是表，使用队列时插入在一端进行而删除在另一端进行。</p>
<h2 id="队列的数组实现"><a href="#队列的数组实现" class="headerlink" title="队列的数组实现"></a>队列的数组实现</h2><p>对于每一个队列数据结构，我们保留一个数组theArray以及位置front和back，它们代表队列的两端。我们还要记录实际存在于队列中的元素的个数currentSize。</p>
<p>为使一个元素x入队(即执行enqueue)，我们让currentSize和back增1，然后置theArray[back] = x。若使元素dequeue(出队)，我们置返回值为theArray[front]，且currentSize减1，然后使front增1。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>SplayTree</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/SplayTree/</url>
    <content><![CDATA[<p>伸展树保证从空树开始连续M次对树的操作最多花费O(M log N)时间。一棵伸展树每次操作的摊还代价是O(log N)。</p>
<p>伸展树的基本 想法是，当一个节点被访问后，它就要经过一些列AVL树的旋转被推到根上。因为在许多应用中当一个节点被访问时，它很可能不久再被访问。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Stack</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Stack/</url>
    <content><![CDATA[<p>栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈的顶。</p>
<p>栈又叫做LIFO(后进先出表)，由于栈是一个表，因此任何实现表的方法都能实现栈。</p>
<h2 id="栈的链表实现"><a href="#栈的链表实现" class="headerlink" title="栈的链表实现"></a>栈的链表实现</h2><p>栈的第一种实现方法是使用单链表。通过在表的顶端插入来实现push，通过删除表顶端元素实现pop。top操作只是考察表顶端元素并返回它的值。</p>
<h2 id="栈的数组实现"><a href="#栈的数组实现" class="headerlink" title="栈的数组实现"></a>栈的数组实现</h2><p>与每个栈相关联的操作是theArray和topOfStack，对于空栈它是-1。为将某个元素x推入栈，我们使topOfStack增1然后置theArray[topOfStack] = x。为了弹出栈元素，我们置返回值为theArray[topOfStack]然后使topOfStack减1。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>优先队列(堆)</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97(%E5%A0%86)/</url>
    <content><![CDATA[<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>在多用户环境中，操作系统调度程序必须决定在若干进程中运行哪个进程。一般说来，短的作业要尽可能快地结束，这一点很重要，因此在已经运行的作业当中这些短作业应该拥有优先权。此外，有些作业虽不短小但很重要，也应该拥有优先权。<br>这种特殊的应用似乎需要一类特殊的队列，我们称之为<strong>优先队列</strong>。<br>优先队列至少允许下列两种操作，</p>
<ol>
<li>插入</li>
<li>删除最小者：找出、返回并删除优先队列中最小的元素。</li>
</ol>
<h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p>二叉堆的使用对于优先队列的实现相当普遍。在这里，我们把二叉堆只叫做堆。<br>像二叉查找树一样，堆也有两个性质，即结构性和堆序性。对堆的操作可能破坏者两个性质中的一个，因此，堆的操作必须到堆的所有性质都被满足时才能终止。</p>
<ol>
<li>结构性质<br>堆是一棵被完全填满的二叉树，有可能的例外是在底层，底层上的元素从左到右填入。这样的树称为完全二叉树。<br>一个重要的观察发现，因为完全二叉树这么有规律，所以它可以用一个数组表示而不需要使用链。<br>对于数组中任意位置i上的元素，其左儿子在位置2i上，右儿子在左儿子后的单元(2i + 1)中，它的父亲则在位置[i  / 2]上，</li>
<li>堆序性<br>让操作快速执行的性质是堆序性质。由于我们想要快速找出最小元，因此最小元应该在根上。如果我们考虑任意子树也应该是一个堆，那么任意节点就应该小于它所有后裔。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>排序算法除了要考虑时间，空间复杂度以外，还需要考虑到稳定性。</p>
<p>稳定的排序算法表示在排序前后，相等的两个值的前后位置保持不变。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>首先从第一个元素开始扫描整个序列，并将序列的最小元素和第一个元素交换，然后从第二个元素开始扫描，将n-1个元素中的最小序列与第二个元素交换，执行到n-1个元素后，这个序列就排序好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 升序</span></span><br><span class="line"><span class="comment"> * 遍历数组找出最小的与第一个交换，第二小的与第二个交换...</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> originalArr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] asc(<span class="keyword">int</span>[] originalArr)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; originalArr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; originalArr.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(originalArr[min] &gt; originalArr[j])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> tmp = originalArr[min];</span><br><span class="line">        originalArr[min] = originalArr[i];</span><br><span class="line">        originalArr[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> originalArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>比较相邻的两个元素，如果第一个元素大于第二个元素就交换位置，第一遍最大值将会交换到最后一个位置，第二次循环将n-1个元素中的最大值交换到最后第二个位置，重复操作n-1遍后，这个序列就排序好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 升序</span></span><br><span class="line"><span class="comment"> * 比较相邻元素，将大元素沉下去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] asc(<span class="keyword">int</span>[] originalArray) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; originalArray.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; originalArray.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(originalArray[i] &gt; originalArray[j])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = originalArray[i];</span><br><span class="line">                originalArray[i] = originalArray[j];</span><br><span class="line">                originalArray[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> originalArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>散列</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97/</url>
    <content><![CDATA[<p>散列是一种用于以常数平均时间执行插入、删除和查找的技术。但是，那些需要元素间任何排序信息的树操作将不会得到有效的支持。因此，诸如findMin、findMax以及以线性时间将排过序的整个表进行打印的操作都是散列所不支持的。</p>
<p>每个关键字被映射到从0到TableSize - 1这个范围中的某个数，并且被放到适当的单元中。这个映射就叫做散列函数。因为单元的数目是有限的，而关键字实际上是用不完的。因此，我们寻找一个散列函数，该函数要在单元之间均匀地分配关键字。剩下的问题就是要选择一个函数，决定到两个关键字散列到同一个值的时候(冲突)应该做什么以及如何确定散列表的大小。<br>散列函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(String key, <span class="keyword">int</span> tableSize)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> hashVal = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			hashVal = <span class="number">37</span> * hashVal + key.charAt(i);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		hashVal %= tableSize;</span><br><span class="line">		<span class="keyword">if</span>(hashVal &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			hashVal += tableSize;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> hashVal;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>解决冲突<br>分离链接法</p>
<p>将散列到同一个值的所有元素保留到一个表中。<br>开放定址法</p>
<p>另有一种不使用链表解决冲突的方法是尝试另外一些单元，直到找出空的单元为止。更常见的是，单元h0(x),h1(x),h2(x),…相继被试选，其中hi(x) = (hash(x) + f(i)) mod tableSize，且f(0) = 0。函数f是冲突解决方法。因为所有数据都要置入表内，所以这种解决方案所需要的表要比分离链接散列的表大。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>极大似然估计</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/</url>
    <content><![CDATA[<p>考察下面的ARMA模型:<br>$$Y_t = c + \phi_1 Y_{t-1} +  \phi_2 Y_{t-2} + … + \phi_p Y_{t-p} +\epsilon_t + \theta_1\epsilon_{t-1} + \theta_2\epsilon_{t-2} + … + \theta_q\epsilon_{t-q}$$<br>如何运用Y的观测值来估计$(c,\phi_1,…,\phi_p,\theta_1,…,\theta_q,\sigma^2)$的值。</p>
<p>估计所根据的基本原则是最大似然估计。<br>从理论上讲，求最大似然估计包括两个步骤。</p>
<ol>
<li>计算似然函数式</li>
<li>求使得这个函数值最大的$\theta$值</li>
</ol>
<p>令$\theta \equiv (c,\phi_1,…,\phi_p,\theta_1,…,\theta_q,\sigma^2)^,$表示总体参数向量。假定我们观测到一个样本量为T的样本$(y_1,y_2,…,y_T)$，计算概率密度<br>$$f_{Y_T,Y_{T-1},…,Y_1}(y_T,y_{T-1},…,y_1;\theta)$$<br>它可近似地看作已观测到的这个具体样本的概率。$\theta$的最大似然估计是使这个具体样本最可能观测到的值，即使式最大的$\theta$值。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>混合自回归移动平均过程</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%B7%B7%E5%90%88%E8%87%AA%E5%9B%9E%E5%BD%92%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="差分方程"><a href="#差分方程" class="headerlink" title="差分方程"></a>差分方程</h2><p>所谓差分方程即将变量$y_t$与它的滞后期联系起来的表达式。<br>研究变量在第t期的值记为$y_t$。假定给出的动态方程将变量y第t期的值与另外的变量$w_t$以及y的前一期联系起来:<br>$$y_t=\phi y_{t-1}+w_t$$<br>上述称为一阶差分方程是因为仅仅只有变量的一阶滞后($y_{t-1}$)出现在方程中。</p>
<h2 id="移动平均"><a href="#移动平均" class="headerlink" title="移动平均"></a>移动平均</h2><p>“移动平均”的含义源于$Y_t$是最近两期的$\epsilon$的加权平均。<br>令{$\epsilon_t$}是一个白噪声序列。<br>$$Y_t = \mu + \epsilon_t + \theta\epsilon_{t-1}$$<br>其中$\mu$和$\theta$可以是任意的常数。这个时间序列称为一阶移动平均过程，记为MA(1).</p>
<h2 id="自回归过程"><a href="#自回归过程" class="headerlink" title="自回归过程"></a>自回归过程</h2><h3 id="一阶自回归过程"><a href="#一阶自回归过程" class="headerlink" title="一阶自回归过程"></a>一阶自回归过程</h3><p>一个一阶自回归，记作AR(1)满足下面的差分方程<br>$$Y_t = c + \phi Y_{t-1} + \epsilon_t$$<br>{$\epsilon_t$}是一个白噪声序列。</p>
<p>####p阶自回归过程<br>一个p阶自回归，记作AR(p)满足下式<br>$$Y_t = c + \phi_1 Y_{t-1} +  \phi_2 Y_{t-2} + … + \phi_p Y_{t-p} +\epsilon_t$$</p>
<h2 id="混合自回归移动平均过程"><a href="#混合自回归移动平均过程" class="headerlink" title="混合自回归移动平均过程"></a>混合自回归移动平均过程</h2><p>一个ARMA(p,q)过程包括自回归和移动平均项：<br>$$Y_t = c + \phi_1 Y_{t-1} +  \phi_2 Y_{t-2} + … + \phi_p Y_{t-p} +\epsilon_t + \theta_1\epsilon_{t-1} + \theta_2\epsilon_{t-2} + … + \theta_q\epsilon_{t-q}$$</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法设计与分析基础</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>预测</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="基于条件期望的预测"><a href="#基于条件期望的预测" class="headerlink" title="基于条件期望的预测"></a>基于条件期望的预测</h2><p>我们关心的是根据t期观测到的一组变量$X_t$预测变量$Y_{t+1}$。<br>令$Y^<em>_{t+1|t}$表示根据$X_t$作出的对$Y_{t+1}$的预测。为了评价这个预测有用性，我们需要给出一个损失函数来表示当我们的预测偏离一个特定的量时我们的关心程度。通过假定一个二次损失函数，可以得到一个便利的结果。二次损失函数的含义是选择合适的$Y^</em><em>{t+1|t}$，使得<br>$$MSE(Y^*</em>{t+1|t})\equiv E(Y_{t+1} - Y^<em>_{t+1|t})^2$$<br>最小。MSE被称作预测值$Y^</em>_{t+1|t}$的均方误差。<br>可以证明对该均方误差最小时的预测就是$X_t$条件下$Y_{t+1}$的期望，即：<br>$$Y^*<em>{t+1|t} =E(Y</em>{t+1}|X_t)$$</p>
<h2 id="基-于线性投影的预测"><a href="#基-于线性投影的预测" class="headerlink" title="基 于线性投影的预测"></a>基 于线性投影的预测</h2><p>我们现在将所考察的预测$Y^<em>_{t+1|t}$限定为$X_t$的线性函数：<br>$$Y^</em>_{t+1|t} = \alpha^,X_t$$<br>假定我们求出一个$\alpha$值，使得预测误差($Y_{t+1} - \alpha^,X_t$)与$X_t$无关：<br>$$E[(Y_{t+1} - \alpha^,X_t)X^,_t] = 0^,$$<br>那么，则预测$\alpha^,X_t$称为$Y_{t+1}$关于$X_t$的线性投影。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Envoy</title>
    <url>/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/Envoy/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils  device-mapper-persistent-data lvm2</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">yum install -y docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line">yum install -y git</span><br><span class="line">git clone https://github.com/envoyproxy/envoy.git</span><br><span class="line">git checkout v1.13.0</span><br></pre></td></tr></table></figure>
<p>./ci/run_envoy_docker.sh ‘./ci/do_ci.sh bazel.release.server_only’</p>
]]></content>
      <categories>
        <category>服务网格</category>
      </categories>
  </entry>
  <entry>
    <title>Istio</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/Istio/</url>
    <content><![CDATA[<p>kubectl apply -f <a href="https://istio.io/operator.yaml" target="_blank" rel="noopener">https://istio.io/operator.yaml</a></p>
<p>kubectl apply -f - &lt;&lt;EOF<br>apiVersion: install.istio.io/v1alpha2<br>kind: IstioControlPlane<br>metadata:<br>  namespace: istio-operator<br>  name: example-istiocontrolplane<br>spec:<br>  profile: demo<br>EOF</p>
<p>kubectl get svc -n istio-system</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>服务网格</tag>
        <tag>Service Mesh</tag>
      </tags>
  </entry>
  <entry>
    <title>服务网格技术选型</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<p>Linkerd<br>Istio<br>Consul<br>Apache ServiceComb Mersher:<br>SOFAMesh</p>
<h2 id="生产级微服务特性"><a href="#生产级微服务特性" class="headerlink" title="生产级微服务特性"></a>生产级微服务特性</h2><p>高可用</p>
<p>水平扩展</p>
<p>多中心</p>
<p>多环境<br>虚拟机<br>K8S</p>
<h3 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h3><blockquote>
<blockquote>
<p>docker run -h node1 –name consul -d -p 8400 -p 8500:8500 consul -server -bootstrap-expect 1 -advertise 127.0.0.1<br>docker run -h node1 –name consul -d -p 8400 -p 8500:0.0.0.0:8500 consul agent -server -ui -bootstrap-expect 1 -advertise 127.0.0.1</p>
</blockquote>
<p>docker run -h node1 –name consul -d -p 8400 -p 8500:8500 -e CONSUL_BIND_INTERFACE=eth0 consul agent -dev</p>
</blockquote>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>服务网格</tag>
        <tag>Service Mesh</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ANN/</url>
    <content><![CDATA[<p>神经网络是由简单处理单元构成的大规模并行分布式处理器，天然地具有存储经验知识和使之可用的特性。神经网络在两个方面与大脑相似：</p>
<p>1.神经网络是通过学习过程从外界环境中获取知识的。</p>
<p>2.互连神经元的连接强度，即突触权值，用于存储获取的知识。</p>
<p>神经网络的性质和能力<br>1.非线性。</p>
<p>2.输入输出映射。称之为有教师学习或监督学习的关于学习的流行方法。它使用带表号的训练样例或任务样例对神经网络的突触权值进行修改。</p>
<p>3.自适应性。神经网络具有调整自身突触权值以适应外界环境变化的固有能力。</p>
<p>4.证据响应。在模式分类问题中，神经网络可以设计成不仅提供选择哪一个特定模式的信息，还提供关于决策的置信度信息。</p>
<p>5.上下文信息。网络中每一个神经元都受网络中所有其他神经元全局活动的潜在影响。</p>
<p>6.容错性。由于网络存储的分布特性，神经网络从性能上显示了一个缓慢恶化的过程而不是灾难性的失败。</p>
<p>7.VLSI实现。神经网络的大规模并行性使它具有快速处理某些任务的潜在能力。</p>
<p>8.分析和设计的一致性。基本上，神经网络作为信息处理器具有通用性。</p>
<p>9.神经生物类比。神经网络的设计是由与人脑的类比引发的。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>Apriori</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Apriori/</url>
    <content><![CDATA[<p>优点：易编码实现。<br>缺点：在大数据集上可能较慢。<br>适用数据类型：数值型或者标称型数据。<br>规则的支持度和置信度是规则兴趣度的两种度量。它们分别反映所发现规则的有用性和确定性。关联规则的支持度为2%，意味着所分析的所有事务的2%显示计算机和杀毒软件被同时购买。置信度60%意味购买计算机的顾客60%也购买了杀毒软件。</p>
<p>Apriori算法的一般过程<br>1.收集数据：使用任意方法。<br>2.准备数据：任何数据类型都可以，因为我们只保存集合。<br>3.分析数据：使用任意方法。<br>4.训练算法：使用Apriori算法来找到频繁项集。<br>5.测试算法：不需要测试过程。<br>6.使用算法：用于发现频繁项集以及物品之间的关联规则。</p>
<p>Apriori原理<br>       Apriori原理是说如果某个项集市频繁的，那么它的所有子集也是频繁的。这意味着如果{0, 1}是频繁的，那么{0}、{1}也一定是频繁的。这个原理直观上并没有什么帮助，但是如果反过来看就有用了，也就是说如果一个项集是非频繁集，那么它的所有超集也是非频繁的。<br>伪代码<br>当集合中项的个数大于0时<br>       构建一个k个项组成的候选项集的列表<br>       检查数据以确认每个项集都是频繁的<br>       保留频繁项集并构建k + 1项组成的候选项集的列表</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>决策树</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DecisionTree/</url>
    <content><![CDATA[<p>ID3算法，C4.5算法，CART算法</p>
<p>优点:计算复杂度不高，输出结果易于理解，对中间值的缺失不敏感，可以处理不相关特征数据。</p>
<p>缺点:可能会产生过度匹配问题。</p>
<p>适用数据类型:数值型和标称型。</p>
<p>1.收集数据:可以使用任何方法。</p>
<p>2.准备数据:树构造算法只适用于标称型数据，因此数值型数据必须离散化。</p>
<p>3.分析数据:可以使用任何方法，构造树完成之后，我们应该检查图形是否符合预期。</p>
<p>4.训练算法:构造树的数据结构。</p>
<p>5.测试算法:使用经验树计算错误率。</p>
<p>6.使用算法:此步骤可以适用于任何监督学习算法发，而使用决策树可以更好地理解数据的内在含义。</p>
<p>划分数据集的大原则是：将无需的数据变得更加有序。</p>
<p>组织杂乱无章数据的一种方法就是使用信息论度量信息。</p>
<p>在划分数据集之前之后发生的变化称为信息增益。集合信息的度量方式称为香农熵或者简称为熵。</p>
<p>熵定义为信息的期望值。如果待分类的事务可能划分在多个分类之中，则</p>
<p>所有类别所有可能值包含的信息期望值，</p>
<p>另一种度量集合无序程度的方法是基尼不纯度</p>
<p>从一个数据集中随机选取子项，度量其被错误分类到其他分组里的概率。</p>
<p>决策树分类器就像带有终止块的流程图，终止块表示分类结果。开始处理数据集时，我们首先需要测量集合中数据的不一致性，也就是熵，然后寻找最优方案划分数据集，直到数据集中的所有数据属于同一分类。ID3算法可以用于划分标称型数据集。构建决策树时，我们通常采用递归的方法将数据集转化为决策树。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>k近邻算法</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/knn/</url>
    <content><![CDATA[<p>k-近邻算法(kNN)</p>
<p>描述：采用测量不同特征值之间的距离方法进行分类。</p>
<p>优点:精度高、对异常值不敏感、无数据输入假定。</p>
<p>缺点:计算复杂度高、空间复杂度高。</p>
<p>适用数据范围:数值型和标称型</p>
<p>工作原理:我们知道样本集中每一数据与所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据(最近邻)的分类标签。一般来说，我们只选择样本数据集中前k个(通常k&lt;20)最相似的数据。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。</p>
<p>1.收集数据:可以使用任何方法。</p>
<p>2.准备数据:距离计算所需要的数值，最好是结构化的数据格式。</p>
<p>3.分析数据:可以使用任何方法。</p>
<p>4.训练算法:此步骤不适用于k-近邻算法。</p>
<p>5.测试算法:计算错误率。</p>
<p>6.使用算法:首先需要输入样本数据和结构化的输出结构，然后运行k-近邻算法判定输入数据分别属于哪个分类，最后应用对计算粗的分类执行后续的处理。</p>
<p>计算向量点的距离:</p>
<p>数值归一化</p>
<p>在处理不同取值范围的特征值时，我们通常采用的方法是将数值归一化，如将取值范围处理为0到1或者-1到1之间。</p>
<p>特征值转化为0到1区间内的值:newValue =  (oldValue - min)/ (max - min)</p>
<p>k-近邻算法是分类数据最简单最有效的算法。k-近邻算法是基于实例的学习，使用算法时我们必须有接近实际数据的训练样本数据。k-近邻算法必须保存全部数据集，如果训练数据集很大，必须使用大量的存储空间。此外，由于必须对数据集中的每个数据计算距离值，实际使用时可能非常耗时。</p>
<p>k-近邻算法的另一个缺陷是它无法给出任何数据的基础结构信息，因此我们也无法知晓平均实例样本和典型实例样本具有什么特征。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习-sklearn</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-sklearn/</url>
    <content><![CDATA[<p>Scikit-Learn 设计的 API 设计的非常好。它的主要设计原则是：</p>
<h2 id="一致性："><a href="#一致性：" class="headerlink" title="一致性："></a>一致性：</h2><p>所有对象的接口一致且简单：</p>
<h3 id="估计器（estimator）"><a href="#估计器（estimator）" class="headerlink" title="估计器（estimator）"></a>估计器（estimator）</h3><p>任何可以基于数据集对一些参数进行估计的对象都被称为估计器（比如， imputer 就是个估计器）。<br>估计本身是通过 fit() 方法，只需要一个数据集作为参数（对于监督学习算法，需要两个数据集；第二个数据集包含标签）。<br>任何其它用来指导估计过程的参数都被当做超参数（比如 imputer 的 strategy ），<br>并且超参数要被设置成实例变量（通常通过构造器参数设置） 。</p>
<h3 id="转换器（transformer）"><a href="#转换器（transformer）" class="headerlink" title="转换器（transformer）"></a>转换器（transformer）</h3><p>一些估计器（比如 imputer ） 也可以转换数据集，这些估计器被称为转换器。<br>API也是相当简单：转换是通过 transform() 方法，被转换的数据集作为参数。<br>返回的是经过转换的数据集。转换过程依赖学习到的参数，比如 imputer 的例子。<br>所有的转换都有一个便捷的方法 fit_transform() ，等同于调用 fit() 再 transform() （但有时 fit_transform() 经过优化，运行的更快） 。</p>
<h3 id="预测器（predictor）"><a href="#预测器（predictor）" class="headerlink" title="预测器（predictor）"></a>预测器（predictor）</h3><p>最后，一些估计器可以根据给出的数据集做预测，这些估计器称为预测器。<br>例如，上一章的 LinearRegression 模型就是一个预测器：它根据一个国家的人均 GDP 预测生活满意度。<br>预测器有一个 predict() 方法，可以用新实例的数据集做出相应的预测。<br>预测器还有一个 score() 方法，可以根据测试集（和相应的标签，如果是监督学习算法的话） 对预测进行衡器。</p>
<h2 id="可检验"><a href="#可检验" class="headerlink" title="可检验"></a>可检验</h2><p>所有估计器的超参数都可以通过实例的public变量直接访问（比如， imputer.strategy ），<br>并且所有估计器学习到的参数也可以通过在实例变量名后加下划线来访问（比如， imputer.statistics_ ）。</p>
<h2 id="类不可扩散"><a href="#类不可扩散" class="headerlink" title="类不可扩散"></a>类不可扩散</h2><p>数据集被表示成 NumPy 数组或 SciPy 稀疏矩阵，而不是自制的类。<br>超参数只是普通的 Python 字符串或数字。</p>
<h2 id="可组合"><a href="#可组合" class="headerlink" title="可组合"></a>可组合</h2><p>尽可能使用现存的模块。<br>例如，用任意的转换器序列加上一个估计器，就可以做成一个流水线，后面会看到例子。</p>
<h2 id="合理的默认值"><a href="#合理的默认值" class="headerlink" title="合理的默认值"></a>合理的默认值</h2><p>Scikit-Learn 给大多数参数提供了合理的默认值，很容易就能创建一个系统。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习-概览</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h2 id="根据训练时监督的量和类型进行分类"><a href="#根据训练时监督的量和类型进行分类" class="headerlink" title="根据训练时监督的量和类型进行分类"></a>根据训练时监督的量和类型进行分类</h2><h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p>之所以称为监督学习，是因为这类算法必须知道预测什么，即目标变量的分类信息。(分类、回归)</p>
<ul>
<li>K近邻算法</li>
<li>线性回归</li>
<li>逻辑回归</li>
<li>支持向量机</li>
<li>决策树和随机森林</li>
<li><p>神经网络</p>
<h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>此时数据没有类别信息，也不会给定目标值。(聚类)</p>
</li>
<li><p>聚类</p>
<ul>
<li>K均值</li>
<li>层次聚类分析（HCA）</li>
<li>期望最大值</li>
</ul>
</li>
<li>可视化和降维<ul>
<li>主成分分析（PCA）</li>
<li>核主成分分析</li>
<li>局部线性嵌入（LLE）</li>
<li>t-分布领域嵌入算法（t-SNE）</li>
</ul>
</li>
<li>关联性规则学习<ul>
<li>Apriori算法</li>
<li>Eclat算法</li>
</ul>
</li>
</ul>
<h3 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h3><p>一些算法可以处理部分带标签的训练数据，通常是大量不带标签数据加上小部分带标签数据。</p>
<ul>
<li>深度信念网络</li>
<li>受限玻尔兹曼机（RBM）<h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3>学习系统在这里被称为（agent），可以对环境进行观察，选择和执行动作，获得奖励（惩罚）。然后它必须自己学习哪个是最佳方法（策略），<br>以得到长久的最大奖励。策略决定了智能体在给定情况下应该采取的行动。</li>
</ul>
<h2 id="根据是否能从导入的数据流进行持续学习"><a href="#根据是否能从导入的数据流进行持续学习" class="headerlink" title="根据是否能从导入的数据流进行持续学习"></a>根据是否能从导入的数据流进行持续学习</h2><h3 id="在线学习"><a href="#在线学习" class="headerlink" title="在线学习"></a>在线学习</h3><p>在线学习中，使用数据实例持续地进行训练，可以一次一个或一次几个实例（小批量），且自动对改变做出调整。</p>
<p>在线学习系统的一个重要参数是，它们可以多快地适应数据的改变：这被称为学习速率。</p>
<p>在线学习的挑战之一是，如果坏数据被用来进行训练，系统的性能就会逐渐下滑。<br>例如，坏数据可能来自失灵的传感器或机器人，或某人向搜索引擎传入垃圾信息以提高搜索排名。要减小这种风险，你需要密集监测，<br>如果检测到性能下降，要快速关闭（或是滚回到一个之前的状态） 。<br>你可能还要监测输入数据，对反常数据做出反应（比如，使用异常检测算法） 。</p>
<h3 id="批量学习"><a href="#批量学习" class="headerlink" title="批量学习"></a>批量学习</h3><p>在批量学习中，系统不能进行持续学习：必须用所有可用数据进行训练。首先是进行训练，然后部署在生产环境且停止学习，<br>它只是使用已经学到的策略。这称为离线学习。</p>
<h2 id="如何进行归纳推广"><a href="#如何进行归纳推广" class="headerlink" title="如何进行归纳推广"></a>如何进行归纳推广</h2><p>大多机器学习任务是关于预测的。这意味着给定一定数量的训练样本，系统需要能推广到之前没见到过的样本。<br>对训练数据集有很好的性能还不够，真正的目标是对新实例预测的性能。</p>
<h3 id="基于实例学习"><a href="#基于实例学习" class="headerlink" title="基于实例学习"></a>基于实例学习</h3><p>系统先用记忆学习案例，然后使用相似度测量推广到新的例子</p>
<p>如果用这种方法做一个垃圾邮件检测器，只需标记所有和用户标记的垃圾邮件相同的邮件 。<br>一个（简单的） 相似度测量方法是统计两封邮件包含的相同单词的数量。如果一封邮件含有许多垃圾邮件中的词，就会被标记为垃圾邮件。</p>
<h3 id="基于模型学习"><a href="#基于模型学习" class="headerlink" title="基于模型学习"></a>基于模型学习</h3><p>另一种从样本集进行归纳的方法是建立这些样本的模型，然后使用这个模型进行预测。这称作基于模型学习。</p>
<p>首先，选一个线性模型。<br>接下来，就是线性回归算法，你用训练样本训练算法，算法找到使线性模型最拟合数据的参数。这称作模型训练。<br>最后，可以准备运行模型进行预测了。</p>
<h2 id="机器学习算法应用程序开发步骤："><a href="#机器学习算法应用程序开发步骤：" class="headerlink" title="机器学习算法应用程序开发步骤："></a>机器学习算法应用程序开发步骤：</h2><p>1.收集数据<br>2.准备输入数据<br>3.分析输入数据<br>4.训练算法(无监督学习除外，由于不存在目标变量，故而也不需要训练算法)<br>5.测试算法<br>6.使用算法</p>
<h2 id="机器学习的主要挑战"><a href="#机器学习的主要挑战" class="headerlink" title="机器学习的主要挑战"></a>机器学习的主要挑战</h2><h3 id="训练数据量不足"><a href="#训练数据量不足" class="headerlink" title="训练数据量不足"></a>训练数据量不足</h3><p>需要大量数据，才能让多数机器学习算法正常工作。即便对于非常简单的问题，一般也需要数千的样本，<br>对于复杂的问题，比如图像或语音识别，你可能需要数百万的样本</p>
<h3 id="没有代表性的训练数据"><a href="#没有代表性的训练数据" class="headerlink" title="没有代表性的训练数据"></a>没有代表性的训练数据</h3><p>为了更好地进行归纳推广，让训练数据对新数据具有代表性是非常重要的。无论你用的是基于实例学习或基于模型学习，这点都很重要。<br>如果样本太小，就会有样本噪声（即，会有一定概率包含没有代表性的数据），<br>但是即使是非常大的样本也可能没有代表性，如果取样方法错误的话。这叫做样本偏差。</p>
<h3 id="低质量数据"><a href="#低质量数据" class="headerlink" title="低质量数据"></a>低质量数据</h3><p>如果训练集中的错误、异常值和噪声（错误测量引入的） 太多，系统检测出潜在规律的难度就会变大，性能就会降低。</p>
<h3 id="不相关的特征"><a href="#不相关的特征" class="headerlink" title="不相关的特征"></a>不相关的特征</h3><p>进来的是垃圾，出去的也是垃圾。你的系统只有在训练数据包含足够相关特征、非相关特征不多的情况下，才能进行学习。<br>机器学习项目成功的关键之一是用好的特征进行训练。</p>
<h3 id="过拟合训练数据"><a href="#过拟合训练数据" class="headerlink" title="过拟合训练数据"></a>过拟合训练数据</h3><p>模型在训练数据上表现很好，但是推广效果不好。<br>复杂的模型，比如深度神经网络，可以检测数据中的细微规律，但是如果训练集有噪声，或<br>者训练集太小（太小会引入样本噪声） ，模型就会去检测噪声本身的规律。很明显，这些规<br>律不能推广到新实例。</p>
<h3 id="欠拟合训练数据"><a href="#欠拟合训练数据" class="headerlink" title="欠拟合训练数据"></a>欠拟合训练数据</h3><p>当你的模型过于简单时就会发生。例如，生活满意度的线性模型倾向于欠拟合；现实要比这个模型复杂的多，所以预测很难准确，<br>即使在训练样本上也很难准确。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习-项目</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/pauljoo/labs-ml" target="_blank" rel="noopener">https://github.com/pauljoo/labs-ml</a></p>
<h2 id="一个完整机器学习项目的主要步骤"><a href="#一个完整机器学习项目的主要步骤" class="headerlink" title="一个完整机器学习项目的主要步骤"></a>一个完整机器学习项目的主要步骤</h2><ol>
<li>项目概述。</li>
<li>获取数据。</li>
<li>发现并可视化数据，发现规律。</li>
<li>为机器学习算法准备数据。</li>
<li>选择模型，进行训练。</li>
<li>微调模型。</li>
<li>给出解决方案。</li>
<li>部署、监控、维护系统。</li>
</ol>
<h2 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h2><ul>
<li>流行的开源数据仓库：<ul>
<li>UC Irvine Machine Learning Repository</li>
<li>Kaggle datasets</li>
<li>Amazon’s AWS datasets</li>
</ul>
</li>
<li>准入口（提供开源数据列表）<ul>
<li><a href="http://dataportals.org/" target="_blank" rel="noopener">http://dataportals.org/</a></li>
<li><a href="http://opendatamonitor.eu/" target="_blank" rel="noopener">http://opendatamonitor.eu/</a></li>
<li><a href="http://quandl.com/" target="_blank" rel="noopener">http://quandl.com/</a></li>
</ul>
</li>
<li>其它列出流行开源数据仓库的网页：<ul>
<li>Wikipedia’s list of Machine Learning datasets</li>
<li>Quora.com question</li>
<li>Datasets subreddit</li>
</ul>
</li>
</ul>
<h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p>利用加州普查数据，建立一个加州房价模型。这个数据包含每个街区组的人口、收入中位数、房价中位数等指标</p>
<h3 id="划定问题"><a href="#划定问题" class="headerlink" title="划定问题"></a>划定问题</h3><p>首先，你需要划定问题：监督或非监督，还是强化学习？这是个分类任务、回归任务，还是其它的？要使用批量学习还是线上学习？</p>
<ol>
<li><p>问老板的第一个问题应该是商业目标是什么？<br>建立模型可能不是最终目标。公司要如何使用、并从模型受益？<br>这非常重要，因为它决定了如何划定问题，要选择什么算法，评估模型性能的指标是什么，要花多少精力进行微调。<br>老板告诉你你的模型的输出（一个区的<strong>房价中位数</strong>） 会传给另一个机器学习系统，也有其它信号会传入后面的系统。<br>这一整套系统可以确定某个区进行投资值不值。确定值不值得投资非常重要，它直接影响利润。</p>
</li>
<li><p>现在的解决方案效果如何</p>
</li>
</ol>
<p>老板通常会给一个参考性能，以及如何解决问题。<br>老板说，现在街区的房价是靠专家手工估计的，专家队伍收集最新的关于一个区的信息（不包括房价中位数） ，他们使用复杂的规则进行估计。<br>这种方法费钱费时间，而且估计结果不理想，误差率大概有 15%。</p>
<h3 id="选择性能指标"><a href="#选择性能指标" class="headerlink" title="选择性能指标"></a>选择性能指标</h3><p>回归问题的典型指标是均方根误差（RMSE）。均方根误差测量的是系统预测误差的标准差。</p>
<p>虽然大多数时候 RMSE 是回归任务可靠的性能指标，在有些情况下，你可能需要另外的函数。<br>例如，假设存在许多异常的街区。此时，你可能需要使用平均绝对误差（Mean Absolute Error，也称作平均绝对偏差） ，</p>
<p>RMSE 和 MAE 都是测量预测值和目标值两个向量距离的方法。</p>
<h3 id="核实假设"><a href="#核实假设" class="headerlink" title="核实假设"></a>核实假设</h3><p>最后，最好列出并核对迄今（你或其他人） 作出的假设，这样可以尽早发现严重的问题。</p>
<p>例如，你的系统输出的街区房价，会传入到下游的机器学习系统，我们假设这些价格确实会被当做街区房价使用。<br>但是如果下游系统实际上将价格转化成了分类（例如，便宜、中等、昂贵） ，然后使用这些分类，而不是使用价格。<br>这样的话，获得准确的价格就不那么重要了，你只需要得到合适的分类。<br>问题相应地就变成了一个分类问题，而不是回归任务。你可不想在一个回归系统上工作了数月，最后才发现真相。</p>
<h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install jupyter matplotlib numpy pandas scipy scikit-learn</span><br></pre></td></tr></table></figure>
<h2 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jupyter notebook --ip=0.0.0.0 --no-browser --allow-root</span><br></pre></td></tr></table></figure>
<h2 id="创建测试集"><a href="#创建测试集" class="headerlink" title="创建测试集"></a>创建测试集</h2><p>在这个阶段就分割数据，听起来很奇怪。毕竟，你只是简单快速地查看了数据而已，你需要再仔细调查下数据以决定使用什么算法。</p>
<p>这么想是对的，但是人类的大脑是一个神奇的发现规律的系统，这意味着大脑非常容易发生过拟合：</p>
<p>如果你查看了测试集，就会不经意地按照测试集中的规律来选择某个特定的机器学习模型。<br>再当你使用测试集来评估误差率时，就会导致评估过于乐观，而实际部署的系统表现就会差。这称为数据透视偏差。</p>
<ol>
<li>纯随机的取样方法<br>当你的数据集很大时（尤其是和属性数相比） ，这通常可行；但如果数据集不大，就会有采样偏差的风险。</li>
<li>分层采样<br>将人群分成均匀的子分组，称为分层，从每个分层去取合适数量的实例，以保证测试集对总人数有代表性。</li>
</ol>
<h2 id="数据探索和可视化、发现规律"><a href="#数据探索和可视化、发现规律" class="headerlink" title="数据探索和可视化、发现规律"></a>数据探索和可视化、发现规律</h2><p>前为止，你只是快速查看了数据，对要处理的数据有了整体了解。现在的目标是更深的探索数据。<br>首先，保证你将测试集放在了一旁，只是研究训练集。</p>
<h3 id="地理数据可视化"><a href="#地理数据可视化" class="headerlink" title="地理数据可视化"></a>地理数据可视化</h3><p>通常来讲，人类的大脑非常善于发现图片中的规律，但是需要调整可视化参数使规律显现出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">housing.plot(kind=<span class="string">"scatter"</span>, x=<span class="string">"longitude"</span>, y=<span class="string">"latitude"</span>, alpha=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="查找关联"><a href="#查找关联" class="headerlink" title="查找关联"></a>查找关联</h3><p>当数据集并不是非常大，可以很容易地使用 corr() 方法计算出每对属性间的标准相关系数（standard correlation coefficient，也称作皮尔逊相关系数） </p>
<p>相关系数的范围是 -1 到 1。</p>
<ul>
<li>当接近 1 时，意味强正相关；例如，当收入中位数增加时，房价中位数也会增加。</li>
<li>当相关系数接近 -1 时，意味强负相关；</li>
<li>相关系数接近 0，意味没有线性相关性。</li>
</ul>
<blockquote>
<p>警告：相关系数只测量线性关系（如果 x 上升， y 则上升或下降）。<br>相关系数可能会完全忽略非线性关系（例如，如果 x 接近 0，则 y 值会变高）。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corr_matrix = housing.corr()</span><br><span class="line">corr_matrix[<span class="string">"median_house_value"</span>].sort_values(ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h4 id="scatter-matrix"><a href="#scatter-matrix" class="headerlink" title="scatter_matrix"></a>scatter_matrix</h4><p>另一种检测属性间相关系数的方法是使用 Pandas 的 scatter_matrix 函数，它能画出每个数值属性对每个其它数值属性的图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tools.plotting <span class="keyword">import</span> scatter_matrix</span><br><span class="line">attributes = [<span class="string">"median_house_value"</span>, <span class="string">"median_income"</span>, <span class="string">"total_rooms"</span>,<span class="string">"housing_median_age"</span>]</span><br><span class="line">scatter_matrix(housing[attributes], figsize=(<span class="number">12</span>, <span class="number">8</span>))</span><br></pre></td></tr></table></figure>
<p>最有希望用来预测房价中位数的属性是收入中位数，因此将这张图放大</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">housing.plot(kind=<span class="string">"scatter"</span>, x=<span class="string">"median_income"</span>,y=<span class="string">"median_house_value"</span>,alpha=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>
<p>你发现了一些数据的巧合，需要在给算法提供数据之前，将其去除。<br>你还发现了一些属性间有趣的关联，特别是目标属性。<br>你还注意到一些属性具有长尾分布，因此你可能要将其进行转换（例如，计算其 log 对数）。<br>当然，不同项目的处理方法各不相同，但大体思路是相似的。</p>
<h3 id="属性组合试验"><a href="#属性组合试验" class="headerlink" title="属性组合试验"></a>属性组合试验</h3><p>给算法准备数据之前，你需要做的最后一件事是尝试多种属性组合。<br>例如，如果你不知道某个街区有多少户，该街区的总房间数就没什么用。<br>你真正需要的是每户有几个房间。<br>相似的，总卧室数也不重要：你可能需要将其与房间数进行比较。<br>每户的人口数也是一个有趣的属性组合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">housing[<span class="string">"rooms_per_household"</span>] = housing[<span class="string">"total_rooms"</span>]/housing[<span class="string">"households"</span>]</span><br><span class="line">housing[<span class="string">"bedrooms_per_room"</span>] = housing[<span class="string">"total_bedrooms"</span>]/housing[<span class="string">"total_rooms"</span>]</span><br><span class="line">housing[<span class="string">"population_per_household"</span>]=housing[<span class="string">"population"</span>]/housing[<span class="string">"households"</span>]</span><br><span class="line">corr_matrix = housing.corr()</span><br><span class="line">corr_matrix[<span class="string">"median_house_value"</span>].sort_values(ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>看起来不错！与总房间数或卧室数相比，新的 bedrooms_per_room 属性与房价中位数的关联更强。<br>显然，卧室数/总房间数的比例越低，房价就越高。<br>每户的房间数也比街区的总房间数的更有信息，很明显，房屋越大，房价就越高。</p>
<h2 id="为机器学习算法准备数据"><a href="#为机器学习算法准备数据" class="headerlink" title="为机器学习算法准备数据"></a>为机器学习算法准备数据</h2><h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>大多机器学习算法不能处理缺失的特征，因此先创建一些函数来处理特征缺失的问题。<br>前面，你应该注意到了属性 total_bedrooms 有一些缺失值。<br>有三个解决选项：</p>
<ul>
<li>去掉对应的街区；</li>
<li>去掉整个属性；</li>
<li>进行赋值（0、平均值、中位数等等） 。</li>
</ul>
<h3 id="处理文本和类别属性"><a href="#处理文本和类别属性" class="headerlink" title="处理文本和类别属性"></a>处理文本和类别属性</h3><p>前面，我们丢弃了类别属性 ocean_proximity ，因为它是一个文本属性，不能计算出中位数。<br>大多数机器学习算法跟喜欢和数字打交道，所以让我们把这些文本标签转换为数字。</p>
<h3 id="自定义转换器"><a href="#自定义转换器" class="headerlink" title="自定义转换器"></a>自定义转换器</h3><p>尽管 Scikit-Learn 提供了许多有用的转换器，你还是需要自己动手写转换器执行任务，比如自定义的清理操作，或属性组合。<br>你需要让自制的转换器与 Scikit-Learn 组件（比如流水线） 无缝衔接工作，因为 Scikit-Learn 是依赖依赖类型的（而不是继承），<br>你所需要做的是创建一个类并执行三个方法： fit() （返回 self ） ， transform() ，和 fit_transform() 。</p>
<h3 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h3><p>数据要做的最重要的转换之一是特征缩放。除了个别情况，当输入的数值属性量度不同时，机器学习算法的性能都不会好。<br>这个规律也适用于房产数据：总房间数分布范围是 6 到39320，而收入中位数只分布在 0 到 15。注意通常情况下我们不需要对目标值进行缩放。<br>有两种常见的方法可以让所有的属性有相同的量度：线性函数归一化（Min-Max scaling）和标准化（standardization） 。</p>
<h3 id="转换流水线"><a href="#转换流水线" class="headerlink" title="转换流水线"></a>转换流水线</h3><p>你已经看到，存在许多数据转换步骤，需要按一定的顺序执行。幸运的是，Scikit-Learn 提供了类 Pipeline ，来进行这一系列的转换。</p>
<h2 id="选择并训练模型"><a href="#选择并训练模型" class="headerlink" title="选择并训练模型"></a>选择并训练模型</h2><h3 id="在训练集上训练和评估"><a href="#在训练集上训练和评估" class="headerlink" title="在训练集上训练和评估"></a>在训练集上训练和评估</h3><h4 id="线性回归模型"><a href="#线性回归模型" class="headerlink" title="线性回归模型"></a>线性回归模型</h4><ol>
<li><p>先来训练一个线性回归模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">lin_reg = LinearRegression()</span><br><span class="line">lin_reg.fit(housing_prepared, housing_labels)</span><br></pre></td></tr></table></figure>
</li>
<li><p>用训练集评估下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">housing_predictions = lin_reg.predict(housing_prepared)</span><br><span class="line">lin_mse = mean_squared_error(housing_labels, housing_predictions)</span><br><span class="line">lin_rmse = np.sqrt(lin_mse)</span><br><span class="line">lin_rmse</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="DecisionTreeRegressor"><a href="#DecisionTreeRegressor" class="headerlink" title="DecisionTreeRegressor"></a>DecisionTreeRegressor</h4><ol>
<li>尝试一个更为复杂的模型 DecisionTreeRegressor<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line">tree_reg = DecisionTreeRegressor()</span><br><span class="line">tree_reg.fit(housing_prepared, housing_labels)</span><br><span class="line"><span class="comment"># 68628.413493824875</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>大多数街区的 median_housing_values 位于 120000到 265000 美元之间，因此预测误差 68628 美元不能让人满意。<br>这是一个模型欠拟合训练数据的例子。<br>当这种情况发生时，意味着特征没有提供足够多的信息来做出一个好的预测，或者模型并不强大。</p>
<ol start="2">
<li>用训练集评估下<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">housing_predictions = tree_reg.predict(housing_prepared)</span><br><span class="line">tree_mse = mean_squared_error(housing_labels, housing_predictions)</span><br><span class="line">tree_rmse = np.sqrt(tree_mse)</span><br><span class="line">tree_rmse</span><br><span class="line"><span class="comment"># 0.0</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>没有误差？这个模型可能是绝对完美的吗？当然，更大可能性是这个模型严重过拟合数据。<br>如何确定呢？如前所述，直到你准备运行一个具备足够信心的模型，都不要碰测试集，因此你需要使用训练集的部分数据来做训练，用一部分来做模型验证。</p>
<h4 id="使用交叉验证做更佳的评估"><a href="#使用交叉验证做更佳的评估" class="headerlink" title="使用交叉验证做更佳的评估"></a>使用交叉验证做更佳的评估</h4><ol>
<li><p>用函数 train_test_split 来分割训练集<br>评估决策树模型的一种方法是用函数 train_test_split 来分割训练集，得到一个更小的训练<br>集和一个验证集，然后用更小的训练集来训练模型，用验证集来评估。这需要一定工作量，<br>并不难而且也可行。</p>
</li>
<li><p>用 Scikit-Learn 的交叉验证功能<br>另一种更好的方法是使用 Scikit-Learn 的交叉验证功能。下面的代码采用了 K 折交叉验证（K-fold cross-validation） ：<br>它随机地将训练集分成十个不同的子集，成为“折”，然后训练评估决策树模型 10 次，每次选一个不用的折来做评估，用其它 9 个来做训练。<br>结果是一个包含10 个评分的数组。</p>
</li>
</ol>
<p>判断没错：决策树模型过拟合很严重，它的性能比线性回归模型还差。</p>
<h4 id="RandomForestRegressor"><a href="#RandomForestRegressor" class="headerlink" title="RandomForestRegressor"></a>RandomForestRegressor</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line">forest_reg = RandomForestRegressor()</span><br><span class="line">forest_reg.fit(housing_prepared, housing_labels)</span><br><span class="line"><span class="comment"># [...]</span></span><br><span class="line">forest_rmse</span><br><span class="line"><span class="comment"># 22542.396440343684</span></span><br></pre></td></tr></table></figure>
<p>随机森林看起来很有希望。但是，训练集的评分仍然比验证集的评分低很多。<br>解决过拟合可以通过简化模型，给模型加限制（即，规整化） ，或用更多的训练数据。<br>在深入随机森林之前，你应该尝试下机器学习算法的其它类型模型（不同核心的支持向量机，神经网络，等等），<br>不要在调节超参数上花费太多时间。目标是列出一个可能模型的列表（<strong>两到五个</strong>） 。</p>
<h2 id="模型微调"><a href="#模型微调" class="headerlink" title="模型微调"></a>模型微调</h2><p>假设你现在有了一个列表，列表里有几个有希望的模型。你现在需要对它们进行微调。</p>
<p>微调的一种方法是手工调整超参数，直到找到一个好的超参数组合。这么做的话会非常冗长，你也可能没有时间探索多种组合。</p>
<h3 id="网格搜索"><a href="#网格搜索" class="headerlink" title="网格搜索"></a>网格搜索</h3><p>你应该使用 Scikit-Learn 的 GridSearchCV 来做这项搜索工作。<br>你所需要做的是告诉 GridSearchCV 要试验有哪些超参数，要试验什么值，GridSearchCV 就能用交叉验证试验所有可能超参数值的组合。</p>
<h3 id="随机搜索"><a href="#随机搜索" class="headerlink" title="随机搜索"></a>随机搜索</h3><p>当探索相对较少的组合时，就像前面的例子，网格搜索还可以。但是当超参数的搜索空间很大时，最好使用 RandomizedSearchCV 。</p>
<h3 id="集成方法"><a href="#集成方法" class="headerlink" title="集成方法"></a>集成方法</h3><p>另一种微调系统的方法是将表现最好的模型组合起来。<br>组合（集成） 之后的性能通常要比单独的模型要好（就像随机森林要比单独的决策树要好） ，特别是当单独模型的误差类型不同时。</p>
<h2 id="分析最佳模型和它们的误差"><a href="#分析最佳模型和它们的误差" class="headerlink" title="分析最佳模型和它们的误差"></a>分析最佳模型和它们的误差</h2><p>通过分析最佳模型，常常可以获得对问题更深的了解。比如， RandomForestRegressor 可以指出每个属性对于做出准确预测的相对重要性<br>有了这个信息，你就可以丢弃一些不那么重要的特征（比如，显然只要一个 ocean_proximity 的类型（INLAND） 就够了，所以可以丢弃掉其它的）。<br>你还应该看一下系统犯的误差，搞清为什么会有些误差，以及如何改正问题（添加更多的特征，或相反，去掉没有什么信息的特征，清洗异常值等等）。</p>
<h3 id="用测试集评估系统"><a href="#用测试集评估系统" class="headerlink" title="用测试集评估系统"></a>用测试集评估系统</h3><p>调节完系统之后，你终于有了一个性能足够好的系统。现在就可以用测试集评估最后的模型了。<br>这个过程没有什么特殊的：从测试集得到预测值和标签，运行 full_pipeline 转换数据（调用 transform() ，而不是 fit_transform() ！），再用测试集评估最终模型。</p>
<p>评估结果通常要比交叉验证的效果差一点，如果你之前做过很多超参数微调（因为你的系统在验证集上微调，得到了不错的性能，通常不会在未知的数据集上有同样好的效果）。<br>这个例子不属于这种情况，但是当发生这种情况时，你一定要忍住不要调节超参数，使测试集的效果变好；这样的提升不能推广到新数据上。<br>然后就是项目的预上线阶段：你需要展示你的方案（重点说明学到了什么、做了什么、没做什么、做过什么假设、系统的限制是什么，等等），<br>记录下所有事情，用漂亮的图表和容易记住的表达（比如，“收入中位数是房价最重要的预测量”） 做一次精彩的展示。</p>
<h2 id="启动、监控、维护系统"><a href="#启动、监控、维护系统" class="headerlink" title="启动、监控、维护系统"></a>启动、监控、维护系统</h2><p>很好，你被允许启动系统了！你需要为实际生产做好准备，特别是接入输入数据源，并编写测试。</p>
<p>你还需要编写监控代码，以固定间隔检测系统的实时表现，当发生下降时触发报警。这对于捕获突然的系统崩溃和性能下降十分重要。<br>做监控很常见，是因为模型会随着数据的演化而性能下降，除非模型用新数据定期训练。</p>
<ul>
<li><p>评估系统的表现需要对预测值采样并进行评估。<br>这通常需要人来分析。分析者可能是领域专家，或者是众包平台（比如 Amazon Mechanical Turk 或 CrowdFlower） 的工人。<br>不管采用哪种方法，你都需要将人工评估的流水线植入系统。</p>
</li>
<li><p>你还要评估系统输入数据的质量。<br>有时因为低质量的信号（比如失灵的传感器发送随机值，或另一个团队的输出停滞） ，系统的表现会逐渐变差，但可能需要一段时间，系统的表现才能下降到一定程度，触发警报。<br>如果监测了系统的输入，你就可能尽量早的发现问题。对于线上学习系统，监测输入数据是非常重要的。</p>
</li>
<li><p>最后，你可能想定期用新数据训练模型。<br>你应该尽可能自动化这个过程。如果不这么做，非常有可能你需要每隔至少六个月更新模型，系统的表现就会产生严重波动。<br>如果你的系统是一个线上学习系统，你需要定期保存系统状态快照，好能方便地回滚到之前的工作状态。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>C++ API设计-介绍</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/CplusplusAPI%E8%AE%BE%E8%AE%A1-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><blockquote>
<p>API提供了对某个问题的抽象，以及客户与解决该问题的软件组件之间进行交互的方式。</p>
</blockquote>
<p>API是一个明确定义的接口，可以为其他软件提供特定服务。<br>现代应用程序通常都是基于很多API建立起来的，而这些API往往又依赖于其他API。<br>目的是为某个组件的功能提供一个逻辑接口，同时隐藏该模块内部的实现细节。</p>
<h2 id="API设计中的一些关键因素"><a href="#API设计中的一些关键因素" class="headerlink" title="API设计中的一些关键因素"></a>API设计中的一些关键因素</h2><ol>
<li>API是为开发者设计的接口，如同GUI是为用户设计的接口一样。</li>
<li>多个应用程序可以共享一个API。</li>
<li>修改API时，必须竟可能保证向后兼容。</li>
</ol>
<p>API的生成周期一般比较长。为了创造良好的API，在前期要投入巨大的成本，因为规划、设计、版本和审查开销是必不可少的。</p>
<blockquote>
<p>API描述了其他工程师构建他们的应用软件所使用的软件。因此，API必须拥有良好的设计、文档、回归测试，并且保证发布之间的稳定性。</p>
</blockquote>
<h2 id="为什么使用API"><a href="#为什么使用API" class="headerlink" title="为什么使用API"></a>为什么使用API</h2><ol>
<li>更健壮的代码</li>
</ol>
<ul>
<li>隐藏实现</li>
<li>延长寿命</li>
<li>促进模块化</li>
<li>减少代码重复</li>
<li>消除硬编码假设</li>
<li>易于改变实现</li>
<li>易于优化</li>
</ul>
<ol start="2">
<li>代码复用<br>代码复用就是使用已有的软件去构建新的软件。软件开发从本质上已变得更加模块化。</li>
<li>并行开发<br>假设你正在编写一个字符串加密算法，其他开发者需要使用该算法将数据写入配置文件。一种做法是让其他开发者等你完成所有工作，然后在其文件输出模块中使用你的算法。然而，更有效率的做法是，你们提前见面协商好恰当的API，然后你把API放在适当的位置，而API仅仅其占位符的作用。<br>实际上，有些接口问题很可能在编写代码之前并没有预料到，因此API设计可能需要多次迭代才能保证其恰到好处。</li>
</ol>
<h2 id="何时应当避免使用API"><a href="#何时应当避免使用API" class="headerlink" title="何时应当避免使用API"></a>何时应当避免使用API</h2><p>如果编写的是不需要和其他客户端通信的内部模块，那么为模块创建并维护稳定公有接口的额外开销就不值得了。<br>假设你是一位想在应用程序中使用第三方API的软件开发人员，在如下情况下避免使用特定的API:</p>
<ul>
<li>许可证限制</li>
<li>功能不匹配</li>
<li>缺少源代码</li>
<li>缺乏文档</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title>C++ API设计-设计</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/CplusplusAPI%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>设计API的基本工作流程：从问题分析开始，设计解决方案，然后实现设计方案。</p>
<h2 id="技术债"><a href="#技术债" class="headerlink" title="技术债"></a>技术债</h2><p>技术债可以分为两类：<br>无意识的：软件是完全用心设计，结果却出现了问题，可能因为代码中引入了初级工程师的低质量代码，或者是因为兼并了其他公司，而被兼并的公司的软件存在各种问题等。<br>有意识的：由于时间、成本或资源限制等各方面压力而有意识地走捷径，寄希望于满足最后期限，之后再实施“正确的”方案。</p>
<p>当软件库正在接近最后期限，会出现如下4个警告信号：</p>
<ul>
<li>脆弱性：系统中一个地方的改动会引发</li>
<li>僵化性：软件难以改动。</li>
<li>顽固性：顽固的代码难以复用，有的实现可能与周边代码缠绕在一起。</li>
<li>不可转移性：如果团队中只有一个工程师可以处理代码中的某个部分，我们就说出现了不可转移性。</li>
</ul>
<p>因为积累了太多技术债，要花费很多时间维护和包含遗留代码，这比为客户增加新特性花费的时间还要多。这往往导致下一代项目需要修复老系统的问题。<br>从设计思路上讲，对于这样的下一代项目，其开发有以下两个方向。</p>
<ol>
<li>演进式。设计一个包含所有新需求的系统，然后迭代重构现有系统直到满足要求。</li>
<li>革命式。丢掉旧代码，然后从零开始设计，实现一个全新的系统。</li>
</ol>
<p>同样你要留意第二系统综合症，即新系统可能因为野心太大或工程实现过于复杂而失败。</p>
<h2 id="API设计的元素"><a href="#API设计的元素" class="headerlink" title="API设计的元素"></a>API设计的元素</h2><p>产生好的API设计的秘诀是：对问题领域进行合理抽象，然后设计相应的对象与类的层次结构来表达该抽象。<br>Grady Booch认为任何复杂系统都有两种层次化视角</p>
<ol>
<li>对象层次结构</li>
<li>类层次结构</li>
</ol>
<p>一般认为软件构建的设计阶段由两个主要活动组成。</p>
<ol>
<li>架构设计。描述软件的顶层结构与组织。</li>
<li>详细设计。在一个足够详细的层面描述设计中单独的组件，组件可以利用此描述信息来实现。</li>
</ol>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title>DevOps实践-简介</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/DevOps%E5%AE%9E%E8%B7%B5-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>DevOps由开发(developments)和运维(operations)两个单词组成。DevOps鼓励不同的开发部门共同协作。</p>
<p>DevOps起源于一名软件开发工程师Patrick Debios，他对于开发和运维之间的对立感到相当不爽。</p>
<p>DevOps,想要强调个体和互动是非常重要的，并且这个技术很可能有助于拆除企业里的部门墙。</p>
<p>开发团队、测试团队和运维团队会使用不同的系统来处理任务和缺陷。但是，三个系统都是相似的工作流程。三个系统变成一个系统存在可能，只需要为不同的角色展示不同的界面即可，这样会带来减少维护成本的长期利益。</p>
<p>DevOps的另一个核心目标是自动化和持续交付。</p>
<h2 id="快速"><a href="#快速" class="headerlink" title="快速"></a>快速</h2><p>DevOps化的转变必须要快。在高层次上，我们需要考虑抢占市场，在低层次上，我们需要紧盯任务。</p>
<p>DevOps工程师致力于让公司的流程更快、更有效，而且更可靠。只要有可能，就取代那些容易出错的重复性人力劳动。例如，如果你在程序编译时需要看机器人打气球，那么你的编译时间太长了。</p>
<p>增加企业内部各角色的交流就有很明显的价值。你的产品负责人可能想了解开发的进度并渴望能够先睹为快。像产品负责人这样的利益相关者，还有质量保证团队，都能够在测试环境跟上开发的节奏。</p>
<h2 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h2><h3 id="开发人员"><a href="#开发人员" class="headerlink" title="开发人员"></a>开发人员</h3><p>预打包开发环境，减少花费大量时间来创建开发环境。</p>
<h3 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h3><p>你需要决定文件夹结构的约定和使用的分支策略。</p>
<h3 id="构建服务器"><a href="#构建服务器" class="headerlink" title="构建服务器"></a>构建服务器</h3><h3 id="工件库"><a href="#工件库" class="headerlink" title="工件库"></a>工件库</h3><p>将构建好的二进制工件存放在一个库里。例如Nexus。</p>
<h3 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h3><p>在Red Hat系统上，这个命令是yum，或者是更新的dnf。Debian系的系统上市aptitude/dpkg。</p>
<h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p>测试环境应该尽可能像生产环境。应该能使用和生产环境相同的方法进行安装和配置。</p>
<h3 id="预发布-生产"><a href="#预发布-生产" class="headerlink" title="预发布/生产"></a>预发布/生产</h3><p>预发布环境应该可以和生产环境互换。</p>
<h3 id="发布管理"><a href="#发布管理" class="headerlink" title="发布管理"></a>发布管理</h3><p>一个梦寐以求的场景是自动化的发布过程。但是这个很难实现的，需要有相当高程度的自动化测试，才有信心时间自动化部署。而这通常很难做到。另一个原因是业务业务和技术开发的节奏不一定相同。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title>互联网架构</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E4%BA%92%E8%81%94%E7%BD%91%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>CMDB建设：负责底层基础设施管理，包括物理机、虚拟机、docker容器管理；<br>制定各种规范，进行多数据中心建设，业务上异地双活</p>
<p>DevOps平台：统一研发入口，可以调度底层各种工具，实现对应功能。<br>运维、配置管理、Java技术人员</p>
<p>集成各种语言的工程模板、git代码管理、jenkins持续集成、自动化接口和性能测试、发布流水线和金丝雀分析、域名解析、弹性扩缩容</p>
<p>负载均衡<br>全局负载均衡（Global Server Load Balance, GSLB）<br>服务器负载均衡（Server Load Balance, SLB）</p>
<p>信息安全技术架构</p>
<p>微服务平台技术架构</p>
<p>服务安全<br>事务服务<br>消息服务<br>配置中心<br>注册中心<br>调度中心<br>工作流服务<br>规则引擎及风控<br>搜索服务<br>流量控制<br>报表服务<br>缓存管理<br>故障演练<br>全链路压测<br>容量规划<br>在线调试zdebugger</p>
<p>测试平台技术架构</p>
<p>单元测试</p>
<p>接口测试<br>自动化测试</p>
<p>性能测试<br>全链路压测</p>
<p>数据平台技术架构</p>
<p>数据集成<br>存储计算<br>数据服务<br>数据分析<br>数据安全</p>
<p>展望<br>业务隐藏<br>弹性资源<br>响应式编程<br>SaaS<br>函数计算</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title>大型Cplusplus程序设计-概述</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E5%A4%A7%E5%9E%8BCplusplus%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>人们普遍认为在管理大型系统的复杂性方面，面向对象范型存在潜在优势。但是，如果你认为在大型项目中，只要使用C++就会确保成功，那就完全错了。<br>面向对象范型声名狼藉，因为面向对象范型比相应的面向过程技术需要更多的设计工作和悟性。通过虚函数改变内部行为的能力会使类不变量无效，这些类不变量对于纠正性能是必不可少的。而且，贯穿一个面向对象系统的控制流路径潜在数量可能会爆炸性地增大。<br>当程序规模变得更大时，不同属性的效力就开始起作用。<br>例如：</p>
<h2 id="1-循环依赖"><a href="#1-循环依赖" class="headerlink" title="1. 循环依赖"></a>1. 循环依赖</h2><h2 id="2-过度的链接时依赖"><a href="#2-过度的链接时依赖" class="headerlink" title="2. 过度的链接时依赖"></a>2. 过度的链接时依赖</h2><p>对象的好处之一是在需要时很容易添加功能。面向对象范型这种几乎诱人的特性让许多一丝不苟的开发人员把高效、考虑完善的类转换成具有大代码的“庞大恐龙”-绝大多数客户端没有使用大部分的类。<br>应用特别细致的String类编写的”Hello World”程序,竟然产生了1.2MB的可执行文件长度。</p>
<h2 id="3-过度的编译时依赖"><a href="#3-过度的编译时依赖" class="headerlink" title="3. 过度的编译时依赖"></a>3. 过度的编译时依赖</h2><p>用C++开发多文件程序，更改一个头文件可能会引起许多编译单元重新编译。随着系统的继续开发，重新编译整个系统所需的时间在逐渐增加，编译单个编译单元的时间也在逐渐增加。</p>
<h2 id="4-全局名字空间"><a href="#4-全局名字空间" class="headerlink" title="4. 全局名字空间"></a>4. 全局名字空间</h2><p>全局标识符的广泛应用可能会引发问题。一种显而易见的危险是这些名字可能会存在冲突。结果是，若不修改名字冲突，独立开发的系统部件将无法集成到一起。对于拥有数百个头文件的更大型项目来说，即使查找一个全局名字的声明也是一件困难的事情。</p>
<h2 id="5-逻辑设计和物理设计"><a href="#5-逻辑设计和物理设计" class="headerlink" title="5. 逻辑设计和物理设计"></a>5. 逻辑设计和物理设计</h2><p>大部分关于C++的书中只讲述了逻辑设计。逻辑设计是指从属于诸如类、运算符、函数等语言结构的那些设计。<br>物理设计解决的是与一个系统物理实体(像文件、目录和库等)密切联系的问题和物理实体之间的编译时依赖或者链接时依赖之类的组织问题。</p>
<h2 id="6-重用"><a href="#6-重用" class="headerlink" title="6. 重用"></a>6. 重用</h2><p>重用意味着耦合。<br>重用通常是一个好方案，但是为了成功重用，组件或子系统一定不要与一大段不必要的代码绑定在一起。也就是说，必须能够重用所需要的系统的一部分，同时不必链接系统的其他部分。<br>并不是所有的代码都可以重用，试图实现过多的功能或者为实现对象进行鲁棒错误检测，可能会增加不必要的开发和维护成本，同时也会增加可执行代码的大小。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title>大型网站服务器容量规划</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E9%87%8F%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title>系统分析与设计方法</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>系统分析与设计方法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-介绍</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>||    |创建型    |结构型    |行为型|<br>|范围    |类    |Factory Method(工厂方法)    |Adapter(类)(适配器)    |Interpreter(解释器)|<br>||    |Abstract Factory(抽象工厂)    Adapter(对象)(适配器)    |Template Method(模板方法)|<br>||    |Builder(生成器)    |Bridge(桥接)    |Chain of Responsibility(职责链)|<br>||    |Prototype(原型)    |Composite(组成)    |Command(命令)|<br>||    |Singleton(单件)    |Decorator(装饰)    |Iterator(迭代器)|<br>||    ||Facade(外观)    |Mediator(中介者)|<br>||    ||Flyweight(享元)    |Memento(备忘录)|<br>||    ||Proxy(代理)    |Observer(观察者)|<br>||    |||State(状态)|<br>||    |||Strategy(策略)|<br>||    |||Visitor(访问者)|</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-单件</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class Singleton</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">    Static Singleton* Instance();</span><br><span class="line">Protected:</span><br><span class="line">    Singleton();</span><br><span class="line">Private:</span><br><span class="line">    Static Singleton* _instance();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Singleton*Singleton::_instance = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Singleton*Singleton::Instance()</span><br><span class="line">&#123;</span><br><span class="line">    If(_instance == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        _instance = new Singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    Return _instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-原型</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class MazePrototypeFactory :public MazeFactory</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line"></span><br><span class="line">    MazePrototypeFactory (Maze*, Wall*, Room*, Door*);</span><br><span class="line"></span><br><span class="line">    Virtual Maze* MakeMaze() const;</span><br><span class="line">    Virtual Room* MakeRoom(int) const;</span><br><span class="line">    Virtual Wall* MakeWall() const;</span><br><span class="line">    Virtual Door* MakeDoor() const;</span><br><span class="line"></span><br><span class="line">Private:</span><br><span class="line">    Maze* _prototypeMaze;</span><br><span class="line">    Room* _prototypeRoom;</span><br><span class="line">    Wall* _prototypeWall;</span><br><span class="line">    Door* _prototypeDoor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">MazePrototypeFactory::MazePrototypeFactory (Maze* m, Wall* w, Room* r, Door* d)</span><br><span class="line">&#123;</span><br><span class="line">    _prototypeMaze = m;</span><br><span class="line">    _prototypeRoom = r;</span><br><span class="line">    _prototypeWall = w;</span><br><span class="line">    _prototypeDoor = d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Wall* MazePrototypeFactory::prototypeWall()</span><br><span class="line">&#123;</span><br><span class="line">    Return prototypeWall-&gt;Clone();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//使用基本迷宫构建的原型进行初始化。</span><br><span class="line"></span><br><span class="line">//普通的</span><br><span class="line">MazePrototypeFactorysimpleMazeFactory(new Maze, new Wall, new Room, new Door);</span><br><span class="line"></span><br><span class="line">//Bombed</span><br><span class="line">MazePrototypeFactorybombedMazeFactory(new Maze, new BombedWall, new RoomWithABomb, new Door);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-外观</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82/</url>
    <content><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class Scanner</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">    Scanner(istream&amp;);</span><br><span class="line">    Virtual ~Scanner();</span><br><span class="line"></span><br><span class="line">    Virtual Token&amp; Scan();</span><br><span class="line">Private:</span><br><span class="line">    Istream&amp; _inputStream;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Class Parser</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">    Parser();</span><br><span class="line">    Virtual ~Parser();</span><br><span class="line">    Virtual void Parse(Scanner&amp;, ProgramNodeBuilder&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//外观</span><br><span class="line">Class Compiler</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">    Compiler();</span><br><span class="line">    Virtual void Compile(istream&amp;, BytecodeStream&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//可以传入特定对象</span><br><span class="line">Void Compiler::Compile(istream&amp; input, BytecodeStream&amp; output)</span><br><span class="line">&#123;</span><br><span class="line">    Scanner scanner(input);</span><br><span class="line">    ProgramNodeBuilder builder;</span><br><span class="line">    Parser parser;</span><br><span class="line"></span><br><span class="line">    Parser.Parse(scanner, builder);</span><br><span class="line"></span><br><span class="line">    RISCCodeGenerator generator(output);</span><br><span class="line">    ProgramNode* parseTree = builder.GetRootNode();</span><br><span class="line">    parseTree-&gt;Traverse(generator);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂方法</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。使一个类的实例化延迟到其子类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class Creator</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">    Virtual Product* Create(ProductId id);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Product*Creator::Create(ProductId id)</span><br><span class="line">&#123;</span><br><span class="line">    If(id ==MINE) return new MyProduct();</span><br><span class="line"></span><br><span class="line">    If(id ==YOURS) return new YourProduct();</span><br><span class="line"></span><br><span class="line">    Return 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-抽象工厂</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</url>
    <content><![CDATA[<p>目的</p>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample:</span><br><span class="line">Interface IComputerFactory&#123;</span><br><span class="line">    createMouse();</span><br><span class="line">    createOS();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Class Mouse&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Class OS&#123;&#125;;</span><br><span class="line">//微软鼠标</span><br><span class="line">Class MicrosoftMouse extends Mouse&#123;&#125;;</span><br><span class="line"></span><br><span class="line">//苹果鼠标</span><br><span class="line">Class AppleMouse extends Mouse&#123;&#125;;</span><br><span class="line"></span><br><span class="line">//微软系统</span><br><span class="line">Class MicrosoftOS extends OS&#123;&#125;;</span><br><span class="line"></span><br><span class="line">//苹果系统</span><br><span class="line">Class AppleOS extends OS&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Class MicrosoftFactory implements IComputerFactory&#123;</span><br><span class="line"></span><br><span class="line">    Mouse createMouse()&#123;</span><br><span class="line">        Return new MicrosoftMouse();//创建相应的鼠标品牌</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    OS createOS();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">ClassAppleFactory implementsI IComputerFactory&#123;</span><br><span class="line">    Mouse createMouse()&#123;</span><br><span class="line">        Return new AppleMouse();//创建相应的鼠标品牌</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    OS createOS();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Classclient&#123;</span><br><span class="line"></span><br><span class="line">    //具体工厂的抽象接口作为参数传入</span><br><span class="line">    createComputer(ComputerFactory factory)&#123;</span><br><span class="line">        //动态绑定到具体工厂,具体工厂生产相应的鼠标品牌</span><br><span class="line">        Mouse mouse = factory.createMouse();</span><br><span class="line">        OS os = factory.createOS();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-桥接</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5/</url>
    <content><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>当一个抽象可能有多个实现时，通常用继承来协调它们。抽象类定义对该抽象的接口，而具体的子类则用不同方式加以实现。但是此方法有时不够灵活。继承机制将抽象部分与它的实现部分固定在一起，使得难以对抽象部分和实现部分独立地进行修改、扩充和重用。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p><code>`</code><br>Class Window<br>{<br>Public:<br>    Window(View<em> contents);<br>    Virtual void DrawContents();<br>    Virual void Open();<br>    Virual void Close();<br>    Virual void Iconify();<br>    Virual void Deiconify();<br>    Virual void SetOrigin(const Point&amp; at);<br>    Virual void SetExtent(const Point&amp; extent);<br>    Virual void Raise();<br>    Virual void Lower();<br>    Virual void DrawLine(const Point&amp;, const Point&amp;);<br>    Virual void DrawRect(const Point&amp;, const Point&amp;);<br>    Virual void DrawPolygon(const Point[], int n);<br>    Virual void DrawText(const char</em>, const Point&amp;);</p>
<p>Protected:<br>    WindowImp<em> GetWindowImp();<br>    View</em> GetView();<br>Private:<br>    WindowImp<em> _imp;<br>    View</em> _contents;<br>};</p>
<p>//Window维护一个对WindowImp的引用, WindowImp抽象类定义了一个对底层窗口系统的接口。<br>Class WindowImp<br>{<br>Public:<br>    Virtual void ImpTop() = 0;<br>    Virtual void ImpBottom() = 0;<br>    Virtual void ImpSetExtent(const Point&amp;) = 0;<br>    Virtual void ImpSetOrigin(const Point&amp;) = 0;<br>    Virtual void DeviceRect(Coord, Coord, Coord, Coord) = 0;<br>    Virtual void DeviceText(const char<em>, Coord, Coord) = 0;<br>    Virtual void DeviceBitmap(const char</em>, Coord, Coord) = 0;<br>Protected:<br>    WindowImp();<br>};</p>
<p>VoidWindow::DrawRect(const Point&amp; p1, const Point&amp; p2)<br>{<br>    WindowImp* imp = GetWindowImp();<br>    Imp-&gt;DeviceRect(p1.x(), p1.Y(), p2.X(), p2.Y());<br>};</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-生成器</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>抽象工厂与生成器相似，主要的区别是生成器模式着重于一步步构造一个复杂对象。而抽象工厂着重于多个系列的产品对象。Builder在最后的一步返回，而对于Abstract Factory来说，产品是立即返回的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class MazeBuilder</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">    Virtual void BuildMaze();</span><br><span class="line">    Virtual void BuildRoom(int room);</span><br><span class="line">    Virtual void BuildDoor(int roomFrom, int roomTo);</span><br><span class="line">    Virtual Maze* GetMaze();</span><br><span class="line">Protected:</span><br><span class="line">    MazeBuilder();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Maze*MazeGame::CreateMaze(MazeBuilder&amp; build)</span><br><span class="line">&#123;</span><br><span class="line">    Builder.BuildMaze();</span><br><span class="line">    Builder.BuildRoom(1);</span><br><span class="line">    Builder.BuildRoom(2);</span><br><span class="line">    Builder.BuildDoor(1,2);</span><br><span class="line">    Return builder.GetMaze();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-组合</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>将对象组合成树形结构以表示“部分-整体”的层次结构。使得用户对单个对象和组合对象的使用具有一致性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class Equipment</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">    Virtual ~Equipment();</span><br><span class="line"></span><br><span class="line">    Const char* Name() &#123; return _name&#125;;</span><br><span class="line"></span><br><span class="line">    Virtual Watt Power();</span><br><span class="line">    Virtual Currency NetPrice();</span><br><span class="line">    Virtual Currency DiscountPrice();</span><br><span class="line"></span><br><span class="line">    Virtual void Add(Equipment*);</span><br><span class="line">    Virtual void Remove(Equipment*);</span><br><span class="line">    Virtual Iterator&lt;Equipment*&gt;* CreateIterator();</span><br><span class="line">Protected:</span><br><span class="line">    Equipment(const char*);</span><br><span class="line">Private:</span><br><span class="line">    Const char* _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Class FloppyDisk : public Equipment</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">    FloppyDisk(const char*);</span><br><span class="line">    Virtual ~FloppyDisk ();</span><br><span class="line"></span><br><span class="line">    Virtual Watt Power();</span><br><span class="line">    Virtual Currency NetPrice();</span><br><span class="line">    Virtual Currency DiscountPrice();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Class CompositeEquipment : public Equipment</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">    Virtual ~CompositeEquipment ();</span><br><span class="line"></span><br><span class="line">    Virtual Watt Power();</span><br><span class="line">    Virtual Currency NetPrice();</span><br><span class="line">    Virtual Currency DiscountPrice();</span><br><span class="line"></span><br><span class="line">    Virtual void Add(Equipment*);</span><br><span class="line">    Virtual void Remove(Equipment*);</span><br><span class="line">    Virtual Iterator&lt;Equipment*&gt;* CreateIterator();</span><br><span class="line">Protected:</span><br><span class="line">    CompositeEquipment (const char*);</span><br><span class="line">Private:</span><br><span class="line">    List&lt;Equipment*&gt; _equipment;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Currency CompositeEquipment::NetPrice()</span><br><span class="line">&#123;</span><br><span class="line">    Iterator&lt;Equipment*&gt;* I = CreateIterator();</span><br><span class="line">    Currency total = 0;</span><br><span class="line">    For(i-&gt;First(); !i-&gt;IsDone(); i-&gt;Next())</span><br><span class="line">    &#123;</span><br><span class="line">        Total += i-&gt;CurrentItem()-&gt;NetPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    Delete I;</span><br><span class="line">    Return total;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Class Chassis : public CompositeEquipment </span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">    Chassis (const char*);</span><br><span class="line">    Virtual ~Chassis ();</span><br><span class="line"></span><br><span class="line">    Virtual Watt Power();</span><br><span class="line">    Virtual Currency NetPrice();</span><br><span class="line">    Virtual Currency DiscountPrice();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Cabinet* cabinet = new Cabinet();</span><br><span class="line">Chassis* chassis = new Chassis();</span><br><span class="line">Cabinet-&gt;Add(chassis);</span><br><span class="line"></span><br><span class="line">Bus* bus = new Bus(&quot;MCA Bus&quot;);</span><br><span class="line">Bus-&gt;Add(new Card(&quot;16Mbs Token Ring&quot;));</span><br><span class="line"></span><br><span class="line">Chassis-&gt;Add(bus);</span><br><span class="line">Chassis-&gt;Add(new FloppyDisk(&quot;3.5in Floppy&quot;));</span><br><span class="line"></span><br><span class="line">Cout &lt;&lt; &quot;The net price is &quot; &lt;&lt; chassis-&gt;NetPrice() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-装饰</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0/</url>
    <content><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class VisualComponent</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">    VisualComponent();</span><br><span class="line"></span><br><span class="line">    Virtual void Draw();</span><br><span class="line">    Virtual void Resize();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Class Decorator : public VisualComponent</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">    Decorator(VisualComponent*);</span><br><span class="line"></span><br><span class="line">    Virtual void Draw();</span><br><span class="line">    Virtual void Resize();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Void Decorator::Draw()</span><br><span class="line">&#123;</span><br><span class="line">    Return _component-&gt;Draw();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Void Decorator::Resize()</span><br><span class="line">&#123;</span><br><span class="line">    Return _component-&gt;Resize();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Class BorderDecorator : public Decorator</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">    BorderDecorator (VisualComponent*, int borderWidth);</span><br><span class="line">    Virtual void Draw();</span><br><span class="line">Private:</span><br><span class="line">    void DrawBorder(int);</span><br><span class="line">Private:</span><br><span class="line">    Int _width;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Void BorderDecorator::Draw()</span><br><span class="line">&#123;</span><br><span class="line">    Decorator::Draw();</span><br><span class="line">    DrawBorder(_width);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-适配器</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/</url>
    <content><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p>类适配器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class Shape</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">    Shape();</span><br><span class="line">    Virtual void BoundingBox(Point&amp; bottomLeft, Point&amp; topRight)const;</span><br><span class="line">    Virtual Manipulator* CreateManipulator() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ClassTextView</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">    TextView();</span><br><span class="line">    Void GetOrigin(Coord&amp; x, Coord&amp; y) const;</span><br><span class="line">    Void GetExtend(Coord&amp; width, Coord&amp; height) const;</span><br><span class="line">    Virtual bool IsEmpty() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ClassTextShape : public Shape, private TextView</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">    TextShape();</span><br><span class="line">    Virtual void BoundingBox(Point&amp; bottomLeft, Point&amp; topRight)const;</span><br><span class="line">    Virtual bool IsEmpty() const;</span><br><span class="line">    Virtual Manipulator* CreateManipulator() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//对TextView接口进行转换使之匹配Shape</span><br><span class="line">VoidTextShape::BoundingBox(Point&amp; bottomLeft, Point&amp; topRight) const</span><br><span class="line">&#123;</span><br><span class="line">    Coord bottom, left, width, height;</span><br><span class="line"></span><br><span class="line">    GetOrigin(bottom, left);</span><br><span class="line">    GetExtend(width, height);</span><br><span class="line"></span><br><span class="line">    bottomLeft = Point(bottom, left);</span><br><span class="line">    topRight = Point(bottom + height, left + width);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象适配器<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//对象适配器采用对象组合的方法将具有不同接口的类组合在一起。在该方法中，适配器TextShape维护一个指向TextView的指针</span><br><span class="line">Class TextShape : public Shape</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">    TextShape (TextView*);</span><br><span class="line">    Virtual void BoundingBox(Point&amp; bottomLeft, Point&amp; topRight)const;</span><br><span class="line">    Virtual bool IsEmpty() const;</span><br><span class="line">    Virtual Manipulator* CreateManipulator() const;</span><br><span class="line">Private:</span><br><span class="line">    TextView* _text;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TextShape ::TextShape (TextView*)</span><br><span class="line">&#123;</span><br><span class="line">    _text = t;//初始化</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VoidTextShape::BoundingBox(Point&amp; bottomLeft, Point&amp; topRight) const</span><br><span class="line">&#123;</span><br><span class="line">    Coord bottom, left, width, height;</span><br><span class="line"></span><br><span class="line">    _text-&gt;GetOrigin(bottom, left);</span><br><span class="line">    _text-&gt;GetExtend(width, height);</span><br><span class="line"></span><br><span class="line">    bottomLeft = Point(bottom, left);</span><br><span class="line"></span><br><span class="line">    topRight = Point(bottom + height, left + width);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>软件构架实践-构架商业周期</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E8%BD%AF%E4%BB%B6%E6%9E%84%E6%9E%B6%E5%AE%9E%E8%B7%B5-%E6%9E%84%E6%9E%B6%E5%95%86%E4%B8%9A%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>软件构架是技术、商业和社会等诸多因素作用的结果，而软件构架的存在反过来又会影响技术、商业和社会环境。</p>
<h2 id="构架所受的影响"><a href="#构架所受的影响" class="headerlink" title="构架所受的影响"></a>构架所受的影响</h2><ul>
<li>构架受系统受众的影响</li>
</ul>
<p>很多人和组织都对构建软件系统感兴趣。我们把这样的人或组织称为涉众：客户、最终用户、开发人员、项目经理、维护人员以及那些对系统进行市场营销活动的人等等。这些涉众所关注的问题各不相同，但都要求系统能够在他们所关注的方面提供保证或优化。</p>
<ul>
<li>构架受开发组织的影响</li>
</ul>
<p>组织中是否有足够多的有空闲时间且精通C/S通信的程序员?人员的技能也是一个影响因素，开发进度和预算也会对构架产生影响。</p>
<ul>
<li>构架受设计师的素质和经验的影响</li>
</ul>
<p>设计构架时所做的各种选择与设计师本人所受的教育或培训背景、对其他成功构架的了解以及对某些性能极佳或极差的系统的了解有关。</p>
<ul>
<li>构架受技术环境的影响</li>
</ul>
<p>这里所说的技术环境包括行业中的通常做法或在设计师所属专业团体中占主导地位的软件工程技巧。</p>
<ul>
<li>影响构架的其他因素</li>
</ul>
<h2 id="构架对诸影响因素的反作用"><a href="#构架对诸影响因素的反作用" class="headerlink" title="构架对诸影响因素的反作用"></a>构架对诸影响因素的反作用</h2><p>企业目标、产品需求、设计师的经验、构架和最终系统之间构成带有反馈回路的、可由开发组织实施管理的周期。开发组织对这个周期管理的好，就能够不断成长壮大，拓展其经营范围，充分利用以前在构架和系统构建方面的投资。</p>
<ul>
<li>构架影响开发组织的结构</li>
<li>构架影响开发组织的目标</li>
<li>构架影响客户对下一个系统的要求</li>
<li>构架系统的过程丰富了整个开发团体的敬仰</li>
<li>一些典型的系统会影响并实际改变软件工程的发展，也就是系统开发人员学习和实践的技术环境。</li>
</ul>
<h2 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h2><ul>
<li>为系统构建一个商业案例</li>
<li>理解系统需求</li>
<li>创建或选择构架</li>
<li>将构架编成文档，并与有关各方进行交流</li>
<li>对此构架进行分析和评价</li>
<li>根据此构架实现系统</li>
<li>保证系统实现符合构架的要求</li>
</ul>
<h2 id="什么样的架构才算好"><a href="#什么样的架构才算好" class="headerlink" title="什么样的架构才算好"></a>什么样的架构才算好</h2><h3 id="关于过程的建议"><a href="#关于过程的建议" class="headerlink" title="关于过程的建议"></a>关于过程的建议</h3><ul>
<li>构架的设计应该由一位设计师来完成，或者由一个在某位设计师领导下的小组来完成。</li>
<li>设计师应全面掌握系统的功能需求，并且应有一份所设计构架应满足的划分了优先级的质量属性列表。</li>
<li>构架的文档应该完备，至少应有一个静态视图和一个动态视图，应该采用所有人员认可的文档形式，以保证所有涉众都能很容易的理解这些文档。</li>
<li>应该把架构设计方案交由各涉众传阅，应该让各涉众积极参与设计方案的评审。</li>
<li>应该对构架认真进行分析，得出可应用的量化度量指标。也应该对质量属性进行正式评估，以避免出现发现问题时为时已晚的情况。</li>
<li>构架的设计应有助于增量式实现。为此，可先创建一个粗略的、具备雏形但功能最简单的系统，通过把这个骨架系统逐步细化、扩大来得到所期望的系统。</li>
<li>允许构架带来一定的资源争用，但应该清楚地给出这些资源争用的解决方案，告之于有关各方，并保证这些解决方案切实可行。例如，若网络占用是要考虑的问题，设计师就要为每个开发小组制定出将网络占用减少到最低限度的指导原则。</li>
</ul>
<h3 id="关于产品-结构-的建议"><a href="#关于产品-结构-的建议" class="headerlink" title="关于产品(结构)的建议"></a>关于产品(结构)的建议</h3><ul>
<li>构架应采用定义良好的模块，各模块的功能责任划分应基于信息隐藏和相互独立的原则。</li>
<li>应该使用特定于每个属性的众所周知的构架战术来实现质量属性。</li>
<li>构架绝对不可以依赖于某个特定版本的商业产品或工具。</li>
<li>应将产生数据的模块和使用数据的模块分离开。</li>
<li>对于并行处理系统，构架应该采用定义良好的进程或任务，它们未必反映模块分解结构。</li>
<li>每个任务或进程的编写都要考虑到与特定处理器的关系，并保证能够方便的改变这种关系。</li>
<li>构架应该采用少量的、简单的交互模式。在整个运行过程中，系统的功能应保持一致，这可使系统易于理解，有助于缩短开发时间、提高可靠性、增强可修改性。</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>软件构架实践</tag>
      </tags>
  </entry>
  <entry>
    <title>软件构架实践-质量属性</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E8%BD%AF%E4%BB%B6%E6%9E%84%E6%9E%B6%E5%AE%9E%E8%B7%B5-%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h2 id="质量属性场景"><a href="#质量属性场景" class="headerlink" title="质量属性场景"></a>质量属性场景</h2><p>质量属性场景是一种面向特定的质量属性的需求。它由以下6部分组成：</p>
<ul>
<li>刺激源：某个生成该刺激的实体（人、计算机系统或任何其他激励器）。</li>
<li>刺激：该刺激是当刺激到达系统时需要考虑的条件。</li>
<li>环境：该刺激在某些条件内发生。当刺激发生时，系统可能处于过载，或者正在运行，也可能是其他情况。</li>
<li>制品：某个制品被刺激。这可能是整个系统，也可能是系统的一部分。</li>
<li>响应：该响应是在刺激到达后所采取的行动。</li>
<li>响应度量：当响应发生时，应该能够以某种方式对其进行度量，以对需求进行测试。</li>
</ul>
<p>我们将一般的质量属性场景与具体的质量属性场景区分开来，前者是指那些独立于系统，很可能适合任何系统的场景，后者是指适合正在考虑的某个特定系统的场景。</p>
<img src="/架构/架构/软件构架实践-质量属性/质量属性场景的6个部分.jpg" title="质量属性场景的6个部分">
<h3 id="可用性的一般场景生成"><a href="#可用性的一般场景生成" class="headerlink" title="可用性的一般场景生成"></a>可用性的一般场景生成</h3><table>
<thead>
<tr>
<th>场景的部分</th>
<th>可能的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>源</td>
<td>系统内部、系统外部</td>
</tr>
<tr>
<td>刺激</td>
<td>错误：疏忽、崩溃、时间、响应</td>
</tr>
<tr>
<td>制品</td>
<td>系统的处理器、通信通道、持久存储器、进程</td>
</tr>
<tr>
<td>环境</td>
<td>正常操作、降级模式</td>
</tr>
<tr>
<td>响应</td>
<td>系统应该检测时间，并进行如下一个或多个活动：将其记录下来，通知适当的各方，根据已定义的规则禁止导致错误或故障的事件源，在一段预先指定的时间间隔内不可用。</td>
</tr>
<tr>
<td>响应度量</td>
<td>系统必须可用的时间间隔；可用时间；系统可以在降级模式下运行的时间间隔；修复时间；</td>
</tr>
</tbody>
</table>
<h3 id="可用性的一般场景"><a href="#可用性的一般场景" class="headerlink" title="可用性的一般场景"></a>可用性的一般场景</h3><img src="/架构/架构/软件构架实践-质量属性/可用性的一般场景.jpg" title="可用性的一般场景">
<h3 id="可用性的场景样例"><a href="#可用性的场景样例" class="headerlink" title="可用性的场景样例"></a>可用性的场景样例</h3><img src="/架构/架构/软件构架实践-质量属性/可用性的场景样例.jpg" title="可用性的场景样例">
<h2 id="系统质量属性"><a href="#系统质量属性" class="headerlink" title="系统质量属性"></a>系统质量属性</h2><ol>
<li>可用性</li>
</ol>
<p>可用性所关注的方面包括：如何检测系统故障，系统故障发生的频度，出现故障时会发生什么情况，允许系统有多长时间非正常运行，什么时候可以安全的出现故障，如何防止故障的发生以及发生故障时要求进行哪种通知。</p>
<ol start="2">
<li>可修改性</li>
</ol>
<p>可修改性是有关变更的成本问题，它提出了两个关注点。</p>
<ul>
<li>可以修改什么?可以修改系统的任何方面，最常见的就是系统计算的功能、系统存在的平台、系统运行的环境、系统所展示的质量属性以及其容量。</li>
<li>任何进行变更以及由谁进行变更?可以在编译期间、构建期间、配置设置迁建或者执行期间改变实现。变更还可以由开发人员、最终用户或系统管理员进行。</li>
</ul>
<ol start="3">
<li>性能</li>
</ol>
<p>性能与时间有关。可以用等待时间、处理期限、系统吞吐量、响应抖动、由于系统太忙因而无法做出响应所导致的未处理事件的数量，以及因系统太忙所丢失的数据。</p>
<ol start="4">
<li>安全性</li>
</ol>
<p>可以把安全性刻画为一个提供认可、机密性、完整性、保证、可用性和审核的系统。</p>
<ul>
<li>认可：就是交易不能被交易的任何一方拒绝的属性。这意味着如果你通过Internet订购了某个项目的话，就不能否认。</li>
<li>机密性：就是未经授权不能访问数据或服务的属性。</li>
<li>完整性：根据计划来提交数据或服务的属性。自从老师给你分配登记后，等级就没有改变过。</li>
<li>保证：交易的各方是所声称的人的属性。当客户发送一个信用卡卡号到Internet商家时，该商家正是客户所认为的商家。</li>
<li>可用性：系统可用于合法用户的属性。拒绝服务供给不会阻碍你订购。</li>
<li>审核：系统在其内部跟踪活动的属性，跟踪的级别足以对活动进行重构。</li>
</ul>
<ol start="5">
<li>可测试性</li>
</ol>
<p>可测试性的响应度量是测试在发现缺陷方面的效率，以及要想达到某个期望的覆盖范围，需要用多长时间进行测试。</p>
<ol start="6">
<li>易用性</li>
</ol>
<p>易用性关注的是对用户来说完成某个期望任务的容易程度和系统所提供的用户支持的种类。</p>
<ul>
<li>学习系统的特性：如果用户不熟悉某个特定的系统或该系统的某一特定方面，那么系统可以如何使学习任务变得更容易。</li>
<li>有效的使用系统：系统如何提高用户的操作效率。</li>
<li>将错误的影响降到最低：系统怎样使用户所犯的错误造成的影响最小。</li>
<li>使系统适应用户的需要：系统如何使用户的任务变得更轻松。</li>
<li>提高自信和满意度：系统如何使用户却行采取了正确的行动。</li>
</ul>
<h2 id="其他系统质量属性"><a href="#其他系统质量属性" class="headerlink" title="其他系统质量属性"></a>其他系统质量属性</h2><p>在其他资料中，还可以发现大量的其他属性。比如可扩充性，可移植性等等。在引用这些质量属性的时候，通过对一般场景的6个部分进行描述即可。</p>
<h2 id="商业质量属性"><a href="#商业质量属性" class="headerlink" title="商业质量属性"></a>商业质量属性</h2><ol>
<li>上市时间</li>
<li>成本和收益</li>
<li>所希望的系统生命期的长短</li>
<li>目标市场</li>
<li>推出计划</li>
<li>与老系统的集成</li>
</ol>
<h2 id="构架质量属性"><a href="#构架质量属性" class="headerlink" title="构架质量属性"></a>构架质量属性</h2><ol>
<li>概念完整性：在各个层次上统一系统设计的根本指导思想。</li>
<li>正确性和完整性：构架能够满足系统的各种需求及运行时的资源要求的必要条件。</li>
<li>可构建性：保证能够由指定的开发小组在规定的时间里及时开发系统，并允许在开发过程中做某些更改的架构属性。</li>
</ol>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>软件构架实践</tag>
      </tags>
  </entry>
  <entry>
    <title>面向模式的软件架构-Blackboard模式</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E9%9D%A2%E5%90%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84-Blackboard%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>Blackboard架构模式对还未找到确定解决策略的问题很有帮助。在Blackboard模式中，多个专业子系统通过集思广益，获得可能的部分解或近似解。</p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>未找到或找不到确定解决之道的不成熟领域。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Blackboard模式解决没有可行而确定的解决方案将原始数据转换为高级数据结构(如图表或英语词组)。存在这种问题的领域包括视觉识别、图像识别、语音识别和监视等。这种问题具有如下特点：可分解成多个子问题，但每个子问题都属于不同的专业领域。<br>对于这种问题，影响其解决方案的作用力如下。</p>
<ul>
<li>不可能在合理的时间内遍历整个解空间。</li>
<li>鉴于领域不成熟，可能需要对同一个子任务尝试不同的算法。</li>
<li>子问题的算法各不相同。</li>
<li>输入、中间结果和最终结果的表示方式各不相同，而不同算法是根据不同范式实现的。</li>
<li>一个算法通常使用另一个算法的结果。</li>
<li>涉及不可靠的数据和近似解。</li>
<li>算法的执行顺序不确定时还可能要求支持并行性。</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>Blackboard架构背后的理念是，一系列独立的程序携手合作，致力于处理同一个数据结构。<br>在解决问题的过程中，系统通过合并、修正或否决部分解来完成工作。每个部分解都针对一个子问题，是这个子问题的最终解在特定阶段的表现形式。所有的可能解构成解空间，并被组织成多个抽象层级，其中最低层为输入的内部表示，最高层包含系统要解决的整个问题的可能解。<br>之所以使用名称“黑板”(blackboard)，是因为它让人想起专家们站在黑板前协作解决问题的情形。专家们通常自行决定截下来该由谁来到黑板前，而在这里介绍的模式中，如果有多个程序都能提供帮助，将由调停者(moderator)组件决定这些程序的执行顺序。</p>
<p>###结构<br>对系统进行划分，使其包含一个黑板组件、一系列知识源以及一个控制组件。<br>黑板为中央数据存储区，解空间中的元素及控制数据都存储在这里。黑板提供了一个接口，让所有知识源都能够对其进行读写。<br>每个知识源都是一个独立的子系统，解决整个问题的特定方面。<br>控制组件运行一个监视黑板内容变化的循环，并决定接下来采取什么措施。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">控制-&gt;&gt;分段:execCondition</span><br><span class="line">控制-&gt;&gt;音节生成:execCondition</span><br><span class="line">控制-&gt;&gt;单词生成:execCondition</span><br><span class="line">分段-&gt;&gt;黑板:检查</span><br><span class="line">音节生成-&gt;&gt;黑板:检查</span><br><span class="line">单词生成-&gt;&gt;黑板:检查</span><br></pre></td></tr></table></figure>
<ol>
<li>定义问题。</li>
<li>定义问题的解空间。我们将解分为中间解和顶级解，还将其分为部分解和完整解。顶级解位于最高抽象层级，其他层级的解为中间解。完整解是整个问题的答案，而部分解是部分问题的答案。</li>
<li>将求解过程分为如下步骤：</li>
</ol>
<ul>
<li>定义如何将解转换为上一层级的解。</li>
<li>描绘如何作出同一抽象层级的推测。</li>
<li>详细说明如何从其他层级寻找证据，以证实做出的推测。</li>
<li>指出可利用什么样的知识将部分解空间排除在外。</li>
</ul>
<ol start="4">
<li>根据子任务将知识划分为专业知识源。</li>
<li>定义黑板的词表。</li>
<li>规范系统的控制机制。</li>
<li>实现知识源。</li>
</ol>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>面向模式的软件架构</tag>
      </tags>
  </entry>
  <entry>
    <title>面向模式的软件架构-Layers模式</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E9%9D%A2%E5%90%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84-Layers%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>Layers有助于将应用程序划分为多组子任务，其中每组子任务都位于特定抽象层。</p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>需要分解的大型系统</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>假设你要设计一个系统，其主要特征是需要同时解决高层问题和低层问题，且高层操作依赖于低层操作。在这个系统中，有些部分负责处理低层问题，如硬件陷阱、传感器输入等。在另一端可能有用户可见的功能(如游戏的界面)或高层策略(如电话计费)。在典型的通信过程中，请求从高层向低层传输，而响应、到来的数据及事件通知沿相反的方向传输。</p>
<hr>
<p>在这种情况下，需要平衡下述作用力。</p>
<ol>
<li>以后修改源代码不会波及整个系统。</li>
<li>接口稳定，甚至遵守标准组织制定的标准。</li>
<li>系统的各个部分都可更换。</li>
<li>未来可能需要打造其他系统，这些系统与当前设计的系统面临着相同的低层问题。</li>
<li>应将类似的职责编组，让系统更容易理解和维护。</li>
<li>根本没有所有的标准组件粒度。</li>
<li>复杂的组件需要进一步分解。</li>
<li>跨越组件边界可能影响性能，例如，必须跨越多个组件边界传输大量数据时。</li>
<li>系统将由一个程序员团队打造，因此分工必须明确。</li>
</ol>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>在结构方面，Layers模式的主要特征是，第J+1层只使用第J层的服务，层之间没有其他直接依赖关系。这种结构类似于栈，每层都将下面的各层保护起来，禁止上面的层直接访问它们。<br>|客户端|<br>|-|<br>|第N层|<br>|第N-1层|<br>|…|<br>|第1层|</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol>
<li><p>定义将任务划分到不同层的抽象准则。该准则通常是离平台的概念距离。<br>在真正的软件开发中，大家通常结合使用多种抽象准则。例如，根据离硬件的距离划分较低的层，按概念复杂度划分较高的层。<br>例如，<br>||<br>|–|<br>|用户可以看到的元素|<br>|具体的应用程序模块|<br>|通用服务层|<br>|操作系统接口层|<br>|操作系统|<br>|硬件|</p>
</li>
<li><p>根据抽象准则确定抽象层级数。层数太多可能带来不必要的开销，层数太少又可能导致结构不清晰。</p>
</li>
<li>给每层命名并分派任务。最高层的任务就是整个系统要完成的任务，由客户指定。其他各层的任务是辅佐上一层。</li>
<li>规范服务。最重要的实现原则是相邻界限分明，即任何组件都不跨越多层。</li>
<li>完善层次划分。反复执行第1～4步。如果不考虑抽象准则导致的层及其服务，通常无法准确地定义抽象准则。另外，先定义组件和服务，再根据它们之间的使用关系拼凑出分层结构的做法通常是错误的。由于这样的结构没有反映固有的分层原则，维护系统时很可能破坏原有的架构。例如，新组件可能使用多层提供的服务，违背严格分层的策略。<br>解决之道是反复执行前4步，直到分层结构自然而稳定。</li>
<li>规范每层的接口。如果对第J+1层来说，第J层应该算是“黑盒”，就应设计一个统一接口，该接口提供第J层的所有服务，还可能将其封装到一个Facade对象中。</li>
<li>确定各层的结构。传统上，重点是确保层间关系合理，而各层内部却随心所欲，其结果是混乱不堪。对于复杂的层，应将其划分为多个组件，进行这种划分时粒度更细的模式可提供帮助。</li>
<li>规范相邻层之间的通信。在层间通信方面，最常用的机制是推模型:第J层调用第J-1层的服务时，随服务调用一起传递所需的信息。与这种模型相反的是拉模型，指的是下层根据自己的判断从上层那取回信息。然而，拉模型可能增加当前层对上一层的依赖关系，要避免拉模型导致的下层对上层的依赖，可使用回调。</li>
<li>将相邻层解耦。通常上一层知道下一层，但下一层不知道其用户的身份。这意味着只存在单向耦合:修改第J层时，不用考虑第J+1层，条件是被修改的服务的接口和语义保持不变。<br>为支持自下而上的通信，可使用回调，并保留自上而下的单向耦合。使用回调时，上层向下层注册回调函数。在下层向上层发送的事件固定时，这种方式特别有效。<br>还可在一定程度上降低上层对下层的依赖，根据接口编写上层的代码，让上层不依赖于下层的具体实现。<strong>这里由主程序负责在层之间建立“连接”，但这种工作通常由连接管理组件统一管理。</strong><br>对于需要同时向上和向下传递消息的通信栈，显示地将下层关联到上层通常更佳。</li>
<li>制定错误处理策略。对分层架构而言，处理错误的代价可能非常高，无论从处理时间还是编程工作量的角度来说都如此。错误发生后，要么在当前层进行处理，要么转给上一层。如果采用第二种做法，当前层必须将错误转换为上一层能够明白的错误描述。<strong>一般说来，应尽可能在当前层处理错误，以免高层包含大量处理众多不同错误的代码。</strong></li>
</ol>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>优点</p>
<ol>
<li>各层可重用</li>
<li>支持标准化。一个著名的标准化接口是POSIX编程接口。</li>
<li>限制了依赖关系的范围。</li>
<li>可更换性。<br>缺点</li>
<li>行为变化可能引发雪崩效应。一层的行为发生变化可能引发严重的问题。如果为完成局部调整，必须对很多层做大量修改，那么分层就成了缺点。</li>
<li>效率低下。</li>
<li>不必要的工作。</li>
<li>难以确定正确的层次粒度。</li>
</ol>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>面向模式的软件架构</tag>
      </tags>
  </entry>
  <entry>
    <title>面向模式的软件架构-Pipes and Filters模式</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E9%9D%A2%E5%90%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84-Pipes%20and%20Filters%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>架构模式Pipes and Filters提供的结构适合用于处理数据流的系统。每个处理步骤封装在一个过滤器组件中，数据通过相邻过滤器之间的管道传输。通过重组过滤器，可打造多个相关的系统组。</p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>处理数据流</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>假设要打造的系统必须对输入数据进行处理或转换，以单个组件的方式实现这种系统可能不可行，原因有多个：系统必须由多名开发人员打造；整个系统要完成的任务分多个处理阶段；需求很可能发生变化。<br>因此，需要提供灵活性，以便能够更换处理步骤或调整处理顺序。提供这样的灵活性后，便可使用既有处理组件打造出一些列系统。设计系统时，必须考虑如下作用力。</p>
<ul>
<li>以后可通过更换或重组处理步骤来改进系统。</li>
<li>相比大型组件，在其他环境中重用小型处理步骤更容易。</li>
<li>不相邻的处理步骤不共享消息。</li>
<li>存在不同的输入数据源，如网络连接和提供温度的硬件传感器。</li>
<li>最终结果能够以各种方式和存储。</li>
<li>如果要求用户将中间结果存储到文件中，供以后进一步处理，将很容易出错。</li>
<li>应避免同时执行多个处理步骤，如并行或半并行地执行这些步骤。</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>架构模式Pipes and Filters将系统面临的任务分为多个一次执行的处理步骤。这些步骤通过在系统中传输的数据相关联：一个步骤的输出是下一个步骤的输入。每个处理步骤都由过滤器组件实现。过滤器一边使用数据一边提供数据，而不是等到获得所有输入后才生成输出。这降低了延迟，实现了真正的并行处理。数据源、过滤器、数据接收器通过管道依次相连，每条管道都在相邻处理步骤之间传输数据。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>过滤器组件式流水线的处理单元，负责充实、提炼或转换输入数据。<br>过滤器操作可由多种事件触发：</p>
<ul>
<li>下一个流水线元素从过滤器拉去输出。(被动过滤器)</li>
<li>前一个流水线元素向过滤器推送输入。(被动过滤器)</li>
<li>过滤器不间断地循环，从流水线上游拉去输入，并向下游推送输出。(主动过滤器)</li>
</ul>
<p>管道指的是过滤器之间、数据源和第一个过滤器之间以及最后一个过滤器和数据接收器之间的连接。<strong>将两个主动过滤器组件相连时，管道负责让它们同步，这是使用先进先出缓冲区实现的。被动过滤器与主动过滤器相连时，可这样实现管道：由主动过滤器直接调用被动过滤器，但直接调用增加了重组过滤器的难度。</strong></p>
<p>数据源指的是系统输入，提供结构或类型相同的数据序列，如包含文本行的文件或提供数字序列的传感器。</p>
<p>数据接收器从流水线末端收集结果，分主动接收器和被动数据接收器。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Pipes and Filters架构实现起来很简单。可将系统服务(如消息队列或UNIX管道)用作管道连接，也可采取其他方式，如直接调用。</p>
<ol>
<li>将系统要完成的任务划分为一系列处理阶段。</li>
<li>定义沿管道传递的数据的格式。</li>
<li>确定如何实现每条管道连接。</li>
<li>设计并实现过滤器。</li>
<li>实际错误处理机制。UNIX为错误消息定义了专用输出通道stderr。过滤器并行运行时，单个错误通道可能包含来自不同组件的错误消息，这即不明显又无法预测。</li>
<li>搭建处理流水线。</li>
</ol>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>优点：</p>
<ol>
<li>不需要中间文件，但也可以使用。</li>
<li>可更换过滤器。</li>
<li>可重组过滤器</li>
<li>可重用过滤器组件</li>
<li>可快速创建流水线原型。</li>
<li>效率因并行处理得以提高。</li>
</ol>
<p>缺点：</p>
<ol>
<li>共享状态信息的开销高昂或缺乏灵活性。</li>
<li>通过并行处理提高效率的初衷常常成为泡影。</li>
<li>数据转换开销。</li>
<li>错误处理。</li>
</ol>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>面向模式的软件架构</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动设计-模型和实现</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>当开发人员开始实现应用程序的时候，他们发现彼此纠缠的关系(模型)根本无法转换成事务完整性操作中的可存储、可检索的单元(代码)。基于概念的对象不能够成为他们设计的基础。</p>
<h2 id="模型驱动设计"><a href="#模型驱动设计" class="headerlink" title="模型驱动设计"></a>模型驱动设计</h2><p>领域驱动设计提倡一个模型不仅仅能够帮助早期的分析人员，并且可以作为设计的基础。这种方法要求对代码有着重要的暗示作用。不太明显的一点就是领域驱动设计需要一种不同的建模方法。<br>如果一个设计，或者它的核心部分，不能够映射到领域模型上，那么这个模型是没有价值的，软件的正确性也是值得怀疑的。同时，模型与设计功能之间复杂的映射常常难于理解，并且在实践中，当设计发生变化时也不可能维护。在分析与设计之间存在致命的隔阂，从任何（分析和设计）活动中获得的知识都无法提供给另一方。</p>
<p>应该设计出能够非常精确地反映领域模型的部分软件系统，这样映射就会明显。如同您尽力让模型更深层次地反映领域一样，再次研究模型并修改，使得它能够让软件更加自然的实现。需要这样的单个模型，除了要支持一种健壮的通用语言之外，还要很好的完成这两个目的。<br>从模型中得到的术语可以用于设计和职责的基本分配。代码成为模型的表达形式，因此对代码的改变可能也变成对模型的一种改变。它的影响将相应波及到项目中的其他活动。<br>要将实现与模型严格的绑定在一起，通常需要支持建模泛型的软件开发工具和语言，例如面向对象的编程。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>领域驱动设计</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动设计-通用模型</title>
    <url>/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="通用模型"><a href="#通用模型" class="headerlink" title="通用模型"></a>通用模型</h2><p>要将模型作为语言的骨干。团队在所有的交流与代码中都应该练习使用这种语言。在图、文档编写，尤其是发表意见过程中都使用相同的语言。<br>通过用替代表达方法进行实验来消除实际中遇到的困难，它们反映了替代模型的含义。然后按照新的模型重新进行编码，并对类、方法和模块进行重命名。在交谈中辨明术语中含糊的词义，就像我们对普通的词语意义达成一致意见那样。<br>要意识到通用语言中的变化也是模型中的变化。<br>领域专家应该排除掉传达领域意思时不易使用或不适当的术语或结构；开发人员应该注意防止可能导致设计失败的模糊性或不一致性。</p>
<h3 id="利用对话改进模型"><a href="#利用对话改进模型" class="headerlink" title="利用对话改进模型"></a>利用对话改进模型</h3><p>结合模型来讨论系统。使用模型的元素和元素之间的交互来大声描述场景，按照模型允许的方式把概念组合在一起。找到更简单的方式来说出要表达的内容，然后将这些意见应用到图形和代码中。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>领域驱动设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Fiddler-模拟低速网络环境</title>
    <url>/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95/Fiddler-%E6%A8%A1%E6%8B%9F%E4%BD%8E%E9%80%9F%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>1  下载</p>
<p>Fiddler:<a href="http://www.telerik.com/fiddler" target="_blank" rel="noopener">http://www.telerik.com/fiddler</a></p>
<p>.NET Framework 4:<a href="http://www.microsoft.com/zh-cn/download/confirmation.aspx?id=17718" target="_blank" rel="noopener">http://www.microsoft.com/zh-cn/download/confirmation.aspx?id=17718</a><br>2  简介</p>
<p>Fiddler是一个http协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点，查看所有的“进出”Fiddler的数据（指cookie,html,js,css等文件，这些都可以让你胡乱修改的意思）。 Fiddler 要比其他的网络调试器要更加简单，因为它不仅仅暴露http通讯还提供了一个用户友好的格式。<br>3  模拟低速网络环境</p>
<p>Rules → Performances → Simulate Modem Speeds</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title>Jmeter-介绍</title>
    <url>/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95/Jmeter-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>准备JMeter</p>
<p>安装插件</p>
<p>部署Master Slave</p>
<p>./jmeter.sh -n -t Ademo_cp.jmx -l jtl.jtl -j log.log -R B的IP</p>
<p>jmeter -n -t script.jmx -l jtl.jtl -R 127.0.0.1</p>
<p>slave启动命令：./jmeter-server -Djava.rmi.server.hostname=B的IP</p>
<p>master启动命令：</p>
<p>server:</p>
<p>jmeter-server</p>
<p>收集机器性能</p>
<p>Servers Performance Monitoring</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title>LoadRunner-介绍</title>
    <url>/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95/LoadRunner-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<ul>
<li>基于底层的通信协议</li>
<li>覆盖广泛（将近50种协议）</li>
<li>无代理监测</li>
<li>深层诊断</li>
<li>深层挖据客户端到web服务，web服务到应用服务，应用服务到数据库服务的各个时间段响应时间。</li>
</ul>
<h3 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h3><p>压力测试<br>容量规划<br>硬件选型</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ol>
<li>虚拟用户生成器</li>
<li>Controller</li>
<li>Analysis</li>
</ol>
<h3 id="操作流程："><a href="#操作流程：" class="headerlink" title="操作流程："></a>操作流程：</h3><ol>
<li>Vugen：生成脚本</li>
<li>Controller：起到调度压力测试并管理监控器</li>
<li>Load Generators：模拟大量真实用户的产生</li>
<li>性能监控器(利用系统已有的软件实现无代理windows performance等等)</li>
<li>Analysis</li>
</ol>
<h3 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h3><h4 id="1-测试计划"><a href="#1-测试计划" class="headerlink" title="1. 测试计划"></a>1. 测试计划</h4><p>业务流程<br>输入<br>环境(监控)</p>
<h4 id="2-创建脚本"><a href="#2-创建脚本" class="headerlink" title="2. 创建脚本"></a>2. 创建脚本</h4><p>录制</p>
<blockquote>
<p>建议：录制-&gt;基于URL的脚本</p>
</blockquote>
<p>回放<br>增强功能</p>
<ul>
<li>事务（持续时间）</li>
<li>参数化：唯一性；数据依赖；日期约束；数据缓存(绕过数据库等缓存机制，测试更具真实性)</li>
<li>验证：文本检查(web_reg_find)</li>
<li>关联：<br>比如SessionID<br>录制时12345，回放时就变成45678，导致服务器认为是不同的用户<br>解决方案<br>将sessionID关联起来，保存到一个临时参数中，需要时读取出来<h4 id="3-设计场景"><a href="#3-设计场景" class="headerlink" title="3. 设计场景"></a>3. 设计场景</h4>1.手工场景<br>2.目标场景<h4 id="4-执行场景"><a href="#4-执行场景" class="headerlink" title="4. 执行场景"></a>4. 执行场景</h4>单个场景<br>混合类场景</li>
<li>第一次：3～5个虚拟用户<br>增强日志<br>无思考时间</li>
<li>第二次：20%<br>标准日志<br>5秒思考时间</li>
<li>第三次：100%<br>出错日志<br>思考时间随机</li>
<li>第四次：100%++<h4 id="5-收集分析"><a href="#5-收集分析" class="headerlink" title="5. 收集分析"></a>5. 收集分析</h4><h4 id="6-继续执行第4步"><a href="#6-继续执行第4步" class="headerlink" title="6. 继续执行第4步"></a>6. 继续执行第4步</h4></li>
</ul>
<p>LoadRunner自带测试Demo账号密码<br>账号:jojo<br>密码:bean</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title>Selenium-介绍</title>
    <url>/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95/Selenium-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>Selenium<br>IE-Driver<br>Selenium RC</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title>sikulix</title>
    <url>/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95/sikulix/</url>
    <content><![CDATA[<p>MIT的研究人员设计了一种新颖的图形脚本语言Sikuli</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title>不懂带人就当不好经理-懂激励</title>
    <url>/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86/%E4%B8%8D%E6%87%82%E5%B8%A6%E4%BA%BA%E5%B0%B1%E5%BD%93%E4%B8%8D%E5%A5%BD%E7%BB%8F%E7%90%86-%E6%87%82%E6%BF%80%E5%8A%B1/</url>
    <content><![CDATA[<h2 id="人性的假设"><a href="#人性的假设" class="headerlink" title="人性的假设"></a>人性的假设</h2><ol>
<li>经济人假设。人是经济的产物，人的一切活动都是为了获得经济报酬和物质生活的满足。X理论。</li>
<li>社会人假设。人是社会的产物，人在社会主流中追求人际关系的和谐，注重心理和情感的满足，并为此付出个人的努力。</li>
<li>自我实现人假设。人们力求最大限度地将自己的潜能充分发挥出来，只有在工作中将自己的才能表现出来，人才会感到最大的满足。Y理论。</li>
<li>复杂人假设。人是很复杂的，人的需要与潜在欲望是多种多样的，而这些需要的内容和结构也不断地随人的年龄和发展阶段的变化而变化，并因人的境遇差异而不同。</li>
</ol>
<h2 id="有效地激励他人"><a href="#有效地激励他人" class="headerlink" title="有效地激励他人"></a>有效地激励他人</h2><ol>
<li>充分肯定下属的出色工作</li>
<li>让下属承担富有挑战性的工作</li>
<li>恢复下属的自信心。首先要有一个紧迫的环境，其次要有一个化险为夷，度过危机的结果。</li>
<li>在工作中多褒少贬。让下属在犯了错误后做了错事之后尽快地了解自己的错误而不是打击他们的自信心，给予他们时间去争取下一步的审理。</li>
<li>不要无谓地为难你的下属。正确地运用批评的武器也是一种激励手段。</li>
<li>让你的下属有归属感。一个有着主人翁意识的员工，一定是深爱着自己的工作、自己的部门、自己的公司，对组织有着巨大的献身精神的人。</li>
</ol>
<h2 id="给员工以精神上的满足"><a href="#给员工以精神上的满足" class="headerlink" title="给员工以精神上的满足"></a>给员工以精神上的满足</h2><ol>
<li>倾听式激励</li>
<li>赞美式激励</li>
<li>参与式激励</li>
<li>内部升迁式激励</li>
<li>感谢太太式激励</li>
<li>挑战式激励</li>
<li>工作轮换式激励</li>
<li>工作丰富化式激励</li>
</ol>
<h2 id="最佳激励组合"><a href="#最佳激励组合" class="headerlink" title="最佳激励组合"></a>最佳激励组合</h2><ol>
<li>按照工作业绩进行分类激励</li>
<li>按照个性类型选择合适的激励方法</li>
</ol>
<h2 id="最佳激励典范"><a href="#最佳激励典范" class="headerlink" title="最佳激励典范"></a>最佳激励典范</h2><ol>
<li>按照员工喜欢的方式激励他们</li>
<li>在公司内实施良性竞争</li>
<li>不要“只让一人独得”的激励方式。不应该鼓励手下员工互相竞争，他不能促进合作，相反却很容易使员工互相保密，拒绝向别人提供帮助。</li>
</ol>
<h2 id="成功激励的28条经验"><a href="#成功激励的28条经验" class="headerlink" title="成功激励的28条经验"></a>成功激励的28条经验</h2><ol>
<li>尝试利用自发的社交和体育活动来激励员工</li>
<li>利用小组竞争刺激士气</li>
<li>将管理者的数目减至最低</li>
<li>确信你给的奖励是锦上添花，而非理所应得的薪资</li>
<li>询问你的员工，工作中的每一个改变是否有助于激励他们</li>
<li>尽可能弹性地利用金钱奖励员工，以便激励他们发挥最大的潜能</li>
<li>尽量让员工知道最新消息，搞不清楚状况只会令员工士气溃散</li>
<li>花时间去和员工聊天，而不只是和员工道声早安</li>
<li>对员工有影响的决定，不妨询问他们的意见如何</li>
<li>小心办公室的政治阴谋，并且以身作则，绝不加入</li>
<li>尽早提拔有能力、年轻一点的员工</li>
<li>即使一些目标未达成，也要奖励成效卓越的工作表现</li>
<li>当你注意到员工的错误时，必须严格且公平，而不是一味地责怪</li>
<li>给一位在过去一年里一致没有任务的员工分派任务</li>
<li>告知员工他们的想法被采用了，以及成功率为多少</li>
<li>考虑所有老资格员工提出的意见</li>
<li>尽可能给员工创造提意见的机会</li>
<li>将目标全盘告知员工，可以使他们表现的更好</li>
<li>初次见到新成员时，要让他们觉得自己很受欢迎</li>
<li>激励每个人的野心，野心能引导成就</li>
<li>不要等到年度评鉴时，才和员工讨论他们的表现</li>
<li>让员工告诉你降低他们工作动机的原因，注意要认真聆听</li>
<li>不管多么不受欢迎，一定要强调改革会给员工带来利益</li>
<li>在失去有价值的团队成员前，尽量利用各种方式加以挽留</li>
<li>提供小型、定期的训练，而非长时间的课程</li>
<li>旁听训练课程，以确保高质量</li>
<li>如果有个建议被采纳了，就让提议人来完成这个建议</li>
<li>利用证书和刻上姓名的礼物，标识员工的成就</li>
</ol>
]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>不懂带人就当不好经理</tag>
      </tags>
  </entry>
  <entry>
    <title>信息系统项目管理师-介绍</title>
    <url>/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><blockquote>
<p>项目是用有限的资源、有限的时间为特定客户完成特定目标的一次性工作。</p>
</blockquote>
<p>资源：完成项目所需要的人、财、物。<br>时间：明确的开始和结束时间。<br>客户：提供资金、确定需求并拥有项目成果的组织或个人。<br>目标：满足要求的产品、服务和成果。</p>
<p>项目的特点：临时性、独特性和渐进性。</p>
<ol>
<li>临时性<br>临时性是指每一个项目都有确定的开始和结束。<br>此外，临时性一般不适用于项目所产生的产品、服务或成果。大多数项目是为了得到持久的结果。</li>
<li>独特的产品、服务或成果<br>独特是项目可交付成果的一种重要特征，例如，办公楼已经建造了成千上万做，单其中每一座都是独特的-不同的业主、不同的设计、不同的地点、不同的承建人等。</li>
<li>渐进明细<br>渐进明细是项目逐步完成的过程。渐进明细意味着分步、连续的积累。例如，在项目的早期项目范围的说明是粗略的，随着项目团队对目标和可交付成果的理解更完整，更深入时，项目的范围也就更具体。<br>项目规格说明书的渐进明细务必要与项目范围的恰当定义谨慎地协调起来。<strong>如果项目范围，即需要完成的任务规定的恰如其分，则在规格说明书的渐进明细过程中，项目范围仍应保持控制。</strong></li>
</ol>
<h3 id="信息项目的特点"><a href="#信息项目的特点" class="headerlink" title="信息项目的特点"></a>信息项目的特点</h3><blockquote>
<p>信息系统项目是根据用户需求，优选各种技术和产品，进行设计开发，将各个分离的“信息孤岛”连接成为一个完整、可靠、经济和有效的整体，并使之能彼此协调工作，发挥整体效益，达到整体优化的目的。</p>
</blockquote>
<p>现在的信息系统已不只是为用户提供信息共享的功能，而是要整合各种资源，在满足用户需求的基础上，提高用户的投资效率、管理效率和经营效率，最终<strong>帮助用户获取更大的利润</strong>。</p>
<p>信息系统是以信息的集成为目标，功能的集成为结构，平台的集成为基础，人的集成为保证。不仅要在技术上实现客户的需求，还要对客户投资的实用性和有效性进行分析。开发商要向客户提供具有针对性的整合应用解决方案，这就要求开发商除了要有IT方面的技术外，必须要有较丰富的行业经验。</p>
<h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><blockquote>
<p>项目管理就是把各种知识、技能、手段和技术应用于项目活动之中，以达到项目的要求。</p>
</blockquote>
<p>管理一个项目包括：</p>
<ul>
<li>识别要求。</li>
<li>确定清楚而又能够实现的目标。</li>
<li>权衡质量、范围、时间和成本方面互不相让的要求，使技术规定说明书、计划和方法适用于各种各样利害关系者的不同需求与期望。</li>
</ul>
<p>有效的管理要求项目管理组至少能理解和使用以下5方面的专门知识领域：</p>
<ul>
<li>项目管理知识体系。</li>
<li>应用领域的知识、标准和规定。<ul>
<li>标准是“一直同意建立并由公认的机构批准的文件，该团队提供通用的和可重复使用的规则、指南、活动或其结果的特征，目的是在特定的背景下达到最佳的秩序。</li>
<li>规则是政府强制的要求，它制定了产品、过程或服务的特征。建筑法规是规则的一个例子。</li>
</ul>
</li>
<li>项目环境知识。</li>
<li>通用的管理知识和技能。</li>
<li>软技能(处理人际关系技能)。</li>
</ul>
<p>国际化组织以PMBOK(项目管理的知识体系)为框架，制定了ISO10006关于项目管理的标准。<br>包括，<br>动态的项目管理5大过程</p>
<ul>
<li>启动过程组。</li>
<li>规划过程组。</li>
<li>执行过程组。</li>
<li>监控过程组。</li>
<li>收尾过程组。</li>
</ul>
<p>静态的项目管理9大知识领域</p>
<ul>
<li>范围管理。</li>
<li>时间管理。</li>
<li>成本管理。</li>
<li>质量管理。</li>
<li>人力资源管理。</li>
<li>沟通管理。</li>
<li>采购管理。</li>
<li>风险管理。</li>
<li>整体管理。</li>
</ul>
<h3 id="项目管理高级话题"><a href="#项目管理高级话题" class="headerlink" title="项目管理高级话题"></a>项目管理高级话题</h3><p>在更广泛的背景下，项目管理包括相关的工作如大项目和项目组合管理。它们都应用了一些基本技能以管理项目，只是执行的层面不同。通常，战略计划、项目组合、大项目、项目、子项目是有层次的，大项目包含几个相关的项目，并共同为战略计划的完成做出贡献。</p>
<h3 id="项目管理的产生和发展"><a href="#项目管理的产生和发展" class="headerlink" title="项目管理的产生和发展"></a>项目管理的产生和发展</h3><h4 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h4><ol>
<li>适应现代产品的创新速度。</li>
<li>适应现代的复杂项目系统。</li>
<li>适应以用户满意为核心的服务理念。<h3 id="发展的方向"><a href="#发展的方向" class="headerlink" title="发展的方向"></a>发展的方向</h3></li>
<li>向学科化方向发展。</li>
<li>向实用化方向发展。</li>
</ol>
]]></content>
      <categories>
        <category>管理</category>
      </categories>
  </entry>
  <entry>
    <title>战略管理</title>
    <url>/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86/%E6%88%98%E7%95%A5%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>管理</category>
      </categories>
  </entry>
  <entry>
    <title>敏捷软件开发Scrum</title>
    <url>/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91Scrum/</url>
    <content><![CDATA[<p>个体和互动高于流程和工具<br>工作的软件高于详尽的文档<br>客户合作高于合同谈判<br>响应变化高于遵循计划<br>也就是说，尽管右项有其价值，我们更重视左项的价值。</p>
]]></content>
      <categories>
        <category>管理</category>
      </categories>
  </entry>
  <entry>
    <title>管理学-激励</title>
    <url>/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86%E5%AD%A6-%E6%BF%80%E5%8A%B1/</url>
    <content><![CDATA[<p>有效的管理者能够使员工尽最大努力认真工作，了解员工如何受到激励以及为什么会被激励，并且选择最合适的激励方式来满足员工的需求。<br>动机指一种过程，它体现了个体为实现目标而付出努力的强度、方向和坚持性。</p>
<h2 id="早期的动机理论"><a href="#早期的动机理论" class="headerlink" title="早期的动机理论"></a>早期的动机理论</h2><h3 id="马斯洛的需求层次理论"><a href="#马斯洛的需求层次理论" class="headerlink" title="马斯洛的需求层次理论"></a>马斯洛的需求层次理论</h3><p>每个人都有五个层次的需求</p>
<ol>
<li>生理需求：人们对食物、水、住所、性以及其他生理方面的需要。</li>
<li>安全需求：人们在生理上的需求得到保证的同时，保护自己免受生理和情感伤害的需要。</li>
<li>社会需求：人们在爱情、归属、接纳以及友谊方面的需要。</li>
<li>尊重需求：内部尊重因素包括对自尊、自主和成就感的需要，外部尊重因素包括对地位、认可或被关注的需要。</li>
<li>自我实现需求：人们对自我发展、自我价值实现和自我理想实现的需要；是追求个人能力极限的动力。</li>
</ol>
<p>管理者运用马斯洛的需求层次理论激励员工为实现自身需求而努力工作。但该理论也指出，一旦员工的某种需求得到实质性的满足，这种需求就不再具有激励作用。因此，需要了解目前处于哪个需求层次，然后重点满足这个层次以及该层次以上的需求。</p>
<p>马斯洛的理论在20世纪六七十年代得到普遍认可，但他的理论缺乏实证研究的支持。</p>
<h3 id="麦格雷戈的X理论和Y理论"><a href="#麦格雷戈的X理论和Y理论" class="headerlink" title="麦格雷戈的X理论和Y理论"></a>麦格雷戈的X理论和Y理论</h3><ol>
<li>X理论：代表了一种消极的人性观点，认为员工没有雄心大志，不喜欢工作，只要有可能就会逃避责任，为了保证工作效果必须严格监控</li>
<li>Y理论：代表了一种积极的人性观点，认为员工喜欢工作，他们接受甚至主动寻求工作责任来自我激励和自我指导，把工作视为一种自然而然的活动。</li>
</ol>
<p>但是，没有证据来证明哪一种理论更有效，也没有办法证明Y理论是激励员工的唯一途径。</p>
<p>黄仁轩在抨击一个项目团队重复犯错的时候说，“你们真的那么烂吗？”，“如果你们确实很烂，那就赶快站起来说你们很烂”。他的话用经典的X理论来解释，意思就是如果你们需要帮助，就赶快说出来。</p>
<h3 id="赫茨伯格的双因素理论"><a href="#赫茨伯格的双因素理论" class="headerlink" title="赫茨伯格的双因素理论"></a>赫茨伯格的双因素理论</h3><p>内在因素与工作满意相关，而外在因素与工作不满意相关</p>
<table>
<thead>
<tr>
<th>激励因素</th>
<th>保健因素</th>
</tr>
</thead>
<tbody>
<tr>
<td>成就</td>
<td>监督</td>
</tr>
<tr>
<td>认可</td>
<td>公司政策</td>
</tr>
<tr>
<td>工作本身</td>
<td>与主管的关系</td>
</tr>
<tr>
<td>责任</td>
<td>工作条件</td>
</tr>
<tr>
<td>进步</td>
<td>薪水</td>
</tr>
<tr>
<td>成长</td>
<td>与同伴的关系</td>
</tr>
<tr>
<td></td>
<td>个人生活</td>
</tr>
<tr>
<td></td>
<td>与下属的关系</td>
</tr>
<tr>
<td></td>
<td>地位</td>
</tr>
<tr>
<td></td>
<td>稳定与保障</td>
</tr>
</tbody>
</table>
<p>赫茨伯格提出了二维连续体的存在：“满意”的对立面是“没有满意”，“不满意”的对立面是“没有不满意”。因此，试图在工作中消除不满意因素的管理者只能给工作场所带来和平，未必能够激励员工。要想真正激励员工努力工作，必须注重激励因素，这些内在因素才是增加员工满意度的依据。</p>
<p>赫茨伯格的理论在20世纪60年代中期到80年代初一直有着广泛的影响，对该理论的批评主要是针对操作程序和方法论方面。</p>
<h3 id="麦克莱兰的三种需要理论"><a href="#麦克莱兰的三种需要理论" class="headerlink" title="麦克莱兰的三种需要理论"></a>麦克莱兰的三种需要理论</h3><ol>
<li>成就需求：达到标准、追求卓越、获得成功的需求。</li>
<li>权利需求：想要是他人按照自己的指示以某种特定方式行事的需求。</li>
<li>归属需求：建立友好、亲密的人际关系的愿望。</li>
</ol>
<p>拥有高成就需求不一定就是好的管理者，因为高成就需求者专注于他们自己的成就，而优秀的管理者强调帮助他人完成目标。<br>最优秀的管理者往往拥有较高的权利需求和较低的归属需求。</p>
<h2 id="当代的动机理论"><a href="#当代的动机理论" class="headerlink" title="当代的动机理论"></a>当代的动机理论</h2><h3 id="目标设置理论"><a href="#目标设置理论" class="headerlink" title="目标设置理论"></a>目标设置理论</h3><p>目标设置理论认为，具体的工作目标会提高工作绩效，困难的目标一旦被员工接受，将会比容易的目标产生更高的工作绩效。</p>
<p>在你进行一项重大任务或者一次重要的班级项目汇报之前，老师是否鼓励过你“只要尽力而为就行”？这个模糊的说法“尽力而为”是什么意思？老师说过只有在班级项目汇报中得到93分，你这门功课才能得A，你的成绩是否会更高一些？目标设置理论的研究就是关注上述问题。</p>
<ol>
<li>努力实现某个目标是工作动机的一个主要来源。具体的、富有挑战性的目标是极为有效的激励力量。</li>
<li>如果员工有机会参与目标设置，他们是否会更努力工作？不一定。</li>
<li>如果员工在完成目标的过程中得到必要的反馈，他们会表现更佳。因为反馈能够帮助他们认清已做之事和想做之事之间的差别。同时，自我生成的反馈比起来自他人的反馈更具有激励作用。</li>
</ol>
<p>影响目标-绩效关系的因素</p>
<ol>
<li>反馈</li>
<li>个人对目标的承诺</li>
<li>足够的自我效能。员工认为自己能够完成某项任务的信念。面对困难时，自我效能低的员工会减少努力或者集体放弃，而自我效能高的员工会更加努力来迎接挑战。</li>
<li>民族文化。在北美国家，文化允许在合理的范围内，下属具有一定的独立性，他们可以自己设定具有挑战性的目标。</li>
</ol>
<p>工作目标的具体化、挑战性和反馈信息对员工的工作绩效都有显著影响。</p>
<h3 id="强化理论"><a href="#强化理论" class="headerlink" title="强化理论"></a>强化理论</h3><p>强化理论认为行为是其结果的函数。如果某种结果紧跟在某种行为之后立即出现，并且提高该行为未来重复的可能性，那么他就称为强化物。强化理论不考虑诸如目标、期望、需求等因素，而只关注个体采取某种行动后产生的结果。</p>
<p>例如，沃尔玛改进了小时工的奖金计划，提供出色客服的员工可以获得奖金奖励。奖金的分配取决商场业绩，而且每季度发放一次，从而使员工更频繁地获得奖励。公司的意图是，在员工完成工作目标是对他们进行奖励，以不断激励他们完成工作目标，从而强化他们的这些行为。</p>
<h3 id="工作设计理论"><a href="#工作设计理论" class="headerlink" title="工作设计理论"></a>工作设计理论</h3><p>由于管理者想要激励员工努力工作，因为我们需要寻找各种方法来设计具有激励作用的工作。</p>
<ol>
<li>工作扩大化。横向扩大工作范围。大多数工作扩大化努力仅关注增加工作任务的数量，其效果似乎并不尽人意。有人说，“以前我只有一项讨厌的任务要做，现在我有三项讨厌的工作任务要做了！”。也有研究显示，知识扩大化活动（扩大工作中使用的知识的范围）会对员工产生积极影响。</li>
<li>工作丰富化。纵向增加工作深度，即员工对于自己工作的控制程度。传统上认为应有管理者完成的某些工作任务现在授权给员工自己来完成。因此，工作丰富化使员工有更多的自由、独立性和责任来完成整项工作。</li>
</ol>
<h4 id="工作特征模型"><a href="#工作特征模型" class="headerlink" title="工作特征模型"></a>工作特征模型</h4><p>工作特征模型，为管理者设计具有激励作用的工作提供了一种有效框架。确定了五种核心工作维度，他们的相互关系以及他们对员工生产率、动机和满意度的影响。</p>
<ol>
<li>技能多样性。指一项工作需要从事多种活动从而使员工能够利用不同技能和才干的程度。</li>
<li>任务完整性。指一项工作需要完成一件完整的、可辨识的工作任务的程度。</li>
<li>任务重要性。指一项工作对他人生活和工作的实际影响程度。</li>
<li>工作自主性。指一项工作在安排工作内容、确定工作程序方面实际上给员工多大的自由度、独立权和决定权。</li>
<li>工作反馈。指员工在完成任务的过程中，可以获得关于自己工作绩效的直接而明确的信息的程度。</li>
</ol>
<img src="/管理/管理/管理学-激励/工作的特征模型.jpg" title="工作的特征模型">
<h4 id="工作再设计"><a href="#工作再设计" class="headerlink" title="工作再设计"></a>工作再设计</h4><ol>
<li>合并任务。管理者应该把零碎的任务组合成新的、范围更广的工作模块，以增强技能多样性和任务完整性。</li>
<li>形成自然的工作单元。管理者应该把工作设计成完整的、有意义的整体，以增强员工对工作的“拥有感”。</li>
<li>建立客户关系。管理者应当建立员工与客户之间的直接联系，以提高技能多样性和工作自主性，并增加反馈信息。</li>
<li>纵向扩展工作。把过去只有管理者才承担的责任和控制权授予员工，能够增强员工的自主性。</li>
<li>开通反馈渠道。直接的反馈可以让员工了解自己在工作中表现如何，以及自己的工作绩效是否正在改进。</li>
</ol>
<img src="/管理/管理/管理学-激励/工作再设计的指导原则.jpg" title="工作再设计的指导原则">
<h4 id="关于工作设计的两个新兴观点"><a href="#关于工作设计的两个新兴观点" class="headerlink" title="关于工作设计的两个新兴观点"></a>关于工作设计的两个新兴观点</h4><ol>
<li>关系取向的工作设计观。在今天的工作中，员工与公司同事以及公司内外其他人具有更多的沟通交流和相互依赖。管理者需要研究员工关系的重要因素，例如进入组织的途径、组织对员工社会需求的支持程度、组织外部的互动类型、工作任务的相互依赖程度，以及人际反馈。</li>
<li>主动的工作涉及观。员工更多地参与对其工作有影响的决策和行动。</li>
</ol>
<h3 id="公平理论"><a href="#公平理论" class="headerlink" title="公平理论"></a>公平理论</h3><ol>
<li>自己从工作中得到的和付出的进行比较</li>
<li>自己的付出-所得比与其他相关人员的付出-所得比进行比较</li>
</ol>
<p>不公平感出现后，员工会试图采取行动来改变它。其结果可能是生产率下降或提高，产品质量下降或提高，更高的缺勤率，或者自愿离职。</p>
<p>管理者应该考虑把报酬分配的决策过程公开化，遵循一致、无偏见的程序，以及采取类似措施，以提高员工的程序公平感。通过增强程序公平感，即使员工对薪水、晋升或其他个人结果感到不满，他们也可能以积极的态度对待上司和组织。</p>
<h3 id="期望理论"><a href="#期望理论" class="headerlink" title="期望理论"></a>期望理论</h3><p>期望理论认为，如果个体语气某种行为会带来某种特定的结构，而且该结果对自己具有吸引力，那么该个体往往会采取种种行为。</p>
<ol>
<li>期望，努力-绩效联系</li>
<li>手段，绩效-奖励联系</li>
<li>效价，奖励的吸引力</li>
</ol>
<p>我必须付出多大努力才能达到某个特定的业绩水平，我确实能够达到这个水平吗？达到这个业绩水平之后我会得到什么奖励？这种奖励对我有多大吸引力，它是否有助于我实现自己的目标？在某个特定时间点上，你是否受到激励去付出努力，取决于你的目标是什么以及这个特定的绩效水平是不是实现你这些目标的必要条件。</p>
<p>管理者必须明白员工为什么认为某些特定的奖励有吸引力或者没有吸引力，我们希望以员工重视的东西来奖励他们。员工是否知道组织对他们的期望是什么以及组织会如何评估他们。期望理论关注人们的感知，真实情况是无关紧要的。个体对工作绩效、奖励和目标的感知（而不是客观情况本身）决定了他的动机（努力程度）。</p>
<h2 id="当代动机理论的整合"><a href="#当代动机理论的整合" class="headerlink" title="当代动机理论的整合"></a>当代动机理论的整合</h2><img src="/管理/管理/管理学-激励/当代动机理论的整合.jpg" title="当代动机理论的整合">
<p>目标设置理论：目标-努力链，表明了目标对行为的指导作用</p>
<p>期望理论：期望理论认为，如果个体认为努力与绩效之间，绩效与奖励之间，奖励与个人目标满足之间存在密切联系，他就会努力工作。每种联系之间又受到一些因素的影响</p>
<p>公平理论：个体的绩效水平不仅取决于自己的努力，而且取决于自己完成工作的能力水平，以及组织中有没有一个公正、客观的绩效评估系统</p>
<p>需求理论：当个体由于工作绩效而获得的奖励满足了与其个人目标相一致的主导需求，就会表现出与需求满足程度相对应的工作积极性。</p>
<p>需求理论：高成就需求者受到的激励不是来自组织对他的绩效评估或组织提供的奖励，对他来说，努力与个人目标之间直接相连。只要他们从事的工作能够提供责任感、信息反馈、中等程度的冒险。这些人并不关心努力-绩效，绩效-奖励以及奖励-目标的联系。</p>
<p>强化理论：通过组织提供的奖励对个人绩效的强化而来如果管理者设计的奖励系统在员工看来是致力于奖励出色的工作绩效，那么这种奖励会进一步强化和激励良好的绩效水平。个人经常会将自己的努力与得到的比例与其他相关人员进行比较，若觉得不公平，则会影响个体的努力程度。</p>
<p>工作设计理论：工作设计从两方面影响工作动机<br>1.个人绩效。工作本身的特征会激发个体的工作积极性。这些工作增强了努力-绩效之间的联系。<br>2.个人目标。增强员工对自己工作中的核心因素的控制。当工作可以提供自主性、信息反馈或类似特征时，将有助于满足该员工的个人目标，因为他们希望对自己的工作拥有更高的控制权</p>
<h2 id="当代激励问题"><a href="#当代激励问题" class="headerlink" title="当代激励问题"></a>当代激励问题</h2><h3 id="在严峻的经济形势下激励员工"><a href="#在严峻的经济形势下激励员工" class="headerlink" title="在严峻的经济形势下激励员工"></a>在严峻的经济形势下激励员工</h3><p>随着工作条件的恶化，员工的工作信心、乐观情绪以及工作敬业度也迅速下降。管理者被迫采取一些不涉及金钱或者费用相对低廉的激励措施。</p>
<p>召开员工会议来保持沟通渠道公开并谋求员工对工作事项的投入；设置一个共同目标，以使每个人都专注其中；创造一种社区感，以使员工能够感受到管理者关心他们和他们的工作；向员工提供继续学习和发展的机会。</p>
<h3 id="管理跨文化激励"><a href="#管理跨文化激励" class="headerlink" title="管理跨文化激励"></a>管理跨文化激励</h3><p>当前大多数的动机理论是由美国人提出来的，而且主要是基于对美国人的研究。这些理论可能隐含着一个最明显的美国化特征：对个人主义和成就的显著强调。</p>
<h3 id="激励独特的员工队伍"><a href="#激励独特的员工队伍" class="headerlink" title="激励独特的员工队伍"></a>激励独特的员工队伍</h3><h4 id="激励多元化的员工队伍"><a href="#激励多元化的员工队伍" class="headerlink" title="激励多元化的员工队伍"></a>激励多元化的员工队伍</h4><p>对于年轻的员工来说，拥有独立性和体验不同经历的机会是非常重要的，但是，老员工可能会对高度结构化的工作机会更感兴趣。</p>
<h4 id="激励专业人员"><a href="#激励专业人员" class="headerlink" title="激励专业人员"></a>激励专业人员</h4><p>在专业人员中，金钱和晋升通常处于次位。相反，工作的挑战性常常被排在较高的位置。</p>
<h4 id="激励灵活就业员工"><a href="#激励灵活就业员工" class="headerlink" title="激励灵活就业员工"></a>激励灵活就业员工</h4><p>提供成为长期员工的机会。同时，临时员工和长期员工从事同样的工作，长期员工不但工资多而且享受福利待遇，那么临时工的绩效水平会受到影响。因此，让这些员工分开工作，或将他们之间的相互依赖程度降至最低，这样可能会帮助管理者减少潜在的问题。</p>
<h4 id="激励低技能并获得最低工作的员工"><a href="#激励低技能并获得最低工作的员工" class="headerlink" title="激励低技能并获得最低工作的员工"></a>激励低技能并获得最低工作的员工</h4><p>如果负责管理某个全部由缺乏技能且工资最低的工人组成的工作群体。管理者可以利用员工认可计划，以及口头表扬。</p>
<h3 id="设计合适的奖励制度"><a href="#设计合适的奖励制度" class="headerlink" title="设计合适的奖励制度"></a>设计合适的奖励制度</h3><h4 id="账目公开管理"><a href="#账目公开管理" class="headerlink" title="账目公开管理"></a>账目公开管理</h4><p>通过公开财务报表的方式让员工参与工作决策。使员工更积极地做出有利于工作的决策，更好地理解自己的工作内容和工作方式对公司的意义，最终影响公司利润。</p>
<h4 id="员工认可计划"><a href="#员工认可计划" class="headerlink" title="员工认可计划"></a>员工认可计划</h4><p>对员工的关注以及对出色的工作表现给予关注、赞扬和感谢。</p>
<h4 id="绩效工资方案"><a href="#绩效工资方案" class="headerlink" title="绩效工资方案"></a>绩效工资方案</h4><p>40%的员工看不到绩效和薪酬的联系，公司没有清晰、明确地向员工传达绩效期望。绩效工资方案指的的根据对绩效的测量来支付员工工资的浮动薪酬方案。个体应当能够感觉到自己的绩效与所获得的奖励之间存在一种强有力的纽带，这样才能使激励效果最大化。</p>
<h4 id="技能练习"><a href="#技能练习" class="headerlink" title="技能练习"></a>技能练习</h4><ol>
<li>认清个体差异。员工并不完全相同，他们在需求、态度、个性以及其他重要的个人变量方面各不相同。</li>
<li>让员工与工作相匹配。个体与工作的合理匹配能够起到激励作用，缺乏必要的技能来圆满完成工作任务的员工将会处于劣势。</li>
<li>利用目标。确保员工拥有困难而具体的目标。</li>
<li>确保这些目标被员工认为是可实现的。无论目标实际上是否能够实现，如果员工认为无法实现，他们就会降低努力程度。因此，管理者必须保证员工充满自信，让他们感到只要努力就可以实现绩效目标。</li>
<li>个人化的奖励。对某人有效的奖励并不一定适合其他人，管理者应该充分了解员工的差异并对他们实施个人化的奖励。你能够支配的一些奖励包括加薪、晋升、工作自主性、参与目标设置和决策的机会。</li>
<li>奖励与绩效挂钩。奖励与绩效紧密联系起来，如果不对绩效因素进行奖励，则只会强化那些非绩效因素。</li>
<li>检查系统的公平性。员工的经验、能力、努力及其他明显的付出应该能够解释收入、职责以及其他明显结果的差异。</li>
<li>不要忽视金钱的作用。我们很容易只关注设置目标、创造工作的趣味性、提供参与机会这些因素，而忘记大多数人参与工作的主要原因是为了钱。因此，基于工作绩效的加薪、计件奖金、员工持股计划以及其他收入激励方式对决定员工激励程度具有重要的影响。</li>
</ol>
]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>管理学</tag>
      </tags>
  </entry>
  <entry>
    <title>组织行为学</title>
    <url>/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86/%E7%BB%84%E7%BB%87%E8%A1%8C%E4%B8%BA%E5%AD%A6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>管理</category>
      </categories>
  </entry>
  <entry>
    <title>软件工程导论-可行性研究</title>
    <url>/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA-%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p>许多问题不可能在预定的系统规模或时间期限之内解决。</p>
<p>可行性研究的目的不是解决问题，而是确定问题是否值得去解决。</p>
<p>技术可行性：使用现有的技术能实现这个系统吗？</p>
<p>经济可行性：这个系统的经济效益能超过它的开发成本吗？</p>
<p>操作可行性：系统的操作方式在这个用户组织内行得通吗？</p>
<p>1.复查系统规模和目标</p>
<p>清晰地描述对目标系统的一切限制和约束。</p>
<p>2.研究目前正在使用的系统</p>
<p>现有的系统是信息的重要来源，现有的系统必然有某些缺点，新系统必须能解决旧系统中存在的问题。</p>
<p>3.导出新系统的高层逻辑模型</p>
<p>优秀的设计过程通常是从现有的物理系统出发，导出现有系统的逻辑模型，再参考现有系统的逻辑模型，设想目标系统的逻辑模型，最后根据目标系统的逻辑模型建造新的物理系统。</p>
<p>分析员能够使用数据流图，描绘数据在系统中流动和处理的情况，从而概括地表达出他对新系统的摄像。还应该有一个初步的数据字典，定义系统中使用的数据。</p>
<p>4.进一步定义问题</p>
<p>分析员应该和用户一起再次复查问题定义、工程规模和目标，这次复查应该把数据流图和数据字典作为讨论的基础。</p>
<p>5.导出和评价供选择的解法</p>
<p>分析员应该从他建议的系统逻辑模型出发，导出若干个较高层次的(较抽象的)物理解法供比较和选择。导出供选择的解法的最简单的途径，是从技术角度出发考虑解决问题的不同方案。例如在数据流图上划分不同的自动化边界，从而导出不同物理方案的方法。</p>
<p>6.推荐行动方针</p>
<p>是否继续进行这项开发工程？分析员必须清楚地表明他对这个关键性决定的建议。</p>
<p>7.草拟开发计划</p>
<p>分析员应该为所推荐的方案草拟一份开发计划，除了制定工程进度表之外还应该估计对各类开发人员(例如，系统分析员、程序员)和各种资源(计算机硬件、软件工具等)的需要情况，应该指明什么时候使用以及使用多长时间。</p>
<p>8.书写文档提交审查</p>
<p>应该把上述可行性研究各个步骤的工作结果写成清晰的文档，请用户、客户组织的负责人及评审组审查，以决定是否继续这项工程及是否接受分析员推荐的方案。</p>
]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>软件工程导论</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程导论-实现</title>
    <url>/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA-%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>通常把编码和测试统称为实现。</p>
<p>编码</p>
<p>1.选择程序设计语言。选用的标准：系统用户的要求；可以使用的编译程序；可以得到的软件工具；工程规模；程序员的知识；软件可移植性要求；软件的应用领域；</p>
<p>2.编码风格。遵循规则：程序内部的文档；数据说明；语句构造；输入输出；效率；</p>
<p>软件测试</p>
<p>软件测试的目标</p>
<p>1.测试是为了发现程序中的错误而执行程序的过程。</p>
<p>2.好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案。</p>
<p>3.成功的测试是发现了至今为止尚未发现的错误的测试。</p>
<p>软件测试准则</p>
<p>1.所有测试都应该能追溯到用户需求。</p>
<p>2.应该远在测试开始之前就制定出测试计划。</p>
<p>3.把Pareto原理应用到软件测试中。</p>
<p>4.应该从“小规模”测试开始，并逐步进行“大规模”测试。</p>
<p>5.穷举测试是不可能的。</p>
<p>6.为了达到最佳的测试效果，应该由独立的第三方从事测试工作。</p>
<p>测试任何产品有两种方法：黑盒测试和白盒测试。</p>
<p>测试步骤</p>
<p>1.模块测试</p>
<p>2.子系统测试</p>
<p>3.系统测试</p>
<p>4.验收测试</p>
<p>5.平行运行</p>
<p>测试阶段的信息流</p>
<p>1.软件配置，包括需求说明书、设计说明书和源程序清单等。</p>
<p>2.测试配置，包括测试计划和测试方案。</p>
<p>如果经常出现要求修改设计的严重错误，那么软件的质量和可靠性是值得怀疑的。</p>
<p>反之应该考虑两种可能：1.软件的可靠性是可以接受的；2.所进行的测试尚不足以发现严重的错误。</p>
<p>软件可靠性模型使用错误率数据估计将来出现错误的情况，并进而对软件可靠性进行预测。</p>
<p>单元测试</p>
<p>在单元测试期间着重从下述5个方面对模块进行测试。</p>
<p>1.模块接口</p>
<p>2.局部数据结构</p>
<p>3.重要的执行通路</p>
<p>4.出错处理通路</p>
<p>5.边界条件。</p>
<p>代码审查</p>
<p>人工测试源程序可以由程序的编写者本人非正式地进行，也可以由审查小组正式进行。后者称为代码审查。</p>
<p>组成人员：1.组长，应该是一个很有能力的程序员，而且没有直接参与这项工程。2.程序的设计者。3.程序的编写者。4.程序的测试者。</p>
<p>模块并不是一个独立的程序，因此必须为每个单元测试开发驱动软件和(或)存根软件。通常驱动程序也就是一个“主程序”，它接收测试数据，把这些数据传送给被测试的模块，并且印出有关的结果。存根程序代替被测试的模块所调用的模块。它使用被它代替的模块的接口，可能做最少量的数据操作，印出对入口的检验或操作结果，并且把控制归还给调用它的模块。</p>
<p>集成测试</p>
<p>集成测试是测试和组装软件的系统化技术。</p>
<p>由模块组装成程序时有两种方法。</p>
<p>非渐增式测试方法：先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序。</p>
<p>一下子把所有模块放在一起，并把庞大的程序作为一个整体来测试，测试者面对的情况十分复杂。改正错误更是极端苦难，因为在庞大的程序中想要诊断定位一个错误是非常困难的。</p>
<p>渐增式测试：把下一个要测试的模块同已经测试好的那些模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试。</p>
<p>它把程序划分成小段来构造和测试，在这个过程中比较容易定位和改正错误；对接口可以进行更彻底的测试；可以使用系统化的测试方法。</p>
<p>目前普遍采用渐增式测试方法。</p>
<p>使用渐增方式时，有自顶向下和自底向上两种集成策略。</p>
<p>1.自顶向下集成</p>
<p>自顶向下集成方式是一个日益为人们广泛采用的测试和组装软件的途径。从主控制模块开始，沿着程序的控制层次向下移动，逐渐把各个模块结合起来。在把附属于主控制模块的那些模块组装待程序结构中去时，或者使用深度优先的策略，或者使用宽度优先的策略。</p>
<p>2.自底向上集成</p>
<p>自底向上测试从“原子”模块（即在软件结构最低层的模块）开始组装和测试。因为是从底部向上结合模块，总能得到所需的下层模块处理功能，所以不需要存根程序。</p>
<p>步骤：</p>
<p>第一步，把低层模块组合成实现某个特定的软件子功能的族。</p>
<p>第二步，写一个驱动程序(用于测试的控制程序)，协调测试数据的输入和输出。</p>
<p>第三步，对由模块组成的子功能族进行测试。</p>
<p>第四步，去掉驱动程序，沿软件结构自下向上移动，把子功能族组合起来形成更大的子功能族。</p>
<p>回归测试</p>
<p>在集成测试过程中每当一个新模块结合进来时，程序就发生了变化：建立了新的数据流路径，可能出现了新的I/O操作，激活了新的控制逻辑。重新执行已经做过的测试的某个子集，以保证上述这些变化没有带来非预期的副作用。</p>
<p>回归测试集包括3类不同的测试用例：</p>
<p>1.检测软件全部功能的代表性测试用例。</p>
<p>2.专门针对可能受修改影响的软件功能的附加测试。</p>
<p>3.针对被修改过的软件成分的测试。</p>
<p>确认测试</p>
<p>确认测试也成为验收测试，它的目标是验证软件的有效性。</p>
<p>确认测试必须有用户积极参与，或者以用户为主进行。用户应该参与月设计测试方案。确认测试通常使用黑盒测试法。</p>
<p>测试计划：包括要进行的测试的种类及进度安排。</p>
<p>测试过程：规定了用来检测软件是否与需求一致的测试方案。</p>
<p>有下述两种可能的结果</p>
<p>1.功能和性能与用户要求一致，软件是可以接受的。</p>
<p>2.功能和性能与用户要求有差距。</p>
<p>确认测试的一个重要内容是复查软件配置。保证软件配置的所有成分都齐全，质量符合要求，文档与程序完全一致，具有完成软件维护所必须的细节，而且已经编好目录。</p>
<p>如果一个软件是为许多客户开发的，那么使用Alpha测试和Beta测试。</p>
<p>Alpha测试：由用户在开发者的场所进行，并且在开发者对用户的“指导”下进行测试，Alpha测试是在受控的环境中进行的。</p>
<p>Beta测试：由软件的最终用户们在一个或多个客户场所进行。</p>
<p>白盒测试技术：</p>
<p>设计测试方案的基本目标是，确定一组最可能发现某个错误或某类错误的测试数据。</p>
<p>1.逻辑覆盖</p>
<p>语句覆盖；判定覆盖；条件覆盖；判定/条件覆盖；条件组合覆盖；点覆盖；边覆盖；路径覆盖；</p>
<p>2.控制结构测试</p>
<p>基本路径测试；条件测试；循环测试；</p>
<p>黑盒测试</p>
<p>黑盒测试力图发现的错误：1.功能不正或遗漏了功能；2.界面错误；3.数据结构错误或外部数据库访问错误；4.性能错误；5.初始化和终止错误。</p>
<p>应该考虑的问题：</p>
<p>1.怎样测试功能的有效性？</p>
<p>2.哪些类型的输入可构成好测试用例？</p>
<p>3.系统是否对特定的输入值特别敏感？</p>
<p>4.怎样划定数据类的边界？</p>
<p>5.系统能够承受什么样的数据率和数据量？</p>
<p>6.数据的特定组合将对系统运行产生什么影响？</p>
<p>测试用例集：</p>
<p>1.所设计出的测试用例能够减少为达到合理测试所需要设计的测试用例的总数。</p>
<p>2.所设计出的测试用例能够告诉人们，是否存在某些类型的错误，而不是仅仅指出与特定测试相关的错误存在。</p>
<p>有哪些技术？</p>
<p>1.等价划分。</p>
<p>2.边界值分析。</p>
<p>3.错误推测。</p>
<p>调试</p>
<p>调试的目标是寻找软件错误的原因并改正错误。</p>
<p>1.蛮干法；2.回溯法；3.原因排除法。</p>
<p>测试阶段的根本目标是消除错误，保证软件可靠性。</p>
<p>软件可靠性是程序在给定的时间间隔内，按照规格说明书的规定成功地运行的概率。</p>
<p>软件可用性是程序在给定的时间点，按照规格说明书的规定，成功地运行的概率。</p>
<p>引入平均无故障时间和平均维修时间。</p>
]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>软件工程导论</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程导论-形式化说明技术</title>
    <url>/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA-%E5%BD%A2%E5%BC%8F%E5%8C%96%E8%AF%B4%E6%98%8E%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>按照形式化的程度，可以把软件工程使用的方法划分成非形式化、半形式化和形式化3类。</p>
<p>所谓形式化方法，是描述系统性质的基于数学的技术。</p>
<p>用自然语言书写的系统规格说明书，可能存在矛盾、二义性、含糊性、不完整性及抽象层次混乱等问题。</p>
<p>数学最有用的一个性质是，它能够简洁准确地描述物理现象、对象或动作的结果，因此是理想的建模工具。数学特别适合于表示状态，也就是表示“做什么”。</p>
<p>应用形式化方法的准则</p>
<p>1.应该选用适当的表示方法。</p>
<p>2.应该形式化，但不要过分形式化。</p>
<p>3.应该估算成本。</p>
<p>4.应该有形式化方法顾问随时提供咨询。</p>
<p>5.不应该放弃传统的开发方法。</p>
<p>6.应该建立详尽的文档。</p>
<p>7.不应该放弃质量标准</p>
<p>8.不应该盲目依赖形式化方法：形式化方法并不能保证开发出的软件绝对正确，例如，无法用形式化方法证明从非形式化需求到形式化规格说明的转换是正确的，因此，必须有那个其他方法(例如，评审、测试)来验证软件正确性。</p>
<p>9.应该测试、测试再测试。</p>
<p>10.应该重用。</p>
]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>软件工程导论</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程导论-总体设计</title>
    <url>/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA-%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>1  总体设计<br>总体设计通常由两个主要阶段组成：<br>系统设计阶段，确定系统的具体实现方案；<br>结构设计阶段，确定软件结构。</p>
<p>总体设计的9个步骤：<br>1.设想供选择的方案<br>       考虑各种可能的实现方案，一般将需求分析阶段得出的数据流图作为出发点，把数据流图中的处理分组的各种可能性，抛弃在技术上行不通的分组方法，余下的分组方法代表可能的实现策略，并且可以启示供选择的物理系统。<br>2.选取合理的方案<br>       选取若干个合理的方案，通常至少选取低成本/中成本/高成本的3种方案。<br>       每个方案准备四份资料(系统流程图，组成系统的物理元素清单，成本/效益分析，实现这个系统的进度计划)。<br>3.推荐最佳方案<br>       从合理方案中，推荐一个最佳的方案，并且为这个方案制定详细的实现计划。<br>4.功能分解<br>       从实现角度把复杂的功能进一步分解，一般说来，经过分解之后应该使每个功能对大多数程序员而言都是明显易懂的。功能分解导致数据流图的进一步细化。<br>5.设计软件结构<br>       把模块组织成良好的层次系统，顶层模块调用它的下层模块以实现程序的完整功能。<br>6.设计数据库<br>7.制定测试计划<br>       考虑测试问题，在设计的时候注意提高软件的可测试性。<br>8.书写文档<br>       系统说明：主要内容包括用系统流程图描绘的系统构成方案，组成系统的物理元素清单，成本/效益分析；对最佳方案的概括描述，精化的数据流图，用层次图或结构图描绘的软件结构，用IPO图或其他工具简要描述的各个模块的算法，模块间的接口关系，以及需求、功能和模块三者之间的交叉参照关系等。<br>       用户手册：根据总体设计阶段的结果，修改更正在需求分析阶段产生的初步的用户手册。<br>       测试计划：包括测试策略，测试方案，预期的测试结果，测试进度计划等等。<br>       详细的实现计划：<br>       数据库设计结果：<br>9.审查和复查<br>       技术审查，然后由客户从管理角度进行复查。</p>
<p>2  设计原理<br>2.1  模块化<br>      模块是由边界元素限定的相邻程序元素的序列，而且有一个总体标识符代表它。按照模块的定义，过程、函数、子程序和宏等，都可作为模块。面向对象方法学中的对象是模块，对象内的方法也是模块。<br>      每个程序都相应地有一最适当的模块数目M，使得系统的开发成本最小。当模块数目增加时每个模块的规模将减小，开发单个模块需要的成本确实减少了；但是，随着模块数目增加，设计模块间接口所需要的工作量也将增加。<br>2.2  抽象<br>      抽象就是抽出事物的本质特性而暂时不考虑它们的细节。<br>      由于人类思维能力的限制，如果每次面临的元素太多，是不可能产生精确思维的。处理复杂系统的唯一有效的方法是用层次的方式构造和分析它。<br>      当考虑对任何问题的模块化解法时。可以提出许多抽象的层次。在抽象的最高层次使用问题环境的语言，以概括的方式叙述问题的解法；在较低抽象层次采用更过程化的方法，把面向问题的术语和面向实现的术语结合起来叙述问题的解法；最后，在最低的抽象层次用可以直接实现的方式叙述问题的解法。<br>2.3  逐步求精<br>      逐步求精是人类解决复杂问题时采用的基本方法。为了能集中精力解决主要问题而尽量延迟对问题细节的考虑。<br>      Miller法则：一个人在任何时候都只能把注意力集中在(7±2)个知识块上。<br>      逐步求精是一种自顶向下的设计策略，按照这种设计策略，程序的体系结构是通过逐步精化处理过程的层次而设计出来的。<br>      抽象与求精是一对互补的概念。抽象使得设计者能够说明过程和数据，同时却忽略了底层细节。求精则帮助设计者在设计过程中桌布揭示出低层细节。<br>2.4  信息隐藏和局部化<br>      信息隐藏原理指出：应该这样设计和确定模块，使得一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的。<br>      局部化是指把一些关系密切的软件元素物理地放得彼此靠近。</p>
<p>3  耦合和内聚<br>      耦合衡量不同模块彼此间相互依赖(连接)的紧密程度；内聚衡量一个模块内部各个元素彼此结合的紧密程度。<br>3.1  耦合<br>      如果两个模块中的每一个都能独立地工作而不需要另一个模块的存在，那么它们彼此完全独立，这意味着模块间无任何连接，耦合程度最低。<br>      数据耦合：低耦合，如果两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据，那么这种耦合称为数据耦合。系统中必须存在这种耦合，因为只用当某些模块的输出数据作为另一些模块的输入数据时，系统才能完成有价值的功能。<br>      控制耦合：中等耦合，如果传递的信息中有控制信息(尽管有时这种控制信息以数据的形式出现)，则称为控制耦合。<br>      特征耦合：如果被调用的模块需要使用作为参数传递进来的数据结构中的所有元素，那么，把整个数据结构作为参数传递就是完全正确的。但是，当把整个数据结构作为参数传递而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合。在这种情况下，被调用的模块可以使用的数据多余它确实需要的数据，这将导致对数据的访问失去控制，从而给计算机犯罪提供了机会。<br>      公共环境耦合：当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合成为公共环境耦合。公共环境耦合的负责程度随耦合的模块个数而变化，当耦合的模块个数增加时复杂程度显著增加。<br>      内容耦合：最高程度的耦合。一个模块方位另一个模块的内部数据。一个模块不通过正常入口而转到另一个模块的内部。两个模块有一部分程序代码重叠(只可能出现在汇编程序中)。一个模块有多个入口(这意味着一个模块有几种功能)。<br>      尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合。</p>
<p>3.2  内聚<br>      内聚标识着一个模块内各个元素彼此结合的紧密程度，它是信息隐藏和局部化概念的自然扩展。<br>      内聚和耦合是密切相关的，模块内的高内聚往往意味着模块间的耦合。内聚和耦合是进行模块化设计的有力工具，但是实践表明内聚更重要，应该把注意力集中到提高模块的内聚程度上。</p>
<p>低内聚有如下几类：<br>偶然内聚：如果一个模块完成一组任务，这些任务彼此间即时有关系，关系也是很松散，就叫做偶然内聚。<br>逻辑内聚：如果一个模块完成的任务在逻辑上属于相同或相似的一类。<br>时间内聚：如果一个模块包含的任务必须在同一段时间内完执行。</p>
<p>中内聚有两类：<br>过程内聚：如果一个模块内的处理元素是相关的，而且必须以特定次序执行。<br>通信内聚：如果模块中所有元素都使用同一个输入数据和(或)产生同一个输出数据。</p>
<p>高内聚有两类：<br>顺序内聚：如果一个模块内的处理元素和同一个功能密切相关，而且这些处理必须顺序执行。<br>功能内聚：如果模块内所有处理元素属于一个整体，完成一个单一的功能。</p>
<p>|功能内聚|10分|时间内聚|3分|<br>|顺序内聚|9分    |逻辑内聚|1分|<br>|通信内聚|7分    |偶然内聚|0分|<br>|过程内聚|5分    |||</p>
<p>4  启发规则<br>1.改进软件结果提高模块独立性。<br>2.模块规模应该适中。<br>3.深度、宽度、扇出和扇入都应适当。<br>4.模块的作用域应该在控制域之内。<br>5.力争降低模块接口的复杂程度。<br>6.设计单入口单出口的模块。<br>7.模块功能应该可以预测。</p>
]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>软件工程导论</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程导论-详细设计</title>
    <url>/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA-%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>详细设计的根本目标是确定应该怎样具体地实现所要求的系统，从而在编码阶段可以把这个描述直接翻译成用某种程序设计语言书写的程序。</p>
<p>程序的”读者”有两个，那就是计算机和人，因此，衡量程序的质量不仅要看它的逻辑是否正确，性能是否满足要求，更主要的是要看它是否容易阅读和理解。结构程序设计使实现上述目标的关键技术，因此是详细设计的逻辑基础。</p>
<p>结构程序设计使尽可能少用GO TO语句的程序设计方法。最好仅在检测出错误时才使用GO TO语句，而且应该总是使用前向GO TO语句。</p>
<p>人机界面设计使接口设计的一个重要的组成部分，对于交互式系统来说，人机界面设计和数据设计、体系结构设计及过程设计一样重要。</p>
<p>在设计人机界面的过程中，几乎总会遇到下述4个问题：系统响应时间、用户帮助设施、出错信息处理和命令交互。</p>
<p>用户界面设计是一个迭代的过程：先创建设计模型，再用原型事项这个设计模型，并有用户试用和评估，然后根据用户意见进行修改。</p>
<p>也可以在创建原型之前就对用户界面的设计质量进行初步评估。如果能及早发现并改正潜在的问题，就可以减少评估周期的执行次数，从而缩短软件的开发时间。可以用下述评估标准对设计进行早期复查。</p>
<p>1.系统及其界面的规格说明书的长度和复杂程度，预示了用户学习使用该系统所需要的工作量。</p>
<p>2.命令或动作的数量、命令的平均参数个数或动作中单个操作的个数，预示了系统的交互时间和总体效率。</p>
<p>3.设计模型中包含的动作、命令和系统状态的数量，预示了用户学习使用该系统时需要记忆的内容的多少。</p>
<p>4.界面风格、帮助设施和出错处理协议，预示了界面的复杂程度及用户接收该界面的程度。</p>
<p>描述程序处理过程的工具称为过程设计工具，它们可以分为图形、表格和语言3类。不论是哪类工具，对它们的基本要求都是能提供对设计的无歧义的描述，也就是应该能指明控制流程、处理功能、数据组织及其他方面的实现细节，从而在编码阶段能把对设计的描述直接翻译成程序代码。可以采用程序流程图、盒图、PAD图、判定表、判定树、过程设计语言PDL。</p>
<p>计算机软件本质上是信息处理系统，因此，可以根据软件所处理的信息的特征来设计软件。面向数据结构的设计方法最终目标是得出对程序处理过程的描述。这种设计方法并不明显地使用软件结构的概念，模块是设计过程的副产品，对于模块独立原理也没有给予应有的重视。因此，这种方法最适合于详细设计阶段使用。Jackson方法和Warnier方法是最著名的两个面向数据结构的设计方法。</p>
<p>程序复杂程度的定量度量</p>
<p>定量度量程序复杂程度的方法很有价值：把程序的复杂程度乘以适当常数即可估算出软件中错误的数量以及软件开发需要用的工作量，定量度量的结果可以用来比较两个不同的设计或两个不同算法的优劣；程序的定量的复杂程度可以作为模块规模的精确限度。用的比较广泛的有McCabe方法和Halstead方法。</p>
]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>软件工程导论</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程导论-软件危机</title>
    <url>/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA-%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="产生的问题"><a href="#产生的问题" class="headerlink" title="产生的问题"></a>产生的问题</h2><p>软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题。<br>1.对软件开发成本和进度的估计常常很不准确。<br>2.用户对“已完成的”软件系统不满意的现象经常发生。<br>3.软件产品的质量往往靠不住。<br>4.软件常常是不可维护的。<br>5.软件通常没有适当的文档资料。<br>6.软件成本在计算机系统总成本中所占的比例逐年上升。<br>7.软件开发生成率提高的速度，远远跟不上计算机应用迅速普及深入的趋势。</p>
<h2 id="产生问题的原因"><a href="#产生问题的原因" class="headerlink" title="产生问题的原因"></a>产生问题的原因</h2><p>1.与软件本身的特点有关，2.和软件开发与维护的方法不正确有关。<br>软件是计算机系统中的逻辑部件，软件缺乏“可见性”，软件的质量也较难评价，因此，管理和控制软件开发过程相当困难。<br>软件是程序、数据及相关文档那个的完整集合。必须充分认识到软件开发不是某种个体劳动的神秘技巧，而应该是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目。</p>
<h2 id="软件工程的7条基本原理"><a href="#软件工程的7条基本原理" class="headerlink" title="软件工程的7条基本原理"></a>软件工程的7条基本原理</h2><p>1.用分阶段的生命周期计划严格管理。不成功的软件项目中有一半是由于计划不周造成的。<br>2.坚持进行阶段评审。<br>3.实行严格的产品控制。<br>4.采用现代程序设计技术。<br>5.结果应能清楚地审查。<br>6.开发小组的人员应该少而精。<br>7.承认不断改进软件工程实践的必要性。</p>
<h2 id="传统方法学和面向对象方法学。"><a href="#传统方法学和面向对象方法学。" class="headerlink" title="传统方法学和面向对象方法学。"></a>传统方法学和面向对象方法学。</h2><p>传统方法学采用结构化技术来完成软件开发的各项任务，并使用适当的软件工具或软件工程环境来支持结构化技术的运用。强调自顶向下顺序地完成软件开发的各阶段任务。这种技术要么面向行为，要么面向数据。<br>面向对象方法是一个主动地多次反复迭代的演化过程。面向对象方法把数据和行为看成是同等重要的。</p>
<h2 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h2><p>软件生命周期由软件定义、软件开发和运行维护。<br>软件定义：问题定义、可行性研究、需求分析。<br>软件开发：总体设计、详细设计、编码、单元测试、综合测试。<br>运行维护。</p>
]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>软件工程导论</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程导论-软件过程</title>
    <url>/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。"><a href="#软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。" class="headerlink" title="软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。"></a>软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。</h2><ol>
<li>瀑布模型</li>
</ol>
<p>阶段间具有顺序性和依赖性。<br>推迟实现的观点。先做设计，再做编程。<br>质量保证的观点。每个阶段都必须完成规定的文档，每个阶段结束前都要对所完成的文档进行评审，以便尽早发现问题，改正错误。<br>优点：可强迫开发人员采用规范的方法；严格地规定了每个阶段必须提交的文档；要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证。<br>缺点：“瀑布模型是由文档驱动的”。在可运行的软件产品交付给用户之前，用户只能通过文档来了解产品是什么样的。</p>
<ol start="2">
<li>快速原型模型</li>
</ol>
<p>快速建立起来的可以在计算机上运行的程序，它所能完成的功能往往是最终产品能完成的功能的一个子集。快速建立一个能反映用户主要需求的原型系统。<br>优点：快速原型模型是不带反馈环的，开发基本上是线性顺序进行的。</p>
<ol start="3">
<li>增量模型</li>
</ol>
<p>把软件产品作为一系列的增量构建来设计、编码、集成和测试。它分批地逐步向用户提交产品。<br>优点：能在较短时间内向用户提交可完成部分工作的产品，逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。</p>
<ol start="4">
<li>螺旋模型</li>
</ol>
<p>使用原型及其他方法来尽量降低风险。每个阶段之前都增加了风险分析过程的快速原型模型。每一步从风险角度分析上一步的工作结果，努力排除各种潜在的风险，通常用建造原型的方法来排除风险。如果风险不能排除，则停止开发工作或大幅度地削减项目规模。</p>
<ol start="5">
<li>喷泉模型</li>
</ol>
<p>体现了面向对象软件开发的过程迭代和无缝的特性。面向对象开发所有其他概念(例如功能、关系、事件等)都是围绕对象组成的，目的是保证分析工作中得到的信息不会丢失或改变。由于各阶段都使用统一的概念和表示符号，因此，整个开发过程都是吻合一致的。</p>
<ol start="6">
<li>Rational统一过程</li>
</ol>
<p>Rational统一过程(Rational Unified Process, RUP)是由Rational软件公司推出的一种完整而且完美的软件过程。<br>最佳实践：迭代是开发；管理需求；使用基于构建的体系结构；可视化建模；验证软件质量；控制软件变更。<br>RUP软件开发生命周期：二维的生命周期模型。工作流，时间。<br>RUP中有9个核心工作流，其中前6个为核心过程工作流程，后3个为核心支持工作流程。<br>业务建模；需求；分析与设计；实现；测试；部署；配置与变更管理；项目管理；环境；<br>工作阶段<br>RUP把软件生命周期划分成4个连续的阶段<br>初始阶段：建立业务模型，定义最终产品视图，并且确定项目的范围。<br>精化阶段：设计并确定系统的体系结构，制订项目计划，确定资源需求。<br>构建阶段：开发出所有构件和应用程序，把它们集成为客户需要的产品，并且详尽地测试所有功能。<br>移交阶段：把开发出的产品提交给用户使用。</p>
<ol start="7">
<li>敏捷过程</li>
</ol>
<p>目的：为了使软件开发团队具有高效工作和快速响应变化的能力。<br>4个简单的价值观<br>个体和交互胜过过程和工具：首先致力于构建软件开发团队(包括成员和交互方式等)，然后再根据需要为团队配置项目环境(包括过程和工具)。<br>可以工作的软件胜过面面俱到的文档：开发人员应该把主要精力放在创建可工作的软件上面，仅当迫切需要并且具有重大意义时，才进行文档编制工作，而且所编制的内部文档应该尽量简明扼要、主体突出。<br>客户合作胜过合同谈判：能够满足客户不断变化的需求的切实可行的途径是，开发团队与客户密切切做。<br>响应变化胜过遵循计划：计划必须有足够的灵活性和可塑性，在形势发生变化时能迅速调整，以适应业务和技术等方面发生的变化。</p>
<ol start="8">
<li>极限编程</li>
</ol>
<p>极限编程是敏捷过程中最富盛名的一个，其名称中”极限“二字的含义是指把好的开发实践运用到极致。<br>极限编程有限的开发实践：<br>客户作为开发团队的成员。<br>使用用户素材：用户素材就是正在进行的关于需求的谈话内容的助记符。<br>短交付周期：每两周完成一次的迭代过程实现了用户的一些需求，获得他们的反馈意见。<br>验收测试：通过执行客户指定的验收测试来捕获用户素材的细节。<br>测试驱动开发：在编码之前首先设计好测试方案，然后再编程。<br>集体所有：小组每个成员都有更改代码的权利，每个成员都对全部代码的质量负责。<br>持续集成：一天之内多次集成系统，而且随着需求的变更，应该不断地进行回归测试。<br>可持续的开发速度：以能够长期维持的速度努力工作，避免工作时间太长，降低生产率。<br>开发的工作空间：全体参与者一起在一个开放的场所中工作。在这个场所中自由地交流和讨论。<br>及时调整计划：制订出计划之后，可以根据项目进展情况及时进行调整，没有一成不变的计划。<br>简单的设计：设计时不需要考虑未来的用户素材，不断变更系统设计，使之相对于正在实现的用户素材而言始终处于最优状态。<br>重构：在开发过程中不要过分依赖重构，不能轻视设计。<br>使用隐喻：可以将隐喻看做是整个系统联系在一起的全局视图，它描述系统如何运作，以及用何种方式把新功能加入到系统中。</p>
<ol start="9">
<li>微软过程</li>
</ol>
<p>基本准则：<br>项目计划应该兼顾未来的不确定因素。<br>用有效的风险管理来减少不确定因素的影响。<br>经常生成并快速地测试软件的过渡版本，从而提高产品的稳定性和可预测性。<br>采用快速循环、递进的开发过程。<br>用创造性的工作来平衡产品特性和产品成本。<br>项目进度表应该具有较高稳定性和权威性。<br>使用小型项目组并发地完成开发工作。<br>在项目早起把软件配置项基线化，项目后期则冻结产品。<br>使用原型验证概念，对项目进行早期论证。<br>把零缺陷作为追求的目标。<br>里程碑评审会的目的是改进工作，切忌相互指责。</p>
]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>软件工程导论</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程导论-需求分析</title>
    <url>/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>需求分析是软件定义时期的最后一个阶段，它的基本任务是准确地回答”系统必须做什么?”这个问题。</p>
<p>虽然在可行性研究阶段已经粗略地了解了用户的需求，甚至还提出了一些可行的方案，但是，可行性研究的基本目的是用较小的成本在较短的时间内确定是否存在可行的解法，因此许多细节被忽略。然而在最终的系统中却不能遗漏任何一个微小的细节，也就是对目标系统提出完整、准确、清晰、具体的要求。</p>
<p>通常对软件系统有下述几方面的综合要求：</p>
<p>1.功能需求</p>
<p>2.性能需求</p>
<p>3.可靠性和可用性需求</p>
<p>4.出错处理需求</p>
<p>5.接口需求</p>
<p>6.约束</p>
<p>7.逆向需求</p>
<p>8.将来可能提出的要求</p>
<p>与用户沟通获取需求的方法</p>
<p>1.访谈</p>
<p>通过正式和非正式的访谈</p>
<p>2.面向数据流自顶向下求精</p>
<p>3.简易的应用规格说明技术</p>
<p>4.快速建立软件原型</p>
<p>需求分析过程应该建立3种模型，它们分别是数据模型、功能模型和行为模型。</p>
<p>验证软件需求</p>
<p>从4个方面进行验证</p>
<p>1.一致性</p>
<p>2.完整性</p>
<p>3.现实性</p>
<p>4.有效性</p>
]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>软件工程导论</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象分析与设计-Ripple</title>
    <url>/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-Ripple/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>阶段</th>
<th></th>
<th>制品</th>
<th>UML</th>
</tr>
</thead>
<tbody>
<tr>
<td>起源</td>
<td></td>
<td>任务陈述或非正式的需求</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td>任务</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td>责任</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td>项目计划</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td>工作本</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td>术语表(全面更新)</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td>测试计划</td>
<td>否</td>
</tr>
<tr>
<td>需求</td>
<td>业务</td>
<td>参与者列表(带有描述)</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td>用例列表(带有描述)</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td>用例细节</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td>活动图(可选)</td>
<td>是</td>
</tr>
<tr>
<td></td>
<td></td>
<td>通信图(可选)</td>
<td>是</td>
</tr>
<tr>
<td></td>
<td>系统</td>
<td>参与者列表(带有描述)</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td>用例列表(带有描述)</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td>用例细节</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td>用例图</td>
<td>是</td>
</tr>
<tr>
<td></td>
<td></td>
<td>用例调查</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td>用户接口框架</td>
<td>否</td>
</tr>
<tr>
<td>分析</td>
<td></td>
<td>类图</td>
<td>是</td>
</tr>
<tr>
<td></td>
<td></td>
<td>通信图</td>
<td>是</td>
</tr>
<tr>
<td>设计</td>
<td>系统</td>
<td>部署图</td>
<td>是</td>
</tr>
<tr>
<td></td>
<td></td>
<td>层图</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td>子系统</td>
<td>类图</td>
<td>是</td>
</tr>
<tr>
<td></td>
<td></td>
<td>顺序图</td>
<td>是</td>
</tr>
<tr>
<td></td>
<td></td>
<td>数据库模式</td>
<td>否</td>
</tr>
<tr>
<td>类规范</td>
<td></td>
<td>注释</td>
<td>否</td>
</tr>
<tr>
<td>实现</td>
<td></td>
<td>源代码</td>
<td>否</td>
</tr>
<tr>
<td>测试</td>
<td></td>
<td>测试报表</td>
<td>否</td>
</tr>
<tr>
<td>部署</td>
<td></td>
<td>压缩打包的解决方案</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td>手册</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td>培训材料</td>
<td>否</td>
</tr>
<tr>
<td>维护</td>
<td></td>
<td>错误报告</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td>递增计划</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>1.项目来源(与顾客一起进行)</p>
<p>a.了解顾客的需求，或者告诉他们需要什么</p>
<p>b.从顾客处获取需求文档，作为任务陈述或较长的文档；如果没有这些文档，就和顾客一起编写非正式的需求文档。</p>
<p>2.分配任务</p>
<p>a.确定开发任务(例如规划、管理、计时、开发、测试、系统管理)。</p>
<p>b.确定每个任务由谁负责。</p>
<p>3.编写业务手册：在纸上或者在线业务手册上包含所有的项目制品。</p>
<p>4.编写术语表</p>
<p>a.编写一个术语表，以记录项目术语的定义。</p>
<p>b.在整个开发过程中更新术语表。</p>
<p>5.制订项目计划</p>
<p>a.为螺旋式递增阶段进行初步的规划，并制订一个进度表。</p>
<p>b.在整个开发过程中，定期检查、调整项目计划。</p>
<p>6.制订测试计划：考虑不间断的测试、测试阶段、顾客评估、开发和维护。</p>
<p>7.业务需求(与顾客一起)：</p>
<p>a.制订业务参与者列表(及其描述)</p>
<p>b.制订业务用例列表(及其描述)</p>
<p>c.(可选)用活动图描述业务用例</p>
<p>d.(可选)用通信图描述业务用例</p>
<p>e.确定业务用例的细节</p>
<p>8.系统需求(与顾客一起)：</p>
<p>a.使用用户界面草图描述系统交互</p>
<p>b.制订系统参与者列表(及其描述)</p>
<p>c.制订系统用例列表(及其描述)</p>
<p>d.绘制系统用例图</p>
<p>e.制订系统用例调查表</p>
<p>f.确定系统用例的细节</p>
<p>g.给系统生成辅助需求</p>
<p>h.确定系统用例的优先级</p>
<p>9.分析：</p>
<p>a.绘制分析类图</p>
<p>b.制订属性列表(及其描述)</p>
<p>c.(可选)使用状态机给复杂的生命周期建模，在状态机图上记录结果</p>
<p>d.实现用例，使用通信图描述结果</p>
<p>e.制订操作列表(及其描述)</p>
<p>10.系统设计</p>
<p>a.选择技术</p>
<p>b.确定重用的可能性(库、模式和框架)</p>
<p>c.绘制层图</p>
<p>d.编写层交互策略</p>
<p>e.设计包结构，在包图上记录它</p>
<p>f.绘制部署图</p>
<p>g.制订安全策略</p>
<p>h.制订并发策略</p>
<p>11.子系统设计</p>
<p>a.定义业务服务</p>
<p>b.确定更多重用的可能性(库、模式和框架)</p>
<p>c.把分析类映射到业务层类上：类列表(及其描述)、类图、字段表(及其描述)。</p>
<p>d.生成数据库模式</p>
<p>e.为其他层设计类(例如服务器和协议、服务小程序、控制、持久)</p>
<p>f.实现业务服务，在顺序图上记录结果</p>
<p>g.制订消息列表(及其描述)</p>
<p>h.最后确定用户界面的设计</p>
<p>12.类的规范</p>
<p>a.为每个类生成非正式规范</p>
<p>b.在设计和源代码中记录非正式规范</p>
<p>13.实现</p>
<p>a.编写单元测试</p>
<p>b.编写实现代码</p>
<p>14.测试</p>
<p>a.让测试小组测试系统</p>
<p>b.修改错误</p>
<p>15.部署</p>
<p>a.生成手册和课件</p>
<p>b.在客户的系统上安装代码制品</p>
<p>c.培训客户</p>
<p>16.维护</p>
<p>a.修改错误</p>
<p>b.把顾客的反馈、改进意见和市场变化合并到新的递增版本中</p>
]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
  </entry>
  <entry>
    <title>产业经济学</title>
    <url>/%E7%BB%8F%E6%B5%8E/%E7%BB%8F%E6%B5%8E/%E4%BA%A7%E4%B8%9A%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>经济</category>
      </categories>
  </entry>
  <entry>
    <title>公共经济学</title>
    <url>/%E7%BB%8F%E6%B5%8E/%E7%BB%8F%E6%B5%8E/%E5%85%AC%E5%85%B1%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>经济</category>
      </categories>
  </entry>
  <entry>
    <title>区域经济学</title>
    <url>/%E7%BB%8F%E6%B5%8E/%E7%BB%8F%E6%B5%8E/%E5%8C%BA%E5%9F%9F%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>经济</category>
      </categories>
  </entry>
  <entry>
    <title>发展经济学</title>
    <url>/%E7%BB%8F%E6%B5%8E/%E7%BB%8F%E6%B5%8E/%E5%8F%91%E5%B1%95%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>经济</category>
      </categories>
  </entry>
  <entry>
    <title>国际经济学</title>
    <url>/%E7%BB%8F%E6%B5%8E/%E7%BB%8F%E6%B5%8E/%E5%9B%BD%E9%99%85%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>经济</category>
      </categories>
  </entry>
  <entry>
    <title>宏观经济学</title>
    <url>/%E7%BB%8F%E6%B5%8E/%E7%BB%8F%E6%B5%8E/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>经济</category>
      </categories>
  </entry>
  <entry>
    <title>彼得林奇的成功投资</title>
    <url>/%E7%BB%8F%E6%B5%8E/%E7%BB%8F%E6%B5%8E/%E5%BD%BC%E5%BE%97%E6%9E%97%E5%A5%87%E7%9A%84%E6%88%90%E5%8A%9F%E6%8A%95%E8%B5%84/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>经济</category>
      </categories>
  </entry>
  <entry>
    <title>微观经济学</title>
    <url>/%E7%BB%8F%E6%B5%8E/%E7%BB%8F%E6%B5%8E/%E5%BE%AE%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>经济</category>
      </categories>
  </entry>
  <entry>
    <title>打开量化投资的黑箱</title>
    <url>/%E7%BB%8F%E6%B5%8E/%E7%BB%8F%E6%B5%8E/%E6%89%93%E5%BC%80%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84%E7%9A%84%E9%BB%91%E7%AE%B1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>经济</category>
      </categories>
  </entry>
  <entry>
    <title>政治经济学</title>
    <url>/%E7%BB%8F%E6%B5%8E/%E7%BB%8F%E6%B5%8E/%E6%94%BF%E6%B2%BB%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>经济</category>
      </categories>
  </entry>
  <entry>
    <title>海龟交易法则</title>
    <url>/%E7%BB%8F%E6%B5%8E/%E7%BB%8F%E6%B5%8E/%E6%B5%B7%E9%BE%9F%E4%BA%A4%E6%98%93%E6%B3%95%E5%88%99/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>经济</category>
      </categories>
  </entry>
  <entry>
    <title>聪明的投资者</title>
    <url>/%E7%BB%8F%E6%B5%8E/%E7%BB%8F%E6%B5%8E/%E8%81%AA%E6%98%8E%E7%9A%84%E6%8A%95%E8%B5%84%E8%80%85/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>经济</category>
      </categories>
  </entry>
  <entry>
    <title>股票作手操盘术</title>
    <url>/%E7%BB%8F%E6%B5%8E/%E7%BB%8F%E6%B5%8E/%E8%82%A1%E7%A5%A8%E4%BD%9C%E6%89%8B%E6%93%8D%E7%9B%98%E6%9C%AF/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>经济</category>
      </categories>
  </entry>
  <entry>
    <title>股票大作手回忆录</title>
    <url>/%E7%BB%8F%E6%B5%8E/%E7%BB%8F%E6%B5%8E/%E8%82%A1%E7%A5%A8%E5%A4%A7%E4%BD%9C%E6%89%8B%E5%9B%9E%E5%BF%86%E5%BD%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>经济</category>
      </categories>
  </entry>
  <entry>
    <title>量化投资-策略与技术</title>
    <url>/%E7%BB%8F%E6%B5%8E/%E7%BB%8F%E6%B5%8E/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84-%E7%AD%96%E7%95%A5%E4%B8%8E%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>经济</category>
      </categories>
  </entry>
  <entry>
    <title>量化投资系统-平台、原理和可信性</title>
    <url>/%E7%BB%8F%E6%B5%8E/%E7%BB%8F%E6%B5%8E/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84%E7%B3%BB%E7%BB%9F-%E5%B9%B3%E5%8F%B0%E3%80%81%E5%8E%9F%E7%90%86%E5%92%8C%E5%8F%AF%E4%BF%A1%E6%80%A7/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>经济</category>
      </categories>
  </entry>
  <entry>
    <title>金融学</title>
    <url>/%E7%BB%8F%E6%B5%8E/%E7%BB%8F%E6%B5%8E/%E9%87%91%E8%9E%8D%E5%AD%A6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>经济</category>
      </categories>
  </entry>
  <entry>
    <title>高频交易</title>
    <url>/%E7%BB%8F%E6%B5%8E/%E7%BB%8F%E6%B5%8E/%E9%AB%98%E9%A2%91%E4%BA%A4%E6%98%93/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>经济</category>
      </categories>
  </entry>
  <entry>
    <title>IPv4和IPv6</title>
    <url>/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C/IPv4%E5%92%8CIPv6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>正向代理和反向代理</title>
    <url>/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/%E8%99%9A%E6%8B%9F%E5%8C%96/%E8%99%9A%E6%8B%9F%E5%8C%96/Docker/</url>
    <content><![CDATA[<h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="修改YUM源"><a href="#修改YUM源" class="headerlink" title="修改YUM源"></a>修改YUM源</h3><ol>
<li><p>备份<br>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</p>
</li>
<li><p>下载对应版本repo文件<br>wget <a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo" target="_blank" rel="noopener">http://mirrors.163.com/.help/CentOS7-Base-163.repo</a></p>
</li>
<li><p>运行以下命令生成缓存<br>yum clean all<br>yum makecache</p>
</li>
<li><p>安装docker<br>yum install docker</p>
</li>
</ol>
<h2 id="Docker-Registry搭建"><a href="#Docker-Registry搭建" class="headerlink" title="Docker Registry搭建"></a>Docker Registry搭建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v /data/registry:/var/lib/registry --restart=always --name registry registry:2</span><br><span class="line"># 配置非安全访问的仓库IP:端口号</span><br><span class="line">/etc/docker/daemon.json </span><br><span class="line">&quot;insecure-registries&quot;:[&quot;10.0.2.15:5000&quot;]</span><br><span class="line"></span><br><span class="line">docker push 192.168.1.62:5000/xpanda/busybox</span><br><span class="line">docker pull 192.168.1.62:5000/xpanda/busybox</span><br></pre></td></tr></table></figure>
<h2 id="常用Docker命令"><a href="#常用Docker命令" class="headerlink" title="常用Docker命令"></a>常用Docker命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search</span><br><span class="line">docker ps</span><br><span class="line">docker images</span><br><span class="line">#删除镜像</span><br><span class="line">docker rmi</span><br><span class="line">#删除容器实例</span><br><span class="line">docker rm</span><br><span class="line">#下载镜像</span><br><span class="line">docker pull quay.io/coreos/etcd:v3.2.16</span><br><span class="line">#构建镜像</span><br><span class="line">docker build -t xpanda/nginx:1.12.2 .</span><br><span class="line">#后台运行</span><br><span class="line">docker run -d -p 8080:8080 -p 443:443 --ip 10.20.0.1 -v /data/configs/nginx/conf.d:/etc/nginx/conf.d -v /data/configs/nginx/certs:/etc/nginx/certs xpanda/nginx:1.12.2</span><br><span class="line">#进入容器</span><br><span class="line">docker exec -it 5c61a04b14fc /bin/bash</span><br><span class="line">#日志查看</span><br><span class="line">docker logs -f --tail=100 6aa2172c8742</span><br><span class="line">journalctl -u docker.service -n</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernets</title>
    <url>/%E8%99%9A%E6%8B%9F%E5%8C%96/%E8%99%9A%E6%8B%9F%E5%8C%96/Kubernets/</url>
    <content><![CDATA[<p>##概念<br>kubernetes，简称K8s，是用8代替8个字符”ubernete”而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效(powerful),Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p>
<h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>k8s里的Master指的是集群控制节点，每个k8s集群里需要有一个Master节点来负责整个集群的管理和控制，基本上k8s所有的控制命令都是发给它，它来负责具体的执行过程。<br>Master节点上运行着以下一组关键进程。</p>
<ol>
<li><p>kube-apiserver<br>提供了Http Rest接口的关键服务进程，是k8s里所有资源的增删改查等操作的唯一入口，也是集群控制的入口进程。</p>
</li>
<li><p>kube-controller-manager<br>k8s里所有资源对象的自动化控制中心。</p>
</li>
<li><p>kube-scheduler<br>负责资源调度(Pod调度)的进行。</p>
</li>
<li><p>etcd Server<br>k8s里的所有资源对象的数据全部是保存在etcd中。</p>
</li>
</ol>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>除了Master, k8s集群中的其他机器被称为Node节点，在较早的版本中也被成为Minion。Node节点是k8s集群中的工作负载节点，每个Node都会被Master分配一些工作负载(Docker容器)，当某个Node宕机时，其上的工作负载会被Master自动转移到其他节点上去。<br>Node节点上运行着以下一组关键进程。</p>
<ol>
<li><p>kubelet<br>负责Pod对应的容器的创建、启停等任务，同时与Master节点密切协作，实现集群管理的基本功能。</p>
</li>
<li><p>kube-proxy<br>实现K8s Service的通信与负载均衡机制的重要组件。</p>
</li>
<li><p>Docker Engine<br>Docker引擎，负责本机的容器创建和管理工作。</p>
</li>
</ol>
<p>默认情况下kubelet会向Master注册自己，并定时向Master节点汇报自身的情况。当某个Node超过指定的时间不上报信息时，会被Master判定为”失联”。</p>
<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod是k8s的最重要也最基本的概念。每个Pod都有一个特殊的被称为”根容器”的Pause容器。Pause容器对应的镜像属于k8s平台的一部分，除了Pause容器，每个Pod还包含一个或多个紧密相关的用户业务容器。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">yum install -y docker etcd kubernetes</span><br><span class="line">vi /etc/sysconfig/docker</span><br><span class="line">OPTIONS='--selinux-enabled=false --log-driver=journald --signature-verification=false'</span><br><span class="line">systemctl start etcd</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl start kube-apiserver</span><br><span class="line">systemctl start kube-controller-manager</span><br><span class="line">systemctl start kube-scheduler</span><br><span class="line">systemctl start kubelet</span><br><span class="line">systemctl start kube-proxy</span><br></pre></td></tr></table></figure>
<h3 id="minikube"><a href="#minikube" class="headerlink" title="minikube"></a>minikube</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line">yum install -y kubectl</span><br><span class="line"></span><br><span class="line">curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 \</span><br><span class="line">  &amp;&amp; chmod +x minikube</span><br><span class="line"></span><br><span class="line">sudo mkdir -p /usr/local/bin/</span><br><span class="line">sudo install minikube /usr/local/bin/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">minikube start --vm-driver=none --image-mirror-country='cn' --image-repository='registry.cn-hangzhou.aliyuncs.com/google_containers' --apiserver-ips=['192.168.0.1'] --service-cluster-ip-range=192.168.0.0/16</span><br></pre></td></tr></table></figure>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>定义RC文件<br>定义SVC文件</p>
<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create -f mysql-rc.yaml</span><br><span class="line">kubectl create -f mysql-svc.yaml</span><br></pre></td></tr></table></figure>
<h3 id="myweb"><a href="#myweb" class="headerlink" title="myweb"></a>myweb</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create -f myweb-rc.yaml</span><br><span class="line">kubectl get rc</span><br><span class="line">kubectl get pod</span><br><span class="line">kubectl create -f myweb-svc.yaml</span><br><span class="line">kubectl get svc</span><br></pre></td></tr></table></figure>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="unable-to-create-pods-No-API-token-found-for-service-account-“default”"><a href="#unable-to-create-pods-No-API-token-found-for-service-account-“default”" class="headerlink" title="unable to create pods: No API token found for service account “default”"></a>unable to create pods: No API token found for service account “default”</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/kubernetes/apiserver </span><br><span class="line">KUBE_ADMISSION_CONTROL=&quot;--admission-control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ServiceAccount,ResourceQuota&quot;</span><br><span class="line"># 去除SecurityContextDeny,ServiceAccount</span><br><span class="line"># 重启</span><br><span class="line">systemctl restart kube-apiserver</span><br></pre></td></tr></table></figure>
<h3 id="No-such-image-registry-access-redhat-com-rhel7-pod-infrastructure-latest”"><a href="#No-such-image-registry-access-redhat-com-rhel7-pod-infrastructure-latest”" class="headerlink" title="No such image: registry.access.redhat.com/rhel7/pod-infrastructure:latest”"></a>No such image: registry.access.redhat.com/rhel7/pod-infrastructure:latest”</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search pod-infrastructure</span><br><span class="line">docker pull docker.io/tianyebj/pod-infrastructure</span><br><span class="line">docker tag docker.io/tianyebj/pod-infrastructure 10.0.2.15:5000/pod-infrastructure</span><br><span class="line">docker push 10.0.2.15:5000/pod-infrastructure</span><br><span class="line"># 配置基础镜像</span><br><span class="line">vi /etc/kubernetes/kubelet </span><br><span class="line">KUBELET_POD_INFRA_CONTAINER=&quot;--pod-infra-container-image=10.0.2.11:5000/pod-infrastructure:latest&quot;</span><br><span class="line"></span><br><span class="line">systemctl restart kube-apiserver</span><br><span class="line">systemctl restart kube-controller-manager</span><br><span class="line">systemctl restart kube-scheduler</span><br><span class="line">systemctl restart kubelet</span><br><span class="line">systemctl restart kube-proxy</span><br></pre></td></tr></table></figure>
<h3 id="“cgroupfs”-is-different-from-docker-cgroup-driver-“systemd”"><a href="#“cgroupfs”-is-different-from-docker-cgroup-driver-“systemd”" class="headerlink" title="“cgroupfs” is different from docker cgroup driver: “systemd”"></a>“cgroupfs” is different from docker cgroup driver: “systemd”</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">"exec-opts": ["native.cgroupdriver=cgroupfs"]</span><br><span class="line"><span class="meta">#</span> 或者</span><br><span class="line">vi /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure>
<h3 id="Error-loading-config-file-“-var-lib-minikube-kubeconfig”-open-var-lib-minikube-kubeconfig-permission-denied"><a href="#Error-loading-config-file-“-var-lib-minikube-kubeconfig”-open-var-lib-minikube-kubeconfig-permission-denied" class="headerlink" title="Error loading config file “/var/lib/minikube/kubeconfig”: open /var/lib/minikube/kubeconfig: permission denied"></a>Error loading config file “/var/lib/minikube/kubeconfig”: open /var/lib/minikube/kubeconfig: permission denied</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>
<h3 id="Failed-to-get-system-container-stats-for-“-system-slice-kubelet-service”"><a href="#Failed-to-get-system-container-stats-for-“-system-slice-kubelet-service”" class="headerlink" title="Failed to get system container stats for “/system.slice/kubelet.service”"></a>Failed to get system container stats for “/system.slice/kubelet.service”</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</span><br><span class="line">--runtime-cgroups=/systemd/system.slice --kubelet-cgroups=/systemd/system.slice</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure>
<h3 id="Failed-to-list-v1-Endpoints-Get-https-10-96-0-1-443-api-v1-endpoints-limit-500-amp-resourceVersion-0"><a href="#Failed-to-list-v1-Endpoints-Get-https-10-96-0-1-443-api-v1-endpoints-limit-500-amp-resourceVersion-0" class="headerlink" title="Failed to list *v1.Endpoints: Get https://10.96.0.1:443/api/v1/endpoints?limit=500&amp;resourceVersion=0:"></a>Failed to list *v1.Endpoints: Get <a href="https://10.96.0.1:443/api/v1/endpoints?limit=500&amp;resourceVersion=0" target="_blank" rel="noopener">https://10.96.0.1:443/api/v1/endpoints?limit=500&amp;resourceVersion=0</a>:</h3><p>当您使用kubeadm init时，请指定pod-network-cidr。确保主机/主网络的IP不在您引用的子网中。<br>即如果您的网络运行在192.168.<em>.</em>使用10.0.0.0/16<br>如果您的网络是10.0.<em>.</em>使用192.168.0.0/16<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--pod-network-cidr=192.168.0.0/16</span><br><span class="line"><span class="meta">#</span> minikube</span><br><span class="line">--service-cluster-ip-range=192.168.0.0/16</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 增加路由规则minikube ip查询出10.0.2.15</span><br><span class="line">ip route add 192.168.0.0/16 via 10.0.2.15</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成-存储器</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
  </entry>
  <entry>
    <title>C++-命名规范</title>
    <url>/%E8%AF%AD%E8%A8%80/%E8%AF%AD%E8%A8%80/Cplusplus-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>格式：作用域部分+类型部分+描述部分</p>
<p>例如：m_nMax,g_nMin</p>
<h2 id="作用域部分"><a href="#作用域部分" class="headerlink" title="作用域部分"></a>作用域部分</h2><table>
<thead>
<tr>
<th></th>
<th>前缀</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>作用域部分</td>
<td>无</td>
<td>局部变量</td>
</tr>
<tr>
<td>作用域部分</td>
<td>m_</td>
<td>类的成员变量(member)</td>
</tr>
<tr>
<td>作用域部分</td>
<td>sm_</td>
<td>类的静态成员变量(static member)</td>
</tr>
<tr>
<td>作用域部分</td>
<td>s_</td>
<td>静态变量(static)</td>
</tr>
<tr>
<td>作用域部分</td>
<td>c_</td>
<td>常量(const)</td>
</tr>
<tr>
<td>作用域部分</td>
<td>g_</td>
<td>外部全局变量(global)</td>
</tr>
<tr>
<td>作用域部分</td>
<td>sg_</td>
<td>静态全局变量(static global)</td>
</tr>
<tr>
<td>作用域部分</td>
<td>gg_</td>
<td>进程或动态链接库间共享的全局变量(global global)</td>
</tr>
</tbody>
</table>
<h2 id="类型部分"><a href="#类型部分" class="headerlink" title="类型部分"></a>类型部分</h2><table>
<thead>
<tr>
<th></th>
<th>前缀</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型部分</td>
<td>u</td>
<td>unsigned</td>
</tr>
<tr>
<td>类型部分</td>
<td>by</td>
<td>BYTE</td>
</tr>
<tr>
<td>类型部分</td>
<td>n</td>
<td>整数和位域变量</td>
</tr>
<tr>
<td>类型部分</td>
<td>e</td>
<td>枚举型变量</td>
</tr>
<tr>
<td>类型部分</td>
<td>ch</td>
<td>char</td>
</tr>
<tr>
<td>类型部分</td>
<td>sz</td>
<td>char[]</td>
</tr>
<tr>
<td>类型部分</td>
<td>l</td>
<td>long</td>
</tr>
<tr>
<td>类型部分</td>
<td>b</td>
<td>布尔</td>
</tr>
<tr>
<td>类型部分</td>
<td>f</td>
<td>浮点</td>
</tr>
<tr>
<td>类型部分</td>
<td>p</td>
<td>指针</td>
</tr>
<tr>
<td>类型部分</td>
<td>r</td>
<td>引用</td>
</tr>
<tr>
<td>类型部分</td>
<td>arr</td>
<td>数组</td>
</tr>
<tr>
<td>类型部分</td>
<td>h</td>
<td>句柄</td>
</tr>
</tbody>
</table>
<h2 id="描述部分"><a href="#描述部分" class="headerlink" title="描述部分"></a>描述部分</h2><table>
<thead>
<tr>
<th></th>
<th>前缀</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>描述部分</td>
<td>Max</td>
<td>最大</td>
</tr>
<tr>
<td>描述部分</td>
<td>Min</td>
<td>最小</td>
</tr>
<tr>
<td>描述部分</td>
<td>Temp</td>
<td>临时</td>
</tr>
<tr>
<td>描述部分</td>
<td>Src</td>
<td>源</td>
</tr>
<tr>
<td>描述部分</td>
<td>Dest</td>
<td>目标</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>C++-标准库简介</title>
    <url>/%E8%AF%AD%E8%A8%80/%E8%AF%AD%E8%A8%80/Cplusplus-%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="C-标准的历史"><a href="#C-标准的历史" class="headerlink" title="C++标准的历史"></a>C++标准的历史</h2><ol>
<li><p>C++98<br>于1998年批准，是第一份C++标准规格。官方名称是Information Technology - Programming Languages - C++,文档编号ISO/IEC 14882:1998</p>
</li>
<li><p>C++03<br>这是个所谓“技术勘误”(technical corrigendum, TC)，内含不甚严重的C++98 bug 修正。文档编号ISO/IEC 14882:2003。</p>
</li>
<li><p>TR1<br>内含大幅度的标准库扩充。官方名称是Information Technology - Programming Languages -Technical Report on C++ Library Extensions,文档编号 ISO/IEC TR 19768:2007。它所涵盖的扩充全部包含于namespace std::tr1内。</p>
</li>
<li><p>C++11<br>批准于2011年，是第二份C++标准。官方名称Information Technology - Programming Languages -C++,文档编号ISO/IEC 14882:2011。</p>
</li>
</ol>
<h2 id="C-98和C-11的兼容性"><a href="#C-98和C-11的兼容性" class="headerlink" title="C++98和C++11的兼容性"></a>C++98和C++11的兼容性</h2><p>C++的设计目标之一是，对C++98保持向后兼容。</p>
<ol>
<li><p>C+11</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define __cplusplus 201103L</span><br></pre></td></tr></table></figure>
</li>
<li><p>c++98和c++03</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define __cplusplus 199711L</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>向后兼容仅适用于源码，不保证二进制兼容。所以请以C++11编译器重新编译C++98程序的每一份源码。</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>C++标准程序库-通用工具</title>
    <url>/%E8%AF%AD%E8%A8%80/%E8%AF%AD%E8%A8%80/Cplusplus%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93-%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="Pair和Tuple"><a href="#Pair和Tuple" class="headerlink" title="Pair和Tuple"></a>Pair和Tuple</h2><p>Class pair可将两个value视为一个单元。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pair</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		T1 first;</span><br><span class="line">		T2 second;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不定数的值组<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">tuple</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Smart-Pointer"><a href="#Smart-Pointer" class="headerlink" title="Smart Pointer"></a>Smart Pointer</h2><p>自c++ 11起，c++标准库提供两大类型的smart pointer</p>
<ol>
<li>shared_ptr(共享式指针)<br>多个smart pointer可以指向相同对象，该对象和其相关资源会在“最后一个reference被销毁”时被释放。</li>
<li>unique_ptr(独占式拥有)<br>保证同一时间内只有一个smart pointer可以指向该对象。</li>
</ol>
<h2 id="数值的极值"><a href="#数值的极值" class="headerlink" title="数值的极值"></a>数值的极值</h2><p>数值类型有着与平台相依的极值。<br>numeric_limits&lt;&gt;<br>|类型|最小长度|<br>|–|–|<br>|char|1 byte|<br>|short int|2 byte|<br>|int|2 byte|<br>|long int|4 byte|<br>|long long int|8 byte|<br>|float|4 byte|<br>|double|8 byte|<br>|long double|8 byte|</p>
<h2 id="Type-Trait和Type-Utility"><a href="#Type-Trait和Type-Utility" class="headerlink" title="Type Trait和Type Utility"></a>Type Trait和Type Utility</h2><p>type trait提供一种用来处理type属性的方法。可以用来检查类型的性质，类型的比较。</p>
<h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><p>选择最小值、最大值、交换两值</p>
<h2 id="ratio"><a href="#ratio" class="headerlink" title="ratio"></a>ratio</h2><p>编译器分数运算</p>
<h2 id="Clock和Timer"><a href="#Clock和Timer" class="headerlink" title="Clock和Timer"></a>Clock和Timer</h2><p>处理日期和时间的程序库。</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript-ES5</title>
    <url>/%E8%AF%AD%E8%A8%80/%E8%AF%AD%E8%A8%80/JavaScript-ES5/</url>
    <content><![CDATA[<p>一个完整的JavaScript实现包含了三个部分：<br>1.核心(ECMAScript)<br>2.文档对象模型(DOM)<br>3.浏览器对象模型(BOM)</p>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>ECMAScript 5引入了严格模式。在严格模式下ECMAScript 3的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。<br>整个脚本中启动严格模式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br></pre></td></tr></table></figure></p>
<p>在函数内启动严格模式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function doSomething()&#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>ECMAScript的变量是松散类型的，可以用来保存任何类型的数据。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var message;</span><br></pre></td></tr></table></figure></p>
<p>ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>ECMAScript不支持任何创建自定义类型的机制，所有值都最终将是6种数据类型之一。</p>
<ol>
<li><p>Undefined。Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是Undefined。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var message;</span><br><span class="line">alert(message == undefined); // true</span><br></pre></td></tr></table></figure>
</li>
<li><p>Null<br>Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值会返回”object”的原因。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var car = null;</span><br><span class="line">alert(typeof car); // &quot;object&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Boolean<br>该类型只有两个字面值：true和false。这两个值与数字值不是一回事，因此true不一定等于1，而false也不一定等于0。</p>
</li>
<li>Number<br>这种类型使用IEEE754格式来表示整数和浮点数值。</li>
<li>String<br>String类型用于表示由零或多个16位Unicode字符组成的字符序列。</li>
<li>Object<br>ECMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。</li>
</ol>
<h3 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h3><p>用来检测给定变量的数据类型。typeof操作符可能返回下列某个字符串。</p>
<ul>
<li>“undefined”-如果这个值未定义</li>
<li>“boolean”-如果这个值是布尔值</li>
<li>“string”-如果这个值是字符串</li>
<li>“number”-如果这个值是数值</li>
<li>“object”-如果这个值是对象或Null</li>
<li>“function”-如果这个值是函数</li>
</ul>
<p>typeof 操作符会返回一些令人迷惑但技术上却正确的值。比如，调用<code>typeof null</code>会返回<code>object</code>，因为特殊值<code>null</code>被认为是一个空的对象引用。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>ECMAScript中的函数使用function关键字来声明，后跟一组参数以及函数体。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function functionName(arg0, arg1, ..., argN)&#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>严格模式对函数有一些限制：</p>
<ul>
<li>不能把函数命名为eval或arguments;</li>
<li>不能把参数命名为eval或arguments;</li>
<li>不能出现两个命名参数同名的情况</li>
</ul>
<p>ECMAScript中的参数在内部是用一个数组来表示的。即便你定义的函数只接收两个参数，在调用这个函数时也未必一定要传递两个参数。在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。命名的参数只提供便利，但不是必须的。</p>
<h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>如果在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。</p>
<h2 id="执行环节及作用域"><a href="#执行环节及作用域" class="headerlink" title="执行环节及作用域"></a>执行环节及作用域</h2><p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。<br>全局执行环境是最外围的一个执行环境。在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript-ES6</title>
    <url>/%E8%AF%AD%E8%A8%80/%E8%AF%AD%E8%A8%80/JavaScript-ES6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>汇编语言-基础知识</title>
    <url>/%E8%AF%AD%E8%A8%80/%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>机器语言是机器指令的集合。电子计算机的机器指令是一列二进制数字，计算机将之转变为一列高低电平，以使计算机的电子器件受到驱动，进行运算。</p>
<p>汇编语言的主体是汇编指令。汇编指令是机器指令便于记忆的书写格式。然后由汇编编译器将其编译为机器码，由计算机最终执行。</p>
<p>例如：<br>操作：寄存器BX的内容送到AX中<br>机器指令：1000100111011000<br>汇编指令：mov ax,bx</p>
<p>汇编语言发展至今，由以下3类指令组成。</p>
<ul>
<li>汇编指令：机器码的助记符，有对应的机器码。</li>
<li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行。</li>
<li>其他符号：如：+、-、*、/等，由编译器识别，没有对应的机器码。</li>
</ul>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>一个典型的CPU由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。</p>
<p>对于一个汇编程序员来说，CPU中的主要部件是寄存器。寄存器是CPU中程序员可以用指令读写的部件。通过改变各种寄存器中的内容来实现对CPU的控制。</p>
<p>不同的CPU，寄存器的个数、结构是不相同的。8086CPU有14个寄存器，每个寄存器有一个名称。8086CPU的所有寄存器都是16位的，可以存放两个字节。这些寄存器是：AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW。</p>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>AX,BX,CX,DX四个寄存器通常用来存放一般性的数据，被称为通用寄存器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,18</span><br><span class="line">add ax,8</span><br><span class="line">mov ax,bx</span><br></pre></td></tr></table></figure>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><p>8086CPU有4个段寄存器：CS,DS,SS,ES。</p>
<p>8086CPU在访问内存时要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># jmp 段地址：偏移地址</span><br><span class="line">jmp 2AE3:3</span><br></pre></td></tr></table></figure>
<h3 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h3><p>CS和IP指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令指针寄存器。</p>
<h3 id="DS"><a href="#DS" class="headerlink" title="DS"></a>DS</h3><p>8086CPU中有一个DS寄存器，通常用来存放要访问数据的段地址。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx</span><br><span class="line">mov al,[0]</span><br></pre></td></tr></table></figure></p>
<p>[0]中的0表示内存单元的偏移地址。内存单元的段地址自动取DS中的数据为内存单元的段地址。同时，不能直接将数据送入段寄存器，必须通过另外一个寄存器来进行中转，例如这里的bx。</p>
<h3 id="SS和SP"><a href="#SS和SP" class="headerlink" title="SS和SP"></a>SS和SP</h3><p>8086CPU中，有两个寄存器，段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>8086CPU提供相关的指令来以栈的方式访问内存空间。8086CPU提供入栈和出栈指令，最基本的两个是PUSH(入栈)和POP(出栈)。<br>有相应的两个寄存器来存放栈顶的地址，段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">push 寄存器：将一个寄存器中的数据入栈</span><br><span class="line">pop 寄存器:出栈，用一个寄存器接收出栈的数据</span><br></pre></td></tr></table></figure>
<blockquote>
<p>栈顶超界<br>8086CPU不保证我们对栈的操作不会超界，因此我们在编程的时候要自己操心栈顶超界的问题。实模式下没有任何保护，虚模式下由操作系统进行保护。</p>
</blockquote>
<blockquote>
<p>实模式：80386处理器被复位或加电的时候以实模式启动，在实模式下，所有的段都是可以读、写和执行的。实模式下处理器没有硬件级的内存保护概念和多道任务的工作模式。<br>保护模式：又被称作虚拟地址保护模式。保护模式的特性是阻止被其他任务或系统内核破坏已经不健全的程序的运行。<br>虚模式：虚模式是以任务形式在保护模式上执行的。</p>
</blockquote>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>任何一个通用的CPU，都具备一种能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息（中断信息），并且可以立即对所接收到的信息进行处理。</p>
<h3 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h3><p>当CPU内部有下面的情况发生的时候，将产生相应的中断信息：</p>
<ol>
<li>除法错误</li>
<li>单步执行</li>
<li>执行int0指令</li>
<li>执行int指令</li>
</ol>
<p>CPU根据中断类型码的数据来标识中断信息的来源。中断类型码为一个字节型数据，可以表示256种中断信息的来源。</p>
<table>
<thead>
<tr>
<th>中断源</th>
<th>中断类型码</th>
</tr>
</thead>
<tbody>
<tr>
<td>除法错误</td>
<td>0</td>
</tr>
<tr>
<td>单步执行</td>
<td>1</td>
</tr>
<tr>
<td>执行int0指令</td>
<td>4</td>
</tr>
<tr>
<td>执行int指令</td>
<td>指令的格式为int n，指令中的n为字节型数字，是提供给CPU的中断类型码</td>
</tr>
</tbody>
</table>
<h3 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h3><p>当CPU外部有需要处理的事情发生的时候，比如说，外设的输入到达，相关芯片将向CPU发出相应的中断信息。CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。</p>
<p>### </p>
<h2 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h2><p>通过将指令放入CS和IP中，交由CPU执行指令，将数据在AX和BX进行中转，再经DS放回到内存中。</p>
<h1 id="Degbug"><a href="#Degbug" class="headerlink" title="Degbug"></a>Degbug</h1><p>Debug是DOS、Windows都提供的实模式程序的调试工具。使用它，可以查看CPU各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。</p>
<h2 id="进入Debug"><a href="#进入Debug" class="headerlink" title="进入Debug"></a>进入Debug</h2><p>开始&gt;运行&gt;command&gt;debug</p>
<h2 id="Debug常用命令"><a href="#Debug常用命令" class="headerlink" title="Debug常用命令"></a>Debug常用命令</h2><ul>
<li>R命令：查看、修改CPU中寄存器的值</li>
<li>D命令：查看内存中的内容</li>
<li>E命令：改写内存中的内容</li>
<li>U命令：查看机器码对应的汇编指令</li>
<li>T命令：执行当前指令</li>
<li>A命令：以汇编指令的形式在内存中写入机器指令</li>
</ul>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言-程序</title>
    <url>/%E8%AF%AD%E8%A8%80/%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start: mov ax,0123H</span><br><span class="line">       mov bx,0456H</span><br><span class="line">       add ax,bx</span><br><span class="line">       add ax,ax</span><br><span class="line"></span><br><span class="line">       mov ax,4c00H</span><br><span class="line">       int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="可执行程序装入内存并运行的原理"><a href="#可执行程序装入内存并运行的原理" class="headerlink" title="可执行程序装入内存并运行的原理"></a>可执行程序装入内存并运行的原理</h2><p>在DOS中，可执行文件中的程序P1若要运行，必须要有一个正在运行的程序P2，将P1从可执行文件中加载入内存，将CPU的控制权交给它，P1才能得以运行；当P1运行完毕后，应该将CPU的控制权交还给是它得以运行的程序P2。</p>
<ol>
<li>我们在DOS中直接执行1.exe时，是正在运行的command，将1.exe中的程序加载入内存。</li>
<li>command设置CPU的CS:IP指向程序的第一条指令（即程序的入口），从而使程序得以运行。</li>
<li>程序运行结束后，返回到command中，CPU继续运行command。</li>
</ol>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>编译器-介绍</title>
    <url>/%E8%AF%AD%E8%A8%80/%E8%AF%AD%E8%A8%80/%E7%BC%96%E8%AF%91%E5%99%A8-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="语言处理器"><a href="#语言处理器" class="headerlink" title="语言处理器"></a>语言处理器</h2><p>编译器：阅读以某一种语言(源语言)编写的程序，并把该程序翻译成为一个等价的、用另一种语言(目标语言)编写的程序。<br>解释器：并不通过翻译的方式生成目标程序，直接利用用户提供的输入执行源程序中指定的操作。</p>
<table>
<thead>
<tr>
<th>编译器</th>
<th>解释器</th>
</tr>
</thead>
<tbody>
<tr>
<td>执行速度更快</td>
<td>错误诊断效果更好</td>
</tr>
</tbody>
</table>
<p>创建可执行的目标执行还需要的其他程序，比如<br>预处理器：把分割为多个模块的源程序聚合在一起。<br>汇编器：生成可重定位的机器代码。<br>加载器：把所有的可执行目标文件放到内存中执行。</p>
<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><img src="/语言/语言/编译器-介绍/编译器-介绍-1.jpeg">
<img src="/语言/语言/编译器-介绍/编译器-介绍-1.jpeg">
<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法分析器读取组成源程序的字符流，并且将它们组织成为有意义的词素的序列。<br>对于每个词素，词法分析器产生如下形式的词法单元(token)作为输出。<br>(token-name, attribute-value)</p>
<p>比如：<br>position = initial + rate * 60</p>
<ul>
<li>position是一个词素，被映射成(id,1)，其中id表示标识符的抽象符号，而1指向符号表中position对应的条目。</li>
<li>=是一个词素，被映射成(=)，因为不需要属性值，所以忽略第二个分量。</li>
<li>initial是一个词素，被映射成(id,2)</li>
<li>+是一个词素，被映射成(+)</li>
<li>rate是一个词素，被映射成(id,3)</li>
<li><em>是一个词素，被映射成(</em>)</li>
<li>60是一个词素，被映射成(60)<br>(id, 1)(=)(id,2)(+)(id,3)(*)(60)</li>
</ul>
<h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>符号表数据结构为每个变量名字创建了一个记录条目。记录的字段就是名字的各个属性，包括存储分配、类型、作用域等，过程名字包括参数数量和类型、传递方法(传值或传引用)、返回类型等。<br>|1|position|…|<br>|-|–|–|<br>|2|initial|…|<br>|3|rate|…|<br>||||</p>
<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法分析器使用由词法分析器生成的各个词法单元的第一个分量来创建树形的中间表示。一个常用的表示方法是语法树，树中的每个内部节点表示一个运算，而该节点的子节点表示该运算的分量。</p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>使用语法书和符号表中的信息来检查源程序是否和语言定义的语义一直。它同时也收集类型信息，并把这些信息存放在语法树或符号表中，以便在随后的中间代码生成过程中使用。<br>语义分析的一个重要部分是类型检查。</p>
<h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p>在把一个源程序翻译成目标代码的过程中，一个编译器可能构造出一个或多个中间表示。这些中间表示可以有多种形式。语法树是一种中间表示形式。</p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>机器无关的代码优化步骤试图改进中间代码，以便生成更好的目标代码。</p>
<h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>代码生成器以源程序的中间表示形式作为输入，并把它映射到目标语言。</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>Ansible</title>
    <url>/%E8%BF%90%E7%BB%B4/%E8%BF%90%E7%BB%B4/Ansible/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>运维</category>
      </categories>
  </entry>
  <entry>
    <title>Linux常用命令-awk</title>
    <url>/%E8%BF%90%E7%BB%B4/%E8%BF%90%E7%BB%B4/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-awk/</url>
    <content><![CDATA[<h2 id="awk命令形式"><a href="#awk命令形式" class="headerlink" title="awk命令形式"></a>awk命令形式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk [-F|-f|-v] ‘BEGIN&#123;&#125; //&#123;command1; command2&#125; END&#123;&#125;’ file</span><br><span class="line">awk '&#123;print $0&#125;' /etc/passwd</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[-F\</td>
<td>-f\</td>
<td>-v]</td>
<td>大参数，-F指定分隔符，-f调用脚本，-v定义变量 var=value</td>
</tr>
<tr>
<td>‘  ‘</td>
<td>引用代码块</td>
</tr>
<tr>
<td>BEGIN</td>
<td>初始化代码块，在对每一行进行处理之前，初始化代码，主要是引用全局变量，设置FS分隔符</td>
</tr>
<tr>
<td>//</td>
<td>匹配代码块，可以是字符串或正则表达式</td>
</tr>
<tr>
<td>{}</td>
<td>命令代码块，包含一条或多条命令</td>
</tr>
<tr>
<td>;</td>
<td>多条命令使用分号分隔</td>
</tr>
<tr>
<td>END</td>
<td>结尾代码块，在对每一行进行处理之后再执行的代码块，主要是进行最终计算或输出结尾摘要信息</td>
</tr>
</tbody>
</table>
<h2 id="常用-awk-内置变量"><a href="#常用-awk-内置变量" class="headerlink" title="常用 awk 内置变量"></a>常用 awk 内置变量</h2><table>
<thead>
<tr>
<th>变量名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0</td>
<td>当前记录</td>
</tr>
<tr>
<td>$1-$n</td>
<td>当前记录的第n个字段</td>
</tr>
<tr>
<td>FS</td>
<td>输入字段分隔符，默认是空格</td>
</tr>
<tr>
<td>RS</td>
<td>输入记录分隔符，默认是换行符</td>
</tr>
<tr>
<td>NF</td>
<td>当前记录中的字段个数</td>
</tr>
<tr>
<td>NR</td>
<td>已经读出的记录数</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段分隔符，默认是空格</td>
</tr>
<tr>
<td>ORS</td>
<td>输出的记录分隔符，默认是换行符</td>
</tr>
</tbody>
</table>
<h3 id="BEGIN设置"><a href="#BEGIN设置" class="headerlink" title="BEGIN设置"></a>BEGIN设置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk 'BEGIN&#123;FS=":"&#125;&#123;print $1","$2","$3&#125;' hello.txt</span><br></pre></td></tr></table></figure>
<h2 id="正则应用"><a href="#正则应用" class="headerlink" title="正则应用"></a>正则应用</h2><h3 id="规则表达式"><a href="#规则表达式" class="headerlink" title="规则表达式"></a>规则表达式</h3><p><code>awk &#39;/REG/{action} &#39; file</code>,/REG/为正则表达式，可以将$0 中，满足条件的记录送入到：action 进行处理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk '/root/&#123;print $0&#125;' passwd</span><br></pre></td></tr></table></figure>
<h3 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h3><p><code>awk &#39;布尔表达式{action}&#39; file</code>仅当对前面的布尔表达式求值为真时， awk 才执行代码块。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F: '$1=="root"&#123;print $0&#125;' passwd</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>OPNsense</title>
    <url>/%E8%BF%90%E7%BB%B4/%E8%BF%90%E7%BB%B4/OPNsense/</url>
    <content><![CDATA[<h2 id="1-软路由"><a href="#1-软路由" class="headerlink" title="1  软路由"></a>1  软路由</h2><p>软路由是指利用台式机或服务器配合软件形成路由解决方案，主要靠软件的设置，达成路由器的功能；而硬路由则是以特用的硬设备，包括处理器、电源供应、嵌入式软件，提供设定的路由器功能。</p>
<h2 id="2-OPNsense"><a href="#2-OPNsense" class="headerlink" title="2  OPNsense"></a>2  OPNsense</h2><p>OPNsense 是一个开源易用，而且易于构建的基于 FreeBSD 的防火墙和路由平台。包括大多数商业防火墙的特性。提供功能完整却易用的 GUI 管理界面。</p>
<h2 id="3-安装步骤"><a href="#3-安装步骤" class="headerlink" title="3  安装步骤"></a>3  安装步骤</h2><h3 id="3-1-新建虚拟机"><a href="#3-1-新建虚拟机" class="headerlink" title="3.1  新建虚拟机"></a>3.1  新建虚拟机</h3><ul>
<li>操作系统<pre><code>选择&quot;其他&quot;-&quot;FreeBSD&quot;
</code></pre></li>
<li>网络连接<pre><code>选择“使用桥接网络”
</code></pre></li>
<li>自定义硬件<pre><code>选择&quot;添加&quot;-“网络适配器”-&quot;桥接模式&quot;
</code></pre></li>
<li>其他保持默认</li>
<li>CD/DVD中装入ISO文件</li>
<li><h3 id="3-2-启动虚拟机"><a href="#3-2-启动虚拟机" class="headerlink" title="3.2  启动虚拟机"></a>3.2  启动虚拟机</h3>默认安装后，重新启动</li>
</ul>
<h3 id="3-3-配置OPNsense"><a href="#3-3-配置OPNsense" class="headerlink" title="3.3  配置OPNsense"></a>3.3  配置OPNsense</h3><p>账号:root<br>密码:opnsense</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
  </entry>
  <entry>
    <title>OpenVPN</title>
    <url>/%E8%BF%90%E7%BB%B4/%E8%BF%90%E7%BB%B4/OpenVPN/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --cap-add NET_ADMIN -p 2294:2294 -d centos:7 /bin/bash -lc "tail -f /dev/null"</span><br><span class="line"></span><br><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y openvpn easy-rsa</span><br><span class="line"></span><br><span class="line">cd /usr/share/easy-rsa/3</span><br><span class="line">./easyrsa init-pki</span><br><span class="line">./easyrsa build-ca</span><br><span class="line">./easyrsa build-server-full server nopass</span><br><span class="line">./easyrsa build-client-full client nopass</span><br><span class="line">./easyrsa gen-dh</span><br><span class="line">openvpn --genkey --secret ./pki/ta.key </span><br><span class="line">cp -pR /usr/share/easy-rsa/3/pki/&#123;issued,private,ca.crt,dh.pem,ta.key&#125; /etc/openvpn/server/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> https://github.com/OpenVPN</span><br><span class="line">curl -O -L https://github.com/OpenVPN/openvpn/archive/v2.4.8.tar.gz</span><br><span class="line">cp /root/openvpn-2.4.8/sample/sample-config-files/server.conf /etc/openvpn/server/</span><br><span class="line">vi /etc/openvpn/server/server.conf</span><br><span class="line"></span><br><span class="line">10.8.0.0/24，下一跳为VPN服务器的内网地址192.168.60.113</span><br><span class="line"></span><br><span class="line">mkdir /dev/net -pv</span><br><span class="line">mknod /dev/net/tun c 10 200</span><br><span class="line">chmod 666 /dev/net/tun</span><br><span class="line"></span><br><span class="line">openvpn --config /etc/openvpn/server/server.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> line 32: change if need (listening port of OpenVPN)</span><br><span class="line">port 1194</span><br><span class="line"><span class="meta">#</span> line 35: change if need</span><br><span class="line">proto tcp</span><br><span class="line">;proto udp</span><br><span class="line"><span class="meta">#</span> line 78: specify certificates</span><br><span class="line">ca /etc/openvpn/server/ca.crt</span><br><span class="line">cert /etc/openvpn/server/issued/server.crt</span><br><span class="line">key /etc/openvpn/server/private/server.key</span><br><span class="line"><span class="meta">#</span> line 85: specify DH file</span><br><span class="line">dh /etc/openvpn/server/dh.pem</span><br><span class="line"><span class="meta">#</span> line 101: specify network to be used on VPN</span><br><span class="line">server 10.8.0.0 255.255.255.0</span><br><span class="line"><span class="meta">#</span> line 143: uncomment and change to your local network</span><br><span class="line">push "route 172.17.0.0 255.255.255.0"</span><br><span class="line"><span class="meta">#</span> line 244: specify TLS-Auth key</span><br><span class="line">tls-auth /etc/openvpn/server/ta.key 0</span><br><span class="line"><span class="meta">#</span> line 263: uncomment (enable compress)</span><br><span class="line">comp-lzo</span><br><span class="line"><span class="meta">#</span> line 287: change log path</span><br><span class="line">status /var/log/openvpn-status.log</span><br><span class="line"><span class="meta">#</span> line 296: change log path</span><br><span class="line">log         /var/log/openvpn.log</span><br><span class="line">log-append  /var/log/openvpn.log</span><br><span class="line"><span class="meta">#</span> Notify the client that when the server restarts so it</span><br><span class="line">explicit-exit-notify 0</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull python:3.8.2</span><br><span class="line">docker run -d --net=host python:3.8.2 /bin/bash -lc "tail -f /dev/null"</span><br><span class="line">git clone https://github.com/dounine/obfsproxy.git</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y python-twisted python-pyptlib python-crypto python-yaml</span><br><span class="line"></span><br><span class="line">./bin/obfsproxy obfs3 --dest=127.0.0.1:2294 server 0.0.0.0:3394</span><br><span class="line">./bin/obfsproxy obfs3 --dest=REMOTE:3394 client 0.0.0.0:9999</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /etc/openvpn/server/ca.crt ./</span><br><span class="line">cp /etc/openvpn/server/ta.key ./</span><br><span class="line">cp /etc/openvpn/server/issued/client.crt ./</span><br><span class="line">cp /etc/openvpn/server/private/client.key ./</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">remote 192.168.0.1 1194</span><br><span class="line">ca ca.crt</span><br><span class="line">cert client.crt</span><br><span class="line">key client.key </span><br><span class="line">tls-auth ta.key 1</span><br><span class="line">comp-lzo</span><br><span class="line">dhcp-option DNS 8.8.8.8</span><br><span class="line">dhcp-option DNS 8.8.4.4</span><br><span class="line">redirect-gateway def1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>运维</category>
      </categories>
  </entry>
  <entry>
    <title>WSSH</title>
    <url>/%E8%BF%90%E7%BB%B4/%E8%BF%90%E7%BB%B4/wssh/</url>
    <content><![CDATA[<h2 id="WSSH"><a href="#WSSH" class="headerlink" title="WSSH"></a>WSSH</h2><p>wssh 是一个 SSH 到 WebSockets 的桥，可以让你通过 HTTP 调用远程服务器的 SHELL 命令。<br>wssh 可以让我们通过 HTTP 来调用远程的一个 shell，也就是说我们可以用浏览器来访问某个 Linux 服务器／虚拟机的终端（只要这个服务器上运行了 wsshd 服务器端）。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>操作系统:CentOS 7<br>python:2.7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc python-devel openssl-devel</span><br><span class="line">pip install gevent flask paramiko gevent-websocket</span><br></pre></td></tr></table></figure>
<p>下载jquery-1.12.3.js和term.js到本地<br>修改/wssh-0.1.0/wssh/templates/index.html<br>修改前:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;application/javascript&quot; src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;application/javascript&quot; src=&quot;https://raw.github.com/chjj/tty.js/36717df8e96f35f4e2bd3fd585e9361f1439fc7e/static/term.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>修改后:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;application/javascript&quot; src=&quot;&#123;&#123;url_for(&apos;static&apos;, filename=&apos;jquery-1.12.3.js&apos;)&#125;&#125;&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;application/javascript&quot; src=&quot;&#123;&#123;url_for(&apos;static&apos;, filename=&apos;term.js&apos;)&#125;&#125;&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>python setup.py install</p>
</blockquote>
<p>启动wsshd</p>
<blockquote>
<p>wsshd</p>
</blockquote>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>报错:<br>/usr/lib/python2.7/site-packages/wssh-0.1.0-py2.7.egg/EGG-INFO/scripts<br>修改前:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from geventwebsocket import WebSocketHandler</span><br></pre></td></tr></table></figure></p>
<p>修改为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from geventwebsocket.handler import WebSocketHandler</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
  </entry>
  <entry>
    <title>计算机</title>
    <url>/A%E6%A6%82%E8%A7%88/A%E6%A6%82%E8%A7%88/%E8%AE%A1%E7%AE%97%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h3><a href="/计算机组成/计算机组成/计算机组成/" title="计算机组成">计算机组成</a>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><h3 id="单片机"><a href="#单片机" class="headerlink" title="单片机"></a>单片机</h3><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2>]]></content>
      <categories>
        <category>A概览</category>
      </categories>
  </entry>
</search>
